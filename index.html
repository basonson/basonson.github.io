<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.0.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"basonson.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.10.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

  <meta name="description" content="学习,分享,进步">
<meta property="og:type" content="website">
<meta property="og:title" content="大牙技术">
<meta property="og:url" content="https://basonson.github.io/index.html">
<meta property="og:site_name" content="大牙技术">
<meta property="og:description" content="学习,分享,进步">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="郭超">
<meta property="article:tag" content="程序员,架构师,极客">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://basonson.github.io/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>大牙技术</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">大牙技术</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Chaos Guo's Personal WebSite</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="郭超"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">郭超</p>
  <div class="site-description" itemprop="description">学习,分享,进步</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">5</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://basonson.github.io/2022/02/14/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%931-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="郭超">
      <meta itemprop="description" content="学习,分享,进步">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大牙技术">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/02/14/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%931-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" class="post-title-link" itemprop="url">Redis技术总结1-数据类型</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-02-14 09:57:31 / Modified: 12:34:53" itemprop="dateCreated datePublished" datetime="2022-02-14T09:57:31+08:00">2022-02-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/NoSQL/" itemprop="url" rel="index"><span itemprop="name">NoSQL</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/NoSQL/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="一．-Redis常用知识"><a href="#一．-Redis常用知识" class="headerlink" title="一． Redis常用知识"></a>一． Redis常用知识</h3><h4 id="1-常用命令"><a href="#1-常用命令" class="headerlink" title="1.  常用命令"></a>1.  常用命令</h4><p><strong>1)    keys *</strong></p>
<p>查看所有键，只看键，不看值。</p>
<p><strong>2)    dbsize</strong></p>
<p>返回当前数据库中键的数量。</p>
<p>dbsize命令在返回结果时，不会遍历所有的键，而是直接获取Redis内置的键总数变量。所以时间复杂度是O(1)。而keys会遍历所有键，所以时间复杂度是O(n)。</p>
<p><strong>通常生产环境禁止使用keys *命令。</strong></p>
<p><strong>3)    exists [key]</strong></p>
<p>返回键是否存在，存在则返回1，不存在返回0。</p>
<p><strong>4)    del [key]</strong></p>
<p>删除键。返回成功删除键的个数。如果尝试删除一个不存在的键，那么返回0。可以同时删除多个键（多个键之间用空格分隔）。</p>
<p><strong>5)    expire [key] [seconds]</strong></p>
<p>对键添加过期时间。</p>
<p><strong>6)    ttl [key]</strong></p>
<p>显示离键过期的剩余时间。三种返回值：</p>
<p>a.   -2：key不存在。</p>
<p>b.   -1：key存在但已经过期。</p>
<p>c.   n：剩余时间(秒)。</p>
<p><strong>7)    type [key]</strong></p>
<p>返回键的类型（5种）。如果键不存在返回none。</p>
<h4 id="2-数据类型及内部编码"><a href="#2-数据类型及内部编码" class="headerlink" title="2.  数据类型及内部编码"></a>2.  数据类型及内部编码</h4><p>Redis有5种数据类型（type命令返回的值）分别是：</p>
<p><strong>string（字符串）</strong></p>
<p><strong>hash（哈希）</strong></p>
<p><strong>list（列表）</strong></p>
<p><strong>set（集合）</strong></p>
<p><strong>zset（有序集合）</strong></p>
<p>每种数据类型都有2种及以上的内部编码，如下图所示：</p>
<p><img src="/2022/02/14/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%931-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/1.png" alt="img"><center><em>Redis数据类型的不同编码</em></center></p>
<p>用object encoding [key] 命令查询编码。</p>
<p>优点：</p>
<p><strong>1.</strong>   Redis可以在不改变对外接口的情况下，对内进行编码改进，提高性能，不影响用户正常使用。</p>
<p><strong>2.</strong>   多种内部编码可以在不同情形下发挥各自的优势。</p>
<p><strong>3.</strong>  单线程架构</p>
<p>Redis使用了单线程架构和I&#x2F;O多路复用模型来实现高性能的内存数据库服务。</p>
<p><img src="/2022/02/14/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%931-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/2.png" alt="img"><center><em>Redis客户端与服务器交互过程</em></center></p>
<p><img src="/2022/02/14/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%931-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/3.png" alt="img"><center><em>命令在队列中等待执行</em></center></p>
<p>Redis单线程但是依然很快的原因：</p>
<p><strong>1.</strong>   <strong>纯内存访问。</strong></p>
<p>Redis所有数据在内存中，内存访问速度可以到达100纳秒。这是Redis达到每秒万级访问的重要基础。</p>
<p><strong>2.</strong>   <strong>非阻塞I&#x2F;O。</strong></p>
<p>Redis使用epoll作为I&#x2F;O多路复用技术的实现，再加上Redis自身的事件处理模型将epoll中的连接、读写、关闭都转换为事件，不在网络I&#x2F;O上浪费过多的时间。</p>
<p>什么是epoll？</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/songchuwang1868/article/details/89877739">https://blog.csdn.net/songchuwang1868/article/details/89877739</a></p>
<p><strong>3.</strong>   <strong>单线程避免了线程切换造成的消耗。</strong></p>
<p>关于线程切换？</p>
<h3 id="二．-数据类型"><a href="#二．-数据类型" class="headerlink" title="二． 数据类型"></a>二． 数据类型</h3><h4 id="1-string-字符串"><a href="#1-string-字符串" class="headerlink" title="1.  string(字符串)"></a>1.  string(字符串)</h4><p>Redis字符串类型的值可以为简单的字符串、复杂的字符串（JSON，XML）、数字（整型，浮点型），甚至二进制（图片，音频，视频），但是最大不能超过512M</p>
<p><strong>1.1  常用命令</strong></p>
<p>除了get，set外，还有setnx，setxx，mset，mget，incr。</p>
<p><strong>1)    setnx&#x2F;setxx</strong></p>
<p>setnx是键必须不存在，才能设置成功，常用于新增。</p>
<p>setxx是键必须存在，才能设置成功，常用于更新。</p>
<p><strong>关键应用场景：</strong></p>
<p>setnx可以作为分布式锁的一种实现方案：如果多个客户端同时执行setnx [key] [value]，根据setnx的特性，只有一个客户端能设置成功。</p>
<p><strong>2)    mset&#x2F;mget</strong></p>
<p>批量执行。</p>
<p><strong>原因：</strong></p>
<p>Redis可以支撑每秒11w次的读操作&#x2F;8w次的写操作，这指的是Redis服务端的处理能力，对于客户端来说，一次命令除了执行时间还有网络时间。</p>
<p>用get命令：n次get时间&#x3D;n次网络时间+n次命令时间</p>
<p>用mget命令：n次get时间&#x3D;1次网络时间+n次命令时间</p>
<p>假如1次网络时间为1ms，1次执行时间为0.1ms。那么1000个get命令时间为1.1s，1个包含1000个key的mget命令为0.101s。</p>
<p><strong>3)    incr</strong></p>
<p>incr命令用于对值做自增操作。返回结果分为三种：</p>
<p>a.   error：值不是整数，返回错误信息。</p>
<p>b.   值是整数，返回自增之后的结果。</p>
<p>c.   键不存在，按照值为0自增，返回1.</p>
<p><strong>1.2  内部编码</strong></p>
<p>字符串类型的内部编码有3种：</p>
<p><strong>1)    int</strong></p>
<p>8个字节的长整型</p>
<p><strong>2)    embstr</strong></p>
<p>小于等于39个字节的字符串</p>
<p><strong>3)    raw</strong></p>
<p>大于39个字节的字符串</p>
<p><strong>1.3  典型场景</strong></p>
<p><strong>1)    最常用的缓存功能</strong></p>
<p><strong>2)    计数器</strong></p>
<p>播放数、点赞数。</p>
<p><strong>3)    共享session</strong></p>
<p>使用Redis对session进行集中管理。</p>
<p><strong>4)    限制操作次数</strong></p>
<p>一个操作之后在Redis中给相应操作增加一个key和一个n秒过期时间，再次操作时判断key是否存在，如果存在那么直接返回失败。</p>
<h4 id="2-hash-哈希"><a href="#2-hash-哈希" class="headerlink" title="2.  hash(哈希)"></a>2.  hash(哈希)</h4><p>哈希类型指的是键的值，本身是一个键值对类型。如下图所示：</p>
<p><img src="/2022/02/14/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%931-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/4.png" alt="img"><center><em>string与hash对比</em></center></p>
<p><strong>2.1  常用命令</strong></p>
<p>命令几乎都是h开头，比如hset，hget，h代表hash。</p>
<p><strong>2.2  内部编码</strong></p>
<p>哈希类型的内部编码有2种：</p>
<p><strong>1)    ziplist</strong></p>
<p>当哈希类型元素个数小于512个、同时所有值都小于64个字节时（512与64均为可配置项），Redis会使用ziplist作为哈希的内部实现。ziplist使用更紧凑的结构实现多个元素的连续存储，在节省内存方面更优秀。</p>
<p><strong>2)    hashtable</strong></p>
<p>当不满足ziplist的条件时，Redis会使用hashtable作为哈希的内部实现。因为此时ziplist的读写效率会下降，但是hashtable的读写时间复杂度是O(1)。</p>
<p><strong>2.3  使用场景</strong></p>
<p>用于缓存关系型数据库表中的每行信息（例如对比图中的用户信息）。但是哈希类型的每个键可以有不同的值，不局限于关系型数据库中的字段。同时，他也不能像关系型数据库那样进行复杂查询。</p>
<p>关于缓存关系型数据库中每行信息（用户信息），有3种方式可以实现：</p>
<p><strong>1)    string字符串类型</strong></p>
<p>每个属性一个键，例如</p>
<p>set user:1:name guoc12</p>
<p>set user:1:age 34</p>
<p>set user:1:city Tianjin</p>
<p>优点：简单直观。</p>
<p>缺点：占用过多的键，内存占用量较大。用户信息内聚性差（在不了解键命名规则的基础上很难查询所有值的信息）</p>
<p><strong>2)    序列化字符串类型</strong></p>
<p>将用户信息序列化后用一个键保存，例如：</p>
<p>set user:1 serialize(userInfo)</p>
<p>优点：简化编程。</p>
<p>缺点：序列化和反序列化需要一定的开销。每次更新某个属性或者获取某个属性都需要将全部属性都取出。</p>
<p><strong>3)    hash哈希类型</strong></p>
<p>每个用户属性使用一个键值对，但都是用一个键保存。</p>
<p>hset user:1 name guoc12 age 34 city Tianjin</p>
<p>优点：简单直观。</p>
<p>缺点：当使用hashtable编码会消耗更多内存。</p>
<h4 id="3-list（列表）"><a href="#3-list（列表）" class="headerlink" title="3.  list（列表）"></a>3.  list（列表）</h4><p>list（列表）用于存储多个有序的字符串，每个字符串称为element（元素），一个list最多存储232-1个元素。</p>
<p>列表有2个特点：</p>
<p><strong>1.   有序</strong></p>
<p><strong>2.   可以重复</strong></p>
<p><strong>3.1  常用命令</strong></p>
<p>列表的命令有很多，可以从列表的两端（r和l）对列表进行push（插入）和pop（弹出）操作。还可以获得指定范围内的元素列表，获取指定索引下标的元素等。</p>
<p>列表命令通常以l，r开头。例如lpush，rpush，ltrim，lrange等等。</p>
<p><strong>1)    ltrim</strong></p>
<p>ltrim [key] [start] [end]</p>
<p>例如一个列表是 testlist中包含 a,s,d,f ，在执行完ltrim testlist 1,3 之后，会剩余s,d,f。</p>
<p><strong>2)    blpop&#x2F;brpop</strong></p>
<p>他们是lpop&#x2F;rpop（左右侧弹出）的阻塞版本。命令如下：</p>
<p>blpop [key…] [seconds]</p>
<p>意思是：</p>
<p>a.    如果可以弹出，那么立即弹出。如果不可以弹出，那么等待seconds秒。期间可以弹出时立即弹出，否则等待时间到后返回nil。当seconds为0时，持续等待。</p>
<p>b.    当key为多个时，比如blpop list1 list2 list3 0，会按照从左至右的顺序，一旦有一个可以弹出，客户端立刻返回。</p>
<p>c.    当多个客户端对同一个键执行blpop命令时，最先执行（命令最先到达Redis服务器）的客户端会获取到弹出的值。剩下的客户端依次弹出或继续阻塞。</p>
<p><strong>3.2  内部编码</strong></p>
<p>list列表类型的内部编码有2种：</p>
<p><strong>1)    ziplist</strong></p>
<p>当列表元素个数小于512个、同时列表中每个元素的值都小于64字节（512与64同样是可配，但与hash类型的配置项不同）。</p>
<p><strong>2)    linkedlist</strong></p>
<p>不满足ziplist条件时，使用linkedlist进行内部实现。</p>
<p><strong>3.3  使用场景</strong></p>
<p><strong>1)    消息队列</strong></p>
<p>lpush+brpop</p>
<p><strong>2)    普通队列</strong></p>
<p>lpush+rpop</p>
<p><strong>3)    栈</strong></p>
<p>lpush+lpop</p>
<p><strong>4)    有限集合</strong></p>
<p>lpush+ltrim</p>
<h4 id="4-set（集合）"><a href="#4-set（集合）" class="headerlink" title="4.  set（集合）"></a>4.  set（集合）</h4><p>set集合也是用来保存多个字符串元素，但是与列表不同：集合中的元素是无序的，并且是不能重复的。一个集合同样能够存储232-1个元素。</p>
<p><strong>4.1  常用命令</strong></p>
<p>集合除了支持增删改查操作外，还支持多个集合取并集、交集、差集等等。</p>
<p>集合命令通常以s开头。</p>
<p><strong>1)    spop&#x2F;srandmember</strong></p>
<p>spop [key] 从集合内随机弹出一个元素</p>
<p>srandmember [key] [count] 从集合内随机返回指定个元素</p>
<p>两者都是随机弹，但是spop命令执行后，元素会从集合中删除，而srandmember不会。</p>
<p><strong>2)    sinter&#x2F;sunion&#x2F;sdiff</strong></p>
<p>sinter [key1] [key2] 返回key1和key2的交集</p>
<p>sunion [key1] [key2] 返回key1和key2的并集</p>
<p>sdiff [key1] [key2] 返回key1和key2的差集（key1里有但是key2里没有的）</p>
<p><strong>4.2  内部编码</strong></p>
<p><strong>1)    intset</strong></p>
<p>当集合中的元素都是整数，且元素个数小于512（可配）个时，Redis会选用intset作为集合的内部实现。</p>
<p><strong>2)    hashtable</strong></p>
<p>当集合类型无法满足intset条件时，Redis会使用hashtable作为内部实现。</p>
<p><strong>4.3  使用场景</strong></p>
<p><strong>1)    标签</strong></p>
<p>sadd</p>
<p><strong>2)    抽奖，随机数</strong></p>
<p>spop&#x2F;srandmember</p>
<p><strong>3)    社交（共同好友，共同关注）</strong></p>
<p>sadd + sinter</p>
<h4 id="5-zset（有序集合）"><a href="#5-zset（有序集合）" class="headerlink" title="5.  zset（有序集合）"></a>5.  zset（有序集合）</h4><p>有序集合跟集合类似，不能有重复成员。不同的是他可以排序。但是他与列表使用下标索引进行排序不同，他给每个元素设置一个score（分数）作为排序的依据。元素不能重复，但是score可以重复。</p>
<p><strong>5.1  常用命令</strong></p>
<p>有序集合的命令通常以z开头。常用命令除增删改查外，还包括计算排名、增加分数、返回排名，返回分数范围内的成员。也支持交集和并集操作但比较复杂。</p>
<p><strong>5.2  内部编码</strong></p>
<p><strong>1)    ziplist</strong></p>
<p>当有序集合的元素个数小于128个，同时每个元素的值都小于64字节时，Redis会使用ziplist作为有序集合的内部实现。</p>
<p><strong>2)    skiplist</strong></p>
<p>当ziplist条件不满足时，使用skiplist作为内部实现。</p>
<p><strong>5.3  使用场景</strong></p>
<p>排行榜系统（按照score查询或排序）</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://basonson.github.io/2022/02/09/MySQL%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="郭超">
      <meta itemprop="description" content="学习,分享,进步">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大牙技术">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/02/09/MySQL%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93-3/" class="post-title-link" itemprop="url">MySQL技术总结-3</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-02-09 11:37:42 / Modified: 14:39:23" itemprop="dateCreated datePublished" datetime="2022-02-09T11:37:42+08:00">2022-02-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="1-架构图"><a href="#1-架构图" class="headerlink" title="1.  架构图"></a>1.  架构图</h3><p><img src="/2022/02/09/MySQL%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93-3/1.png" alt="img"></p>
<p>存储引擎是数据的不同的存储的方式。</p>
<p><strong>1)</strong>    存储方式</p>
<p>存储位置，存储形式等等</p>
<p>例如：</p>
<p>InnoDB中索引文件和数据文件是存储在一个文件中的。（frm存储表结构，idb存储索引和数据）</p>
<p>MyISAM引擎中索引文件和数据文件是分开存放的。（frm存储表结构，MYD存储数据，MYI存储索引）</p>
<p>Memory引擎的数据是存储在内存中的。</p>
<p><strong>2)</strong>    事务</p>
<p>事务型引擎InnoDB和非事务型引擎MyISAM。</p>
<p><strong>3)</strong>    锁。</p>
<p>InnoDB支持表锁行锁，MyISAM支持表锁。。</p>
<p><strong>4)</strong>    索引</p>
<p>InnoDB的索引叶子节点存储数据，而MyISAM存储地址。</p>
<p><strong>5)</strong>    外键</p>
<p>InnoDB支持外键，MyISAM不支持。</p>
<h3 id="2-索引"><a href="#2-索引" class="headerlink" title="2.  索引"></a>2.  索引</h3><p>索引（在MySQL中也叫做键-key），是存储引擎用于快速找到记录的一种数据结构。索引优化是查询性能优化的最有效的手段。</p>
<h4 id="2-1-为什么要设计索引"><a href="#2-1-为什么要设计索引" class="headerlink" title="2.1.   为什么要设计索引"></a>2.1.   为什么要设计索引</h4><p><strong>加快数据访问速度。</strong></p>
<p>数据是存储在文件中，如果我们顺序访问文件，那么速度很慢。如果我们在查询前，能够迅速的知道，应该访问文件的第几行，就会大大提升速度。</p>
<h4 id="2-2-如何设计索引"><a href="#2-2-如何设计索引" class="headerlink" title="2.2.   如何设计索引"></a>2.2.   如何设计索引</h4><p>数据顺序存储在文件中，索引顺序存储在索引文件中。</p>
<p>要确定的信息：</p>
<p><strong>1.</strong>    索引值；</p>
<p><strong>2.</strong>    文件（索引文件与数据文件）的地址；</p>
<p><strong>3.</strong>    偏移量。</p>
<p>但这种设计还是会慢。因为当数据量大的时候，读取索引文件同样会很慢。</p>
<h4 id="2-3-索引的数据结构"><a href="#2-3-索引的数据结构" class="headerlink" title="2.3.   索引的数据结构"></a>2.3.   索引的数据结构</h4><p>数组，哈希，二叉树、红黑树、b树，b+树</p>
<p>官网写的是b树但其实是b+树。</p>
<p>索引是在存储引擎层而不是服务器层实现，所以提到索引是跟引擎相关联的。索引的类型包括：B-Tree索引，哈希索引，空间数据索引，全文索引等等。</p>
<h4 id="2-4-索引实现-哈希"><a href="#2-4-索引实现-哈希" class="headerlink" title="2.4.   索引实现-哈希"></a>2.4.   索引实现-哈希</h4><p>哈希索引基于哈希表实现，是Memory引擎的默认索引类型，也只有Memory显示的支持哈希索引。（Memory引擎也支持B-Tree索引）</p>
<p>假设有一个表：</p>
<table>
<thead>
<tr>
<th>oa</th>
<th>name</th>
</tr>
</thead>
<tbody><tr>
<td>guoc12</td>
<td>郭超</td>
</tr>
<tr>
<td>cuizg1</td>
<td>崔志广</td>
</tr>
<tr>
<td>wanghg6</td>
<td>王怀刚</td>
</tr>
<tr>
<td>zhaijl1</td>
<td>翟静林</td>
</tr>
<tr>
<td>liuzc24</td>
<td>刘作成</td>
</tr>
</tbody></table>
<p>哈希函数f()返回如下值：</p>
<p>f(‘guoc12’)&#x3D;1234;</p>
<p>f(‘cuizg1)&#x3D;5678;</p>
<p>f(‘wanghg6)&#x3D;2345;</p>
<p>f(‘zhaijl1)&#x3D;8765;</p>
<p>f(‘liuzc24)&#x3D;5612;</p>
<p>索引存储的形式如下(不一定是表，最终形式应该是哈希+链表)：</p>
<table>
<thead>
<tr>
<th>槽(slot)</th>
<th>值(value)</th>
</tr>
</thead>
<tbody><tr>
<td>1234</td>
<td>指向第1行的指针</td>
</tr>
<tr>
<td>2345</td>
<td>指向第3行的指针</td>
</tr>
<tr>
<td>5612</td>
<td>指向第5行的指针</td>
</tr>
<tr>
<td>5678</td>
<td>指向第2行的指针</td>
</tr>
<tr>
<td>8765</td>
<td>指向第4行的指针</td>
</tr>
</tbody></table>
<p>索引存储时按照槽值的顺序存储，但是数据行不是。如果查询：select * from table where oa &#x3D; ‘zhaijl1’。MySQL先计算‘zhaijl1’的哈希值，f(‘zhaijl1’)&#x3D;8765，所以MySQL在索引中找到8765，根据值找到指向第4行的指针，最后一步是比较第4行的oa是否为zhaijl1，以确保该行就是要查找的行。</p>
<p>哈希索引的限制是：</p>
<p><strong>1.</strong>    哈希索引只包含哈希值和行指针，而不是存储字段值，所以不能使用索引中的值来避免读取行。</p>
<p><strong>2.</strong>    哈希索引数值并不是按照索引值顺序存储的，所以无法用于排序。</p>
<p><strong>3.</strong>    哈希索引也不支持部分索引列匹配查找，因为哈希索引是用索引列的全部内容计算哈希值。</p>
<p><strong>4.</strong>    哈希索引只支持等值比较查询，包括&#x3D;，IN，&lt;&#x3D;&gt;（比较操作符&lt;&#x3D;&gt;表示NULL安全的等价比较。这个比较操作符执行等价比较，和&#x3D;操作符类似，但是如果两个操作数都是NULL，会返回1，而不是返回NULL；如果其中一个操作数是NULL,会返回0，而不是返回NULL）。不支持任何形式的范围查询。</p>
<p><strong>5.</strong>    当出现哈希冲突时，访问哈希索引上的数据时，存储引擎必须遍历链表中所有行指针，逐行比较，直到找到所有符合条件的行。</p>
<p><strong>6.</strong>    如果哈希冲突很高，一些索引维护操作的代价也会很高。</p>
<p>注意：</p>
<p><strong>1.</strong>    <strong>自适应哈希索引</strong></p>
<p>InnoDB引擎有一个功能叫自适应哈希索引（adaptive hash index），当InnoDB注意到某些索引值被使用的特别频繁时，他会在内存中基于B-Tree索引之上再创建一个哈希索引。这样就会让B-Tree索引也具有哈希索引的优点，比如快速查找。这是一个完全自动的内部的行为，用户无法控制或者配置，不过如果有必要可以关闭该功能。</p>
<p><strong>2.</strong>    <strong>创建自定义哈希索引</strong></p>
<p>思路：创建一个新列，保存哈希索引值。但与真正的哈希索引不同，因为还是用B-Tree进行查找，它使用的是哈希值而不是键本身进行索引查找。</p>
<p>例如存储url时，如果用B-Tree建立索引，会造成索引内容很大，例如：</p>
<p>select id from table where url &#x3D; ‘<a target="_blank" rel="noopener" href="http://www.baidu.com/%E2%80%99">http://www.baidu.com/’</a></p>
<p>这时可以删除原先url列上的索引，新增一个被索引的url_crc列，使用CRC32函数做哈希，如下：</p>
<p>select id from table where url_crc &#x3D; CRC32(‘<a target="_blank" rel="noopener" href="http://www.baidu.com/%E2%80%99">http://www.baidu.com/’</a>) and url &#x3D; ‘<a target="_blank" rel="noopener" href="http://www.baidu.com/%E2%80%99">http://www.baidu.com/’</a></p>
<p>MySQL优化器会使用这个选择性很高而体积很小的基于url_crc列的索引来完成查找。（相对于用完整的url字符串查询，速度提升非常大）</p>
<p>如果采用这种方式，不能使用SHA1()或者MD5()做哈希函数因为这两个函数产生的哈希值，虽然能够避免哈希冲突，但是是非常长的字符串，如果作为索引会类似uuid，浪费大量空间，也会比较慢。</p>
<p>为什么要包含and url &#x3D; ‘<a target="_blank" rel="noopener" href="http://www.baidu.com/%E2%80%99%E8%BF%99%E4%B8%AA%E6%9F%A5%E8%AF%A2%E6%9D%A1%E4%BB%B6%EF%BC%8C%E5%9B%A0%E4%B8%BA%E8%A6%81%E8%A7%A3%E5%86%B3%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%E3%80%82%E5%A6%82%E6%9E%9C%E4%B8%8D%E5%8C%85%E5%90%AB%E8%BF%99%E4%B8%AA%E6%9D%A1%E4%BB%B6%EF%BC%8C%E5%8F%AA%E7%94%A8url_crc%E6%9F%A5%E8%AF%A2%EF%BC%8C%E4%B8%80%E6%97%A6%E5%87%BA%E7%8E%B0%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%EF%BC%8C%E4%BC%9A%E9%80%A0%E6%88%90%E6%9F%A5%E8%AF%A2%E8%BF%94%E5%9B%9E%E5%A4%9A%E6%9D%A1%E8%AE%B0%E5%BD%95%E3%80%82">http://www.baidu.com/’这个查询条件，因为要解决哈希冲突。如果不包含这个条件，只用url_crc查询，一旦出现哈希冲突，会造成查询返回多条记录。</a></p>
<p>除了CRC32()之外，还可以使用FNV64()作为哈希函数（哈希值为64位，速度快，冲突要比CRC32少很多）。</p>
<h4 id="2-5-索引实现-二叉树与红黑树"><a href="#2-5-索引实现-二叉树与红黑树" class="headerlink" title="2.5.   索引实现-二叉树与红黑树"></a>2.5.   索引实现-二叉树与红黑树</h4><p>树形结构是最常见的数据结构之一。</p>
<p>树(Tree)：每个子节点有多棵子树。</p>
<p>二叉树（Binary Tree）：每个节点最多只有左右两棵子树。</p>
<p>二叉搜索树(Binary Search Tree)：每个节点左子树均小于根节点值，右子树均大于根节点值。</p>
<p>二叉平衡搜索树(AVL，发明者名字缩写)：自平衡，二叉搜索树，并且每个节点左右子树高度差不超过1。（查询速度很快，但是增删速度很慢）</p>
<p>红黑树(Red Black Tree)：自平衡，最高不超过最低高度的2倍即可。（对查找和增删的性能做了平衡）</p>
<p><strong>无论二叉树还是红黑树，都因为树的深度过高而搞成io变多，影响数据的读取的效率。</strong></p>
<p>B树(Balance Tree)：任何节点子树的高度差都小于1。多个分支的排序树，降低深度。</p>
<p><img src="/2022/02/09/MySQL%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93-3/2.png" alt="img"></p>
<p>提高速度的关键：减小I&#x2F;O次数；减少I&#x2F;O量。</p>
<h4 id="2-6-索引实现-B树"><a href="#2-6-索引实现-B树" class="headerlink" title="2.6.   索引实现-B树"></a>2.6.   索引实现-B树</h4><p>每个节点放置degree-1个数据，可以在每个节点保存一页的数据。</p>
<p>如下图所示：</p>
<p><img src="/2022/02/09/MySQL%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93-3/3.png" alt="img"></p>
<p>说明：</p>
<p>每个节点占用一个磁盘块，一个节点上有2个升序排序的关键字和3个指向子树根节点的指针，指针存储的是子节点所在磁盘块的地址。2个关键字划分成的三个范围域对应3个指针指向的子树的数据的范围域。以根节点为例，关键字为16和34，P1指针指向的子树的数据范围小于16。P2指针指向的子树的数据范围为16-34。P3指针指向的子树的数据范围大于34。</p>
<p>查找关键字的过程：</p>
<p>根据根节点找到磁盘块1。读入内存（磁盘I&#x2F;O操作1次）</p>
<p>比较关键字28在区间16-34，找到磁盘块1的指针P2。</p>
<p>根据P2指针找到磁盘块3，读入内存（磁盘I&#x2F;O操作2次）</p>
<p>一个磁盘块就是一个页。一个数据块是16k。</p>
<p>3层的B树可以存储多少数据？</p>
<p>假设一个data是1kb，那么一个磁盘块里可以放16个data也就是16条数据（假设剩余不占空间）。那3层就是16<em>16</em>16也就是4096条数据。</p>
<p>为什么3层B树只能存4000条数据？空间浪费在哪了—浪费在data了。</p>
<h4 id="2-7-索引实现-B-树"><a href="#2-7-索引实现-B-树" class="headerlink" title="2.7.   索引实现-B+树"></a>2.7.   索引实现-B+树</h4><p>非叶节点不存data。如下图所示：</p>
<p><img src="/2022/02/09/MySQL%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93-3/4.png" alt="img"></p>
<p>说明：在B+树上有2个头指针，一个指向根节点，另一个指向关键字最小的叶子节点。而且所有的叶子节点（即数据节点）之间是有一种链式的环结构。因此可以对B+树进行2种查找运算：一种是对于主键的范围查找和分页查找；另一种是从根节点开始，进行随机查找。</p>
<p>优化器自己决定是从根节点查找还是从叶子节点头查找。</p>
<p>数据在插入时就做好了排序。</p>
<p>假设一个指针+一个键值是10字节，那么一个数据库16k可以存储1600条数据。第二层也是1600。第三层是16。那么三层的数据量是1600<em>1600</em>16 &#x3D; 40960000条数据。</p>
<p>问题：MySQL里的B+树是几层（深度）。</p>
<p>3层或者4层取决于当前的数据量。</p>
<p>尽可能让16k存储更多的key值。用当前数据块的总大小（16k）除以key值的大小。得出每个块所存数据的多少。然后根据表里的数据量决定是3层还是4层。所以索引越小越好。</p>
<p>前缀索引：不拿字段的所有值当索引，而只拿前n个字符当做索引（left(column_name,3), column_name(3)）。</p>
<p>3层B+树可以支撑千万级别的数据量。具体数字需要看索引大小-&gt;阶。</p>
<h4 id="2-8-索引的优点"><a href="#2-8-索引的优点" class="headerlink" title="2.8.   索引的优点"></a>2.8.   索引的优点</h4><p>索引按照顺序存储数据，所以MySQL可以直接用索引进行ORDER BY和GROUP BY操作。同时因为索引是有序的， 所以该行相关的列值都会存储在一起。最后，因为索引中存储了实际的列值，查询只是用索引就能完成全部查询返回全部结果。</p>
<p>索引的三个优点：</p>
<p><strong>1.</strong>    索引大大减少了服务器需要扫描的数据量。</p>
<p><strong>2.</strong>    索引可以帮助服务器避免排序和临时表。</p>
<p><strong>3.</strong>    索引可以将随机I&#x2F;O变为顺序I&#x2F;O。</p>
<p>索引并不总是最好的解决方案。当索引帮助存储引擎快速查找到记录带来的好处大于其带来的额外工作时，索引才是有效的。对于非常小的表，大部分情况下简单地全表扫描更高效。对于中到大型表，索引就非常有效。对于特大型的表，建立和使用索引的代价会随之增长。</p>
<h3 id="3-高性能索引策略"><a href="#3-高性能索引策略" class="headerlink" title="3.  高性能索引策略"></a>3.  高性能索引策略</h3><p>对B-Tree索引来说，只有如下类型的匹配方式是有效的：</p>
<p>索引匹配方式：</p>
<p><strong>1.</strong>    全值匹配</p>
<p>和索引中的所有列进行匹配。</p>
<p>select * from table where name &#x3D; ? and age &#x3D; ? and pos &#x3D; ? </p>
<p><strong>2.</strong>    匹配最左前缀</p>
<p>只使用索引的前N列。</p>
<p>select * from table where name &#x3D; ?</p>
<p>select * from table where name &#x3D; ? and age &#x3D; ?</p>
<p><strong>3.</strong>    匹配列前缀</p>
<p>只使用某一列值的开头部分。</p>
<p>select * from table where name like ‘J%’</p>
<p><strong>4.</strong>    匹配范围值</p>
<p>索引第一列在某个范围之间。</p>
<p>select * from table where name &gt; ‘Mary’</p>
<p><strong>5.</strong>    精确匹配某一列并范围匹配另一列</p>
<p>第一列全匹配，第二列范围匹配。</p>
<p>select * from table where name &#x3D; ? and age &gt; ?</p>
<p>select * from table where name &#x3D; ? and age &gt; ? and pos &#x3D; ?</p>
<p><strong>6.</strong>    只访问索引的查询</p>
<p>索引覆盖。只用索引值就可以返回查询结果。</p>
<p>select name,age,pos from table where name &#x3D; ? and age &#x3D; ? and pos &#x3D; ?</p>
<p>注意：</p>
<p><strong>1.</strong>    如果不是按照索引的最左列开始查找，那么无法使用索引。</p>
<p>select * from table where pos &#x3D; ?</p>
<p>select * from table where age&#x3D; ?</p>
<p>select * from table where name like ‘%J’</p>
<p><strong>2.</strong>    不能跳过索引中的列。</p>
<p>select * from table where name &#x3D; ? and pos &#x3D; ?</p>
<p>只能使用name作为索引进行查询。</p>
<p><strong>3.</strong>    如果查询中使用了某个列的范围查询，则其右面的所有列都无法使用索引优化查找。</p>
<p>select * from table where name &#x3D; ? and age &gt; ? and pos &#x3D; ?</p>
<p>只能使用name和age做索引进行查询。</p>
<h4 id="3-1-独立的列"><a href="#3-1-独立的列" class="headerlink" title="3.1.   独立的列"></a>3.1.   独立的列</h4><p>独立的列指的是索引列不能是表达式的一部分，也不能是函数的参数。如果查询中的列不是独立的，MySQL不会使用索引。</p>
<p>select * from table where name + 1 &#x3D; 30</p>
<p>select * from table where TO_DAYS(CURRENT_DATE) – TO_DAYS(date_col) &gt; 10</p>
<h4 id="3-2-索引选择性和前缀索引"><a href="#3-2-索引选择性和前缀索引" class="headerlink" title="3.2.   索引选择性和前缀索引"></a>3.2.   索引选择性和前缀索引</h4><p>索引选择性是指：不重复的索引值（也称为基数）和数据表的记录总数（#T）的比值，范围从1&#x2F;#T到1之间。索引的选择性越高则查询效率越高，因为选择性高的索引可以让MySQL在查找时过滤掉更多的行。唯一索引的选择性是1，性能是最好的。</p>
<p>前缀索引指的是当索引列字符数很多时，会让索引变得大而且慢，所以可以只将开始的部分字符作为索引，这样可以节约索引空间，提高索引效率。但是会降低索引选择性。</p>
<p>关键在于选择足够长的前缀保证较高的选择性，同时又不能太长（以便节约空间）。前缀的基数应该接近于完整列的基数。</p>
<p>前缀索引是一种能使索引更小、更快的有效办法，但另一方面也有缺点：MySQL无法使用前缀索引做ORDER BY和GROUP BY， 也无法使用前缀索引做覆盖扫描。</p>
<p>有时候后缀索引也有用途，例如找到某个域名的所有电子邮件地址。MySQL原生并不支持反向索引，但是可以将字符串翻转后存储，并基于此建立前缀索引。</p>
<h4 id="3-3-多列索引"><a href="#3-3-多列索引" class="headerlink" title="3.3.   多列索引"></a>3.3.   多列索引</h4><p>关于多列索引常见的错误是：为每个列创建独立的索引，或者按照错误的顺序创建多列索引。</p>
<p>在多个列上建立独立的单列索引大部分情况下并不能提高MySQL的查询性能。</p>
<p>在5.0版本之后的MySQL，如果同时有2个列查询（在此两列上各有一个索引），查询能够同时使用这两个单列索引进行扫描，并将结果进行合并，叫做索引合并策略。</p>
<p>索引合并策略是一种优化的结果，但实际上说明了这个表上的索引建立的比较糟糕。</p>
<p><strong>1.</strong>    当出现服务器对多个索引做相交操作时（通常有多个and条件），通常意味着需要一个包含所有相关列的多列索引，而不是多个独立的单列索引。</p>
<p><strong>2.</strong>    当服务器需要对多个索引做联合操作时（通常有多个or条件），通常需要耗费大量CPU和内存资源在算法的缓存、排序和合并操作上，特别是当其中有些索引的选择性不高，需要合并扫描返回的大量数据的时候。</p>
<p><strong>3.</strong>    优化器不会把这些计算到查询成本中，优化器只关心随机页面读取。这会使得查询的成本被“低估”，导致该执行计划还不如直接走全表扫描。</p>
<h4 id="3-4-选择合适的索引列顺序"><a href="#3-4-选择合适的索引列顺序" class="headerlink" title="3.4.   选择合适的索引列顺序"></a>3.4.   选择合适的索引列顺序</h4><p>最常用的经验：将选择性最高的列放到索引的最前列。</p>
<p>如果有具体的多条件查询，可以用不同条件分别进行查询，将对应条件的结果数量最小的列放在最前。</p>
<p>如果查询语句性能很慢，而不同条件查询出的数量都很多，那么应该从程序角度来尝试修改或取消这种业务的查询。</p>
<h4 id="3-5-聚簇索引"><a href="#3-5-聚簇索引" class="headerlink" title="3.5.   聚簇索引"></a>3.5.   聚簇索引</h4><p>聚簇索引并不是单独的一种索引类型，而是一种数据存储方式。也就是说数据跟索引是不是放在一起。 对InnoDB的主键索引来说，是聚簇索引。对MyISAM来说，是非聚簇索引。</p>
<p>MyISAM和InnoDB都是采用的B+树，但是有区别：</p>
<p><strong>1.</strong>    MyISAM中，叶子节点存储该行数据的存储地址。</p>
<p><strong>2.</strong>    InnoDB中，叶子节点直接放该行全部数据</p>
<p><strong>1)</strong>   InnoDB通过B+树结构对主键创建索引，在叶子节点中存储记录。如果没有主键，那么选择唯一键。如果没有唯一键，那么会生成一个6字节的row_id作为主键。</p>
<p><strong>2)</strong>   如果创建索引的键是其他字段，那么叶子节点中存储的是该记录的主键，然后再通过主键索引找到对应的记录，这叫做回表。</p>
<p>聚簇索引的优点：</p>
<p><strong>1.</strong>    可以把相关的数据保存到一起。</p>
<p><strong>2.</strong>    数据访问更快。</p>
<p>缺点：</p>
<p><strong>1.</strong>    最大限度的提高了I&#x2F;O密集型应用的性能，但如果全部数据都在内存中，那么访问顺序就不重要了，聚簇索引也就没什么优势了。</p>
<p><strong>2.</strong>    插入速度严重依赖于插入顺序。按照逐渐顺序插入时加载数据到InnoDB表中速度最快的方式。</p>
<p><strong>3.</strong>    更新聚簇索引列的代价很高，因为会强制InnoDB将每个被更新的行移动到新的位置。</p>
<p><strong>4.</strong>    基于聚簇索引的表在插入新行，或者主键被更新导致需要移动行的时候，可能面临页分裂的问题。</p>
<p><strong>5.</strong>    聚簇索引可能导致全表扫描变慢，尤其是行比较稀疏或者由于页分裂导致数据存储不连续的时候。</p>
<p><strong>6.</strong>    二级索引（非聚簇索引）会比想象中大，因为在二级索引的叶子节点包含了引用行的主键列。</p>
<p><strong>7.</strong>    二级索引访问需要两次索引查找，而不是一次。</p>
<p>每增加一个索引就是一棵树。InnoDB主键索引树中叶子节点存的是该行全部数据，二级索引树中叶子节点存储的是主键值。这意味着如果通过二级索引查找行，存储引擎需要找到二级索引的叶子节点获得对应的主键值，然后根据这个值去聚簇索引中查找到对应的行。即：两次B-Tree查找，也即回表。</p>
<p>对自增主键来说，插入时要做的操作会少很多（页分裂，页合并），查询也会简单。</p>
<p>例如一个表（col1是主键，col2列上有B-Tree索引）：</p>
<table>
<thead>
<tr>
<th>行号</th>
<th>col1</th>
<th>col2</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>99</td>
<td>8</td>
</tr>
<tr>
<td>1</td>
<td>12</td>
<td>56</td>
</tr>
<tr>
<td>2</td>
<td>3000</td>
<td>62</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>9997</td>
<td>18</td>
<td>8</td>
</tr>
<tr>
<td>9998</td>
<td>4700</td>
<td>13</td>
</tr>
<tr>
<td>9999</td>
<td>3</td>
<td>93</td>
</tr>
</tbody></table>
<p><strong>MyISAM****的数据分布</strong>：MyISAM按照数据插入的顺序存储在磁盘上。主键索引如下图所示：</p>
<p><img src="/2022/02/09/MySQL%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93-3/5.png" alt="img"></p>
<p>col2列索引如下图所示：</p>
<p><img src="/2022/02/09/MySQL%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93-3/6.png" alt="img"></p>
<p>可以看出，MyISAM引擎主键索引和其他索引在结构上并没有区别。主键索引就是一个名为PRIMARY的唯一非空索引。</p>
<p><strong>InnoDB****的数据分布</strong>：InnoDB的主键索引（聚簇索引）如下图所示：</p>
<p><img src="/2022/02/09/MySQL%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93-3/7.png" alt="img"></p>
<p>二级索引col2列索引如下图所示：</p>
<p><img src="/2022/02/09/MySQL%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93-3/8.png" alt="img"></p>
<p><strong>在InnoDB表中按照主键顺序插入行</strong></p>
<p>在InnoDB的表中的主键，最好与应用无关(代理主键而非自然主键)，例如自增列，保证数据行是按顺序写入，同时做关联操作的性能会更好。最坏的情况是I&#x2F;O密集型应用中的UUID主键，他会使得聚簇索引的插入完全变得随机。</p>
<table>
<thead>
<tr>
<th>表名</th>
<th>行数</th>
<th>时间（秒）</th>
<th>索引大小（MB）</th>
</tr>
</thead>
<tbody><tr>
<td>userinfo</td>
<td>100w</td>
<td>137</td>
<td>342</td>
</tr>
<tr>
<td>userinfo_uuid</td>
<td>100w</td>
<td>180</td>
<td>544</td>
</tr>
<tr>
<td>userinfo</td>
<td>300w</td>
<td>1233</td>
<td>1036</td>
</tr>
<tr>
<td>userinfo_uuid</td>
<td>300w</td>
<td>4525</td>
<td>1707</td>
</tr>
</tbody></table>
<p>在300w数据量时，uuid主键表的插入顺序变为自增id主键表插入顺序的3倍，索引大小变为1.5倍。</p>
<p>一方面是因为主键字段更长，另一方面是因为页分裂和碎片导致的。</p>
<p><img src="/2022/02/09/MySQL%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93-3/9.png" alt="img"></p>
<p>因为主键值是顺序的，所以InnoDB把每一条记录存储在上一条记录的后面。当达到页的最大填充因子（InnoDB默认最大填充因子是页大小的15&#x2F;16，留出部分空间用于以后修改），下一条记录会写入新的页中。一旦数据按照这种顺序方式加载，主键页就会近似于被顺序的记录填满。这也正是预期的结果。</p>
<p><img src="/2022/02/09/MySQL%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93-3/10.png" alt="img"></p>
<p>因为新行的键值不一定比之前键值大，所以InnoDB会为他寻找合适的位置，通常是已有数据的中间位置，并且为他分配空间。这会增加很多额外的工作，并且导致分布不够优化。如下：</p>
<p><strong>1.</strong>   写入目标页可能已经刷新到硬盘并且从缓存中移除，或是还没被加载到缓存中。InnoDB在插入之前不得不先从磁盘读取目标页加载到内存中，这会导致大量的随机I&#x2F;O。</p>
<p><strong>2.</strong>   因为写入是乱序的，InnoDB不得不做频繁的页分裂操作，以便为新行分配空间。页分裂会导致移动大量数据，一次插入最少需要修改三个页而不是一个页。</p>
<p><strong>3.</strong>   由于频繁的页分裂，页会变的稀疏并被不规则的填充，所以最终数据会有碎片。</p>
<p><strong>4.</strong>   在将随机值插入到聚簇索引之后，也许需要做一次OPTIMIZE TABLE来优化页的填充。</p>
<p>所以，使用InnoDB应尽可能地按照主键顺序插入数据，并尽可能的使用单调增加的主键值插入新行。</p>
<h4 id="3-6-覆盖索引"><a href="#3-6-覆盖索引" class="headerlink" title="3.6.   覆盖索引"></a>3.6.   覆盖索引</h4><p>如果一个索引包含（或者说覆盖）所有需要查询的字段的值，那么称为覆盖索引。</p>
<p>索引覆盖可以极大地提升性能：</p>
<p><strong>1.</strong>    索引条目通常远小于数据行大小，所以如果只读取索引，会极大地减少访问量。将花在数据拷贝上的时间大大减少，同时数据也会更容易的放入内存中。</p>
<p><strong>2.</strong>    因为索引时按照列值顺序存储，所有对于I&#x2F;O密集型的范围查询会比随机从磁盘读取每一行数据的I&#x2F;O要少得多。</p>
<p><strong>3.</strong>    一些存储引擎例如MyISAM在内存中只缓存索引，数据依赖于操作系统缓存，所以每次访问数据都需要一次系统调用，这可能导致严重的性能问题。</p>
<p><strong>4.</strong>    由于InnoDB的聚簇索引，如果二级索引能够覆盖查询，可以避免对主键索引的二次查询。</p>
<p>但并不是说所有的索引都能实现覆盖索引，例如哈希索引、空间索引、全文索引等等，因为都不存储索引列的值，所以在MySQL当中，只能使用B-Tree索引做覆盖索引。</p>
<p>EXPLAIN解析结果可以看出Extra的值为Using index，表示已经使用了索引覆盖。</p>
<h4 id="3-7-索引下推"><a href="#3-7-索引下推" class="headerlink" title="3.7.   索引下推"></a>3.7.   索引下推</h4><p>索引下推（index condition pushdown ）又叫索引条件推送，简称ICP，在MySQL5.6的版本上推出，用于优化查询。</p>
<p>在不使用ICP的情况下，在使用非主键索引进行查询时，存储引擎通过索引检索到数据，然后返回给MySQL服务器，服务器然后判断数据是否符合条件 。</p>
<p>在使用ICP的情况下，如果存在某些被索引的列的判断条件时，MySQL服务器将这一部分判断条件传递给存储引擎，然后由存储引擎通过判断索引是否符合MySQL服务器传递的条件，只有当索引符合条件时才会将数据检索出来返回给MySQL服务器 。</p>
<p>假如查询中有3个条件，当查询的时候，先将符合条件1的结果取出，放到MySQL服务器，再进行条件2和条件3的筛选。这是未进行索引下推。</p>
<p>假如在查询的时候，一次性将符合条件123的结果全部取出，放到MySQL服务层。这就叫索引下推。</p>
<p>索引条件下推优化可以减少回表次数，也可以减少MySQL服务器从存储引擎接收数据的次数。</p>
<p>假设一张用户表(user)，其中主要几个字段有：id、name、age、pos。有联合索引（name，age）。</p>
<p><strong>第一种情况：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;陈%&#x27;</span></span><br></pre></td></tr></table></figure>

<p>根据 “最佳左前缀” 的原则，这里使用了联合索引（name，age）进行了查询，性能要比全表扫描肯定要高。</p>
<p><strong>第二种情况：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;陈xx&#x27;</span> <span class="keyword">and</span> age<span class="operator">=</span><span class="number">20</span></span><br></pre></td></tr></table></figure>

<p><strong>1.</strong>    在MySQL 5.6之前版本，会忽略age这个字段，直接通过name进行查询，在(name,age)这课树上查找到了两个结果，id分别为2,1，然后拿着取到的id值一次次的回表查询，因此这个过程需要回表两次。</p>
<p><strong>2.</strong>    在MySQL 5.6之后版本，InnoDB并没有忽略age这个字段，而是在索引内部就判断了age是否等于20，对于不等于20的记录直接跳过，因此在(name,age)这棵索引树中只匹配到了一个记录，此时拿着这个id去主键索引树中回表查询全部数据，这个过程只需要回表一次。</p>
<p>EXPLAIN解析结果可以看出Extra的值为Using index condition，表示已经使用了索引下推。</p>
<p>索引下推唯一的缺点是需要在磁盘上多做数据筛选，原先的筛选是放在内存中的，现在放在了磁盘中进行查找数据的环节，这样做看起来成本高了，但是数据是排序的，所有的数据是聚集存放，所以性能不会有影响，而且整体的I&#x2F;O量大大减少了，性能反而提升了</p>
<h4 id="3-8-使用索引扫描排序"><a href="#3-8-使用索引扫描排序" class="headerlink" title="3.8.   使用索引扫描排序"></a>3.8.   使用索引扫描排序</h4><p>MySQL有两种方式生成有序的结果：通过排序操作；按照索引顺序扫描。如果EXPLAIN的结果type列为index（Extra没有出现Using filesort），标识MySQL使用了索引扫描进行排序。</p>
<p>扫描索引本身很快，如果MySQL可以使用同一个索引既满足排序，又用于查找查找行，这样是最好的。</p>
<p>只有当索引的列顺序和ORDER BY子句的顺序完全一致，并且所有列的排序方向（正序或倒序）都一样时，MySQL才可以使用索引对结果进行排序。如果查询需要关联多张表，则只有当ORDER BY子句引用的字段全部为第一个表时，才能使用索引做排序。ORDER BY子句需要满足索引的最左前缀要求，否则MySQL无法用索引排序。</p>
<p>有一种特殊情况ORDER BY子句可以不满足索引的最左前缀要求，就是前导列为常量的时候。</p>
<p>例如：</p>
<p>假设一张用户表(user)，其中主要几个字段有：id、name、age、pos、remark。有联合索引（age,name,pos）。</p>
<p><strong>1.</strong>    SELECT id FROM user where age &#x3D; 20 ORDER BY name, pos</p>
<p>即使ORDER BY子句并不满足索引的最左前缀要求，也可以用于查询排序，这是因为索引的第一列被指定为一个常数。</p>
<p><strong>2.</strong>    SELECT id FROM user where age &#x3D; 20 ORDER BY name</p>
<p>第一列是常量，用第二列排序，相当于索引的最左前缀。</p>
<p><strong>3.</strong>    SELECT id FROM user where age &gt; 20 ORDER BY age,name</p>
<p>使用的ORDER BY两列就是索引的最左前缀。</p>
<p>下面几种情况是不能用索引做排序的查询：</p>
<p><strong>1.</strong>    … WHERE age &#x3D; 20 ORDER BY name DESC, pos ASC</p>
<p>两种不同的排序方向。</p>
<p><strong>2.</strong>    … WHERE age &#x3D; 20 ORDER BY name, remark</p>
<p>引用了不在索引中的列。</p>
<p><strong>3.</strong>    … WHERE age &#x3D; 20 ORDER BY pos</p>
<p>WHERE和ORDER BY中的子句无法组成索引的最左前缀</p>
<p><strong>4.</strong>    … WHERE age &gt; 20 ORDER BY name, pos</p>
<p>索引上的第一列是范围条件。</p>
<p><strong>5.</strong>    … WHERE age &#x3D; 20 AND name IN (‘A’,’B’) ORDER BY pos</p>
<p>name列上有多个等于条件，也是一种范围查询。</p>
<h4 id="3-9-压缩索引（前缀压缩）"><a href="#3-9-压缩索引（前缀压缩）" class="headerlink" title="3.9.   压缩索引（前缀压缩）"></a>3.9.   压缩索引（前缀压缩）</h4><p>MyISAM使用前缀压缩来减少索引的大小，从而让更多的索引可以放到内存中，这在某些情况下可以极大地提升性能。</p>
<p>MyISM压缩每个索引块的方法是：先完全保存索引块中的第一个值，然后将其他值和第一个值进行比较得到相同的前缀字节数和不同的后缀部分，存储即可。例如，所以块的第一个值是config,第二个值是configuration,那么第二个值压缩之后存储的值类似6,uration。</p>
<p>压缩块节省了空间，代价是某些操作可能会慢。因为每个值的压缩前缀都依赖于前面的值，所以MyISAM查找时无法在索引块使用二分查找只能从头开始扫描。在块中查找某一行的操作平均都需要扫描半个索引块。</p>
<h4 id="3-10-冗余和重复索引"><a href="#3-10-冗余和重复索引" class="headerlink" title="3.10.  冗余和重复索引"></a>3.10.  冗余和重复索引</h4><p>重复索引指的是在相同的列上按照相同的顺序创建相同类型的索引。应当避免这样创建重复索引，发现后也应该立即移除。</p>
<p>冗余索引与重复索引有所不同，例如：</p>
<p><strong>1.</strong>    如果创建了索引（A,B），再创建索引(A)就是冗余索引，因为这是索引(A,B)的前缀索引，索引（A,B）也可以当做索引（A）使用。</p>
<p><strong>2.</strong>    创建索引（A,ID），ID是主键。对于InnoDB来说主键列已经包含在二级索引中了，所以这也是冗余的。</p>
<h3 id="4-EXPLAIN"><a href="#4-EXPLAIN" class="headerlink" title="4.  EXPLAIN"></a>4.  EXPLAIN</h3><p>基于表的设计、列、索引、还有查询语句中的where条件，MySQL优化器会使用很多技术来更好地执行查询。查询最终会变成一堆操作的集合，这个集合是MySQL优化器选择的最有效的执行这个查询的操作集合，也就是执行计划（query execution plan， 也叫作EXPLAIN plan）。</p>
<p>EXPLAIN返回的结果是MySQL执行语句的信息，EXPLAIN可以应用于SELECT, UPDATE, DELETE, INSERT, REPLACE。</p>
<p>EXPLAIN给每一个SELECT语句中的表，按照MySQL执行语句时的顺序，都返回了一行信息，用以表示执行计划的信息。（多表join时，mysql的查询方式）</p>
<p>EXPLAIN的输出格式</p>
<p><img src="/2022/02/09/MySQL%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93-3/11.png" alt="img"></p>
<p>关于各字段含义：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>主键</td>
</tr>
<tr>
<td>select_type</td>
<td>查询类型</td>
</tr>
<tr>
<td>table</td>
<td>表名，每个表一条数据</td>
</tr>
<tr>
<td>partitions</td>
<td>匹配的分区</td>
</tr>
<tr>
<td><strong>type</strong></td>
<td><strong>关键字段：查询类型</strong></td>
</tr>
<tr>
<td>possible_keys</td>
<td>可能选择的索引</td>
</tr>
<tr>
<td><strong>key</strong></td>
<td><strong>关键字段：实际选择的索引</strong></td>
</tr>
<tr>
<td>key_len</td>
<td>选择索引的长度</td>
</tr>
<tr>
<td>ref</td>
<td>索引对应的列</td>
</tr>
<tr>
<td>rows</td>
<td>预估的行数</td>
</tr>
<tr>
<td>filtered</td>
<td>查询扫描行数的百分比</td>
</tr>
<tr>
<td><strong>Extra</strong></td>
<td><strong>关键字段：额外信息</strong></td>
</tr>
</tbody></table>
<h4 id="4-1-type"><a href="#4-1-type" class="headerlink" title="4.1.    type"></a>4.1.    type</h4><p>type列标识查询的类型，效果从最好到最坏依次是：</p>
<p><strong>1)</strong>   <strong>system</strong></p>
<p>表只有一行（系统表）。一个const类型的特例。</p>
<p><strong>2)</strong>   <strong>const</strong></p>
<p>表只有一行匹配，这一行会在查询开始的时候就被读取。非常快。</p>
<p>在用主键索引或唯一索引查询时，type列为const。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>3)</strong>   <strong>eq_ref</strong></p>
<p>只返回一行。使用主键或唯一索引时，才会有eq_ref。</p>
<p><strong>4)</strong>   <strong>ref</strong></p>
<p>索引访问，返回所有匹配某个单个值的行。</p>
<p><strong>5)</strong>   <strong>fulltext</strong></p>
<p>全文索引。</p>
<p><strong>6)</strong>   <strong>ref or null</strong></p>
<p>跟ref类似，但是包含NULL值判断。</p>
<p><strong>7)</strong>   <strong>index merge</strong></p>
<p>索引合并。索引合并优化策略启用时出现，此时key列中会显示使用的索引列表。</p>
<p><strong>8)</strong>   <strong>unique subquery</strong></p>
<p>在一些in子查询中替代eq_ref。</p>
<p><strong>9)</strong>   <strong>index subquery</strong></p>
<p>与unique subquery类似，在in子查询中，使用非唯一索引时出现。</p>
<p><strong>10)</strong>  <strong>range</strong></p>
<p>在索引确定的范围内返回行。key列标识用到哪个索引，ref列为NULL。</p>
<p>当使用比较符&#x3D;, &lt;&gt;, &gt;, &gt;&#x3D;, &lt;, &lt;&#x3D;, IS NULL, &lt;&#x3D;&gt;, BETWEEN, LIKE, 或者 IN() 函数时，会出现range。</p>
<p><strong>11)</strong>  <strong>index</strong></p>
<p>跟ALL形式一样，全表扫描。但是会按照索引次序。有两种情况：</p>
<p>a.   覆盖索引。此时Extra列会显示Using index</p>
<p>b.   通过查询索引列进行全表扫描。</p>
<p><strong>12)</strong>  <strong>ALL</strong></p>
<p>全表扫描。</p>
<h4 id="4-2-Extra"><a href="#4-2-Extra" class="headerlink" title="4.2.    Extra"></a>4.2.    Extra</h4><p>一些额外信息，但很重要。</p>
<p><strong>1)</strong>   <strong>Using index</strong></p>
<p>索引覆盖。</p>
<p><strong>2)</strong>   <strong>Using index condition</strong></p>
<p>索引下推。</p>
<p><strong>3)</strong>   <strong>Using filesort</strong></p>
<p>排序时没有使用到索引，而是使用内存排序或磁盘排序（统称为文件排序，filesort）。</p>
<p><strong>4)</strong>   <strong>Using temporary</strong> </p>
<p>查询中使用了中间表存储临时结果。</p>
<p><strong>5)</strong>   <strong>Using where</strong></p>
<p>存储引擎检索过行之后，服务器层进行过滤。如果type是index或者All，Extra没有Using where，通常会有问题。</p>
<p><strong>6)</strong>   <strong>Using MRR</strong></p>
<p>MRR（Multi Range Read），将随机I&#x2F;O变为顺序I&#x2F;O。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> name <span class="operator">=</span> ?</span><br></pre></td></tr></table></figure>

<p>结果是1000行，在二级索引树取出1000个id后，在主键树中一个一个的进行查找，速度会比较慢。</p>
<p>MRR:取出1000个id后，在内存中进行排序，然后在主键树中做顺序查找。</p>
<h3 id="5-实验"><a href="#5-实验" class="headerlink" title="5.  实验"></a>5.  实验</h3><p>建立组合索引abc，不同sql语句使用索引情况</p>
<table>
<thead>
<tr>
<th>语句</th>
<th>是否使用索引</th>
<th>索引使用情况</th>
</tr>
</thead>
<tbody><tr>
<td>where a &#x3D; 3</td>
<td>是</td>
<td>只使用a</td>
</tr>
<tr>
<td>where a &#x3D; 3 and b &#x3D; 5</td>
<td>是</td>
<td>使用a,b</td>
</tr>
<tr>
<td>where b &#x3D; 3 and a &#x3D; 5</td>
<td>是</td>
<td>使用a,b</td>
</tr>
<tr>
<td>where a &#x3D; 3 and b &#x3D; 5 and c &#x3D; 4</td>
<td>是</td>
<td>使用a,b,c</td>
</tr>
<tr>
<td>where b &#x3D; 3 or c &#x3D; 4</td>
<td>？</td>
<td>-</td>
</tr>
<tr>
<td>where a &#x3D; 3 and c &#x3D; 4</td>
<td>是</td>
<td>只使用a</td>
</tr>
<tr>
<td>where a &#x3D; 3 and b &gt; 10 and c  &#x3D; 7</td>
<td>？</td>
<td>使用a,b</td>
</tr>
<tr>
<td>where a &#x3D; 3 and b like ‘%xx%’  and c &#x3D; 4</td>
<td>是</td>
<td>只使用a</td>
</tr>
</tbody></table>
<p>疑问：</p>
<p><strong>1.</strong>   where b&#x3D;3 or c&#x3D;4时 是否使用索引。</p>
<p><strong>2.</strong>   where a &#x3D; 3 and b &gt; 10 and c &#x3D; 7 使用索引中的几列。</p>
<p>回答：具体情况具体分析。</p>
<p>如果一个表的所有列都做了组合索引，那么不管怎么查数据，都会用到组合索引。</p>
<p>如果加了多余的一列之后，那么就不会用到索引了。</p>
<p>一些意见：</p>
<p><strong>1.</strong>   当使用索引列进行查询时尽量不要使用表达式，把计算放到业务层也不是数据库层。</p>
<p><strong>2.</strong>   尽量使用主键查询，而不是其他索引，因为主键查询不会触发回表。</p>
<p><strong>3.</strong>   使用前缀索引</p>
<p><strong>4.</strong>   使用索引扫描来排序</p>
<p><strong>5.</strong>   union all，in，or都会使用索引，但是推荐使用in</p>
<p><strong>6.</strong>   范围列可以使用索引（&gt;,&gt;&#x3D;,&lt;,&lt;&#x3D;,between）但范围列后面的列无法用到索引，索引最多用于一个范围列</p>
<p><strong>7.</strong>   强制类型转换会全表扫描</p>
<p>phone是varchar型</p>
<p>隐式类型转换也会使得索引无效</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> phone <span class="operator">=</span> <span class="number">13000000000</span>; <span class="comment">-- 不会触发索引</span></span><br><span class="line"></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> phone <span class="operator">=</span> <span class="string">&#x27;13000000000&#x27;</span> <span class="comment">-- 会触发索引</span></span><br></pre></td></tr></table></figure>

<p><strong>8.</strong>   更新频繁的，数据区分度不高的字段上不宜建立索引</p>
<p>a.   更新会变更b+树，更新频繁的字段建立索引会大大降低数据库性能。</p>
<p>b.   类似于性别之类的字段，建立索引没有意义。</p>
<p>c.   一般区分度在80%以上的时候可以建立索引，区分度用count(distinct(column_name))&#x2F;count(*)计算。   </p>
<p><strong>9.</strong>   创建索引的列，不允许为null，因为可能会得到不符合预期的结果。</p>
<p><strong>10.</strong>  当需要进行表连接的时候，最好不要超过3张表，因为需要join的字段，数据类型必须一致。</p>
<p><strong>11.</strong>  能使用limit的时候尽量使用limit。</p>
<p><strong>12.</strong>  单表索引尽可能控制在5个以内。（但是现在没有太多的限制了）</p>
<p><strong>13.</strong>  单索引字段数不允许超过5个（组合索引）</p>
<p><strong>14.</strong>  创建索引的时候应该避免以下概念：索引越多越好；过早优化或者在不了解系统时进行优化。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://basonson.github.io/2022/02/09/MySQL%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="郭超">
      <meta itemprop="description" content="学习,分享,进步">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大牙技术">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/02/09/MySQL%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93-2/" class="post-title-link" itemprop="url">MySQL技术总结-2</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-02-09 10:17:41 / Modified: 11:39:43" itemprop="dateCreated datePublished" datetime="2022-02-09T10:17:41+08:00">2022-02-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="1．-Schema与数据类型优化"><a href="#1．-Schema与数据类型优化" class="headerlink" title="1． Schema与数据类型优化"></a>1． Schema与数据类型优化</h3><p>选择正确的数据类型，几个基本的原则如下：</p>
<p><strong>a.</strong>   更小的通常更好</p>
<p>一般情况下，应该尽量使用可以正确存储数据的最小数据类型。更小的数据类型通常更快，因为他们占用更小的磁盘空间、内存和CPU缓存，处理时需要的CPU周期也更少。</p>
<p><strong>b.</strong>   越简单越好</p>
<p>简单的数据类型的操作通常需要更少的CPU周期。例如，整型比字符串操作代价更低，因为字符集和校对规则（排序规则）使字符比整型更复杂。</p>
<p><strong>c.</strong>   尽量避免NULL</p>
<p>如果查询包含可为NULL的列，对MySQL来说更难优化，因为可为NULL的列使得索引、索引统计和值比较都更复杂。</p>
<h4 id="1-1-整数类型"><a href="#1-1-整数类型" class="headerlink" title="1.1  整数类型"></a>1.1  整数类型</h4><p>MySQL支持的整数类型有TINYINT、SMALLINT、MEDIUMINT、INT（INTEGER）、BIGINT，分别使用8,16,24,32,64位存储空间，存储的值范围是-2（N-1）到2（N-1）-1。</p>
<p>可选的UNSIGNED属性会将正数上限提高一倍。如下表所示：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>位数</th>
<th>有符号最小</th>
<th>有符号最大</th>
<th>无符号最小</th>
<th>无符号最大</th>
</tr>
</thead>
<tbody><tr>
<td>TINYEINT</td>
<td>8</td>
<td>-128</td>
<td>127</td>
<td>0</td>
<td>255</td>
</tr>
<tr>
<td>SMALLINT</td>
<td>16</td>
<td>-32768</td>
<td>32767</td>
<td>0</td>
<td>65535</td>
</tr>
<tr>
<td>MEDIUMINT</td>
<td>24</td>
<td>-8388608</td>
<td>8388607</td>
<td>0</td>
<td>16777215</td>
</tr>
<tr>
<td>INT</td>
<td>32</td>
<td>-2147483648</td>
<td>2147483647</td>
<td>0</td>
<td>4294967295</td>
</tr>
<tr>
<td>BIGINT</td>
<td>64</td>
<td>-263</td>
<td>263-1</td>
<td>0</td>
<td>264-1</td>
</tr>
</tbody></table>
<p>有无符号使用相同的存储空间与性能，需要根据实际情况进行选择。（JAVA开发规范中，要求主键使用UNSIGNED BIGINT）。</p>
<p><strong>为整数类型指定的宽度，例如INT(11)，其中的11并不代表整数的最大位数，他只是规定了MySQL的一些交互工具（例如命令行客户端）用来显示字符的个数。对于存储和计算来说，INT(1)与INT(11)是相同的。</strong></p>
<p>在设定ZEROFILL（填充零）属性后，会依据设定的宽度，在列的值的左侧补充0，作为补充显示。如果值本身长度超过了设定的宽度，那么不会补充，也不会对值有影响。</p>
<p><img src="/2022/02/09/MySQL%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93-2/1.png" alt="img"></p>
<p>当用于表达式或者UNION查询时，ZEROFILL的属性会无效。</p>
<p>如果给某些字段设置了ZEROFILL属性，同时赋值了超过指定宽度的数值，那么在MySQL执行某些复杂查询时产生的临时表中，这些字段可能会有问题。</p>
<p>ZEROFILL属性同样适用于实数类型（FLOAT,DOUBLE,DECIMAL）。</p>
<p>BOOL和BOOLEAN在MySQL中与TINYINT(1)同义。</p>
<p><img src="/2022/02/09/MySQL%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93-2/2.png" alt="img"></p>
<p>但true和false仅仅是1和0的别称，跟其他值无关。例如：</p>
<p><img src="/2022/02/09/MySQL%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93-2/3.png" alt="img"></p>
<p>SERIAL与BIGINT UNSIGNED NOT NULL AUTO_INCREMENT UNIQUE同义。</p>
<p>关于BIGINT应当了解：</p>
<p><strong>1)</strong>    所有的计算都是用BIGINT和DOUBLE来计算的。除了位运算以外，在计算时不要使用大于9223372036854775807的无符号整数，因为最后几位可能会因为四舍五入到DOUBLE类型而造成误差。</p>
<p><strong>2)</strong>    可以用存储字符串的方式将准确的数字存储在BIGINT型字段中，MySQL会做一个string-to-number的转换（与DOUBLE类型无关）。</p>
<p><strong>3)</strong>    当+,-,*操作符两边都是整型时，MySQL使用BITINT类型做计算。所以当两个大整数相乘，结果大于9223372036854775807时，会得到意想不到的结果。</p>
<h4 id="1-2-实数类型"><a href="#1-2-实数类型" class="headerlink" title="1.2  实数类型"></a>1.2  实数类型</h4><p>实数类型就是有小数的数字。包括FLOAT,DOUBLE和DECIMAL。</p>
<p><strong>a.</strong>   <strong>FLOAT</strong></p>
<p>单精度类型，4个字节，范围是10-38到1038。常定义为FLOAT(M,D)，M是总的位数（不包括.和-），D是小数位数。</p>
<p>如果定义为FLOAT(P)，那么MySQL会根据P值，确定数据类型。如果P值在0-24，那么类型为FLOAT，如果P值在25-53，那么类型会为DOUBLE。FLOAT(P)为ODBC使用。</p>
<p>因为MySQL里的计算是用BIGINT和DOUBLE做的，所以使用FLOAT类型可能会产生意想不到的错误。</p>
<p><strong>b.</strong>   <strong>DOUBLE</strong></p>
<p>双精度类型，8个字节，范围是10-308到10308。常定义为DOUBLE(M,D)，M是总的位数（不包括.和-），D是小数位数。</p>
<p><strong>c.</strong>   <strong>DECIMAL</strong></p>
<p>封装过的精准数据类型，常定义为DECIMAL(M,D)，M是总的位数（不包括.和-），D是小数位数。M值最大为65，D值最大为30。如果M没定义的话，默认为10。如果D没定义的话，默认为0。</p>
<p>DECIMAL类型的操作(+,-,*,&#x2F;)都是用65位的精度完成。</p>
<p>DEC,FIXED,NUMERIC都是DECIMAL的同义词。</p>
<p>MySQL既支持精确类型（DECIMAL），也支持不精确的类型（FLOAT,DOUBLE）但他们并不是只为了存储小数，比如可以用DECIMAL存储比BIGINT还大的整数。</p>
<p>FLOAT和DOUBLE类型支持使用标准的浮点运算进行近似计算，因为CPU支持，所以浮点运算会更快。</p>
<p>DECIMAL类型用于存储精确的小数，CPU不支持直接计算，MySQL服务器自身实现。相比浮点类型稍微慢一些。</p>
<p>MySQL在存储数值时，会进行四舍五入。例如当给FLOAT(5,2)赋值’36.545’时，会存储为’36.55’。</p>
<p>当设置UNSIGNED属性时，同样不能存储负数。但是与整型值不同的是，最大值并不会翻倍。</p>
<p>DECIMAL类型中，MySQL是将数字打包存储到2进制字符串中（每4个字节存9个数字）。所以一个DECIMAL(18,9)的数字，一共使用9个字节：9位整数是4个字节，小数点1个字节，9位小数4个字节。</p>
<p>如果在需要精确计算时，应当尽可能使用DECIMAL，即使需要额外的空间和计算开销。在数据量大的时候，可以考虑用BIGINT代替DECIMAL，将需要存储的数据根据最小单位乘以响应的倍数。</p>
<h4 id="1-3-字符串类型"><a href="#1-3-字符串类型" class="headerlink" title="1.3  字符串类型"></a>1.3  字符串类型</h4><p>MySQL的字符串类型包括CHAR, VARCHAR, BINARY, VARBINARY, BLOB, TEXT, ENUM, SET。</p>
<p>VARCHAR和CHAR是两种最主要的字符串类型。</p>
<p>BINARY和VARBINARY是两种二进制字符串类型。</p>
<p>BLOB和TEXT是为了存储很大的数据而设计的字符串类型，分别采用二进制和字符串方式存储。</p>
<p>CHAR、VARCHAR、TEXT类型，MySQL以字符单位为描述长度。BINARY、VARBINARY、BLOB，MySQL以字节为单位描述长度。</p>
<p>字符串类型的字段可以设定字符集（CHARACTER SET）和比较规则（COLLATION）。</p>
<p><strong>a.</strong>   <strong>VARCHAR</strong></p>
<p>VARCHAR用于存储可变长度的字符串。因为仅使用必要的空间，所以它比定长类型（CHAR）更节省空间。VARCHAR类型不会删掉末尾空格。</p>
<p>VARCHAR长度限制为0-65535，具体的长度决定于所用的字符集和整行最大长度（所有列共用65535个字节，不包括BLOB和TEXT）。例如如果只有一个VARCHAR字段，指定为UTF-8类型，占用3个字节表示一个字符，那么该列最大长度为21844。</p>
<p>VARCHAR需要额外的1或2个字节记录字符串长度：如果列的最大长度小于或等于255字节，那么需要1个字节存储长度，否则需要2个。</p>
<p>因为字段是变长的，所以在UPDATE时可能使行变得比以前更长，这时可能会造成页内没有更多的空间存储。这种情况下，MyISAM会将行拆成不同的片段存储，InnoDB会分裂页使行可以放进页内。</p>
<p>下面几种情况使用VARCHAR是合适的：</p>
<p><strong>1)</strong>    字符串最大长度比平均长度大很多；</p>
<p><strong>2)</strong>    列的更新很少，所以碎片不是问题；</p>
<p><strong>3)</strong>    使用了像UTF-8这样复杂的字符串，每个字符都是用不同的字节存储。</p>
<p><strong>b.</strong>   <strong>CHAR</strong></p>
<p>CHAR是定长的。长度为0-255，如果长度不指定，那么默认为1。</p>
<p>当存储CHAR值时，MySQL会删除所有的末尾空格。当存储小于长度的值时，在右侧用空格填充。当存储超长的值时，CHAR会将值从末尾截断。</p>
<p>当取出CHAR值时，会将末尾空格去掉（当设置sql_mode为PAD_CHAR_TO_FULL_LENGTH时不会去掉）。</p>
<p>可以创建CHAR(0)字段，如果一个不能修改的程序必须需要这个字段，但是不会用到它，可以考虑创建CHAR(0)字段。CHAR(0)字段仅仅可以被赋值为NULL或’’。</p>
<p>CHAR适合存储很短的字符串，或者所有值都接近一个长度。</p>
<p>下面几种情况使用CHAR是合适的：</p>
<p><strong>1)</strong>    MD5值或者手机号；</p>
<p><strong>2)</strong>    经常变更的数据，因为定长的CHAR不容易产生碎片；</p>
<p><strong>3)</strong>    非常短的列，例如CHAR(1)只有Y和N</p>
<p>CHAR型与VARCHAR型的存储如下表所示：</p>
<table>
<thead>
<tr>
<th>Value</th>
<th>CHAR(4)</th>
<th>存储空间</th>
<th>VARCHAR(4)</th>
<th>存储空间</th>
</tr>
</thead>
<tbody><tr>
<td>‘’</td>
<td>‘    ’</td>
<td>4 bytes</td>
<td>‘’</td>
<td>1 bytes</td>
</tr>
<tr>
<td>‘ab’</td>
<td>‘ab   ’</td>
<td>4 bytes</td>
<td>‘ab’</td>
<td>3bytes</td>
</tr>
<tr>
<td>‘abcd’</td>
<td>‘abcd’</td>
<td>4 bytes</td>
<td>‘abcd’</td>
<td>5 bytes</td>
</tr>
<tr>
<td>‘abcdefg’</td>
<td>‘abcd’</td>
<td>4 bytes</td>
<td>‘abcd’</td>
<td>5 bytes</td>
</tr>
</tbody></table>
<p>所有比较规则（COLLATION）都会进行尾部去空格。所以CHAR、VARCHAR、TEXT在比较时都会无视掉尾部的空格，但是此处的比较不包括LIKE。</p>
<p><img src="/2022/02/09/MySQL%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93-2/4.png" alt="img"></p>
<p><img src="/2022/02/09/MySQL%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93-2/5.png" alt="img"></p>
<p><strong>c.</strong>   <strong>BINARY和VARBINARY</strong></p>
<p>对应CHAR类型和VARCHAR类型。区别是字符集和排序采用BINARY，同时长度也对应的是字节数而非字符数。</p>
<p>他们存储的是二进制字符串，也就是字节码而不是字符。填充时用的是\0(0x00)而不是空格，检索时也不会去掉填充值。比较、排序时\0和空格都会参与，不会被去掉。VARBINARY类型不需要填充。</p>
<p>例如：一个BINARY(3)的字段，当插入’a ’时会变成’a \0’，当插入’a\0’时会变成’a\0\0’。值在进行查询时不会改变。</p>
<p>如下图：</p>
<p><img src="/2022/02/09/MySQL%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93-2/6.png" alt="img"></p>
<p>二进制的优势：</p>
<p><strong>1)</strong>    大小写敏感；</p>
<p><strong>2)</strong>    比较值时，二进制字节要比字符简单，也就更快。</p>
<p><strong>d.</strong>   <strong>BLOB和TEXT</strong></p>
<p>BLOB和TEXT对应2组数据类型家族：字符型的是TINYTEXT,TEXT,MEDIUMTEXT,LONGTEXT;对应的二进制类型是TINYBLOB,BLOB,MEDIUMBLOB,LONGBLOB。</p>
<p>与其他的类型不同，MySQL会将每个BLOB和TEXT当做单独的对象处理，当值太大时，InnoDB会建立专门的外部存储区域进行存储，每个值在行内需要1-4个字节存储一个指针，指向外部地址。</p>
<p>二者区别是：BLOB类型存储二进制数据，使用binary字符集和数字型的排序规则；TEXT存储的是字符型数据，使用指定的字符集和指定的排序比较规则。</p>
<p>对BLOB和TEXT，在新增和查询时均不会对结尾的数据做出修改（例如增删空格）。</p>
<p>通常我们可以将BLOB认为是一个很大的VARBINARY，将TEXT认为是一个很大的VARCHAR。</p>
<p>MySQL对2者进行排序或索引时，与普通类型不同：只对每个列的最前长度的字节或字符而不是整个字符串做排序或索引。</p>
<p>BLOB和TEXT列上也不能赋值默认值。</p>
<p>当查询BLOB或者TEXT列时，如果MySQL使用了临时表，那么会使用真实存储在磁盘的临时表而非Memory表，因为Memory引擎不支持这俩类型。而使用存储在磁盘的临时表很影响性能，所以在查询时一定注意除非必须否则不要包含这俩字段。</p>
<p>BLOB和TEXT类型的最大长度取决于字段本身，但是也取决于客户端到服务器的通信缓存大小。</p>
<h4 id="1-4-日期和时间类型"><a href="#1-4-日期和时间类型" class="headerlink" title="1.4  日期和时间类型"></a>1.4  日期和时间类型</h4><p>MySQL可以使用YEAR,DATE,TIME等数据类型来保存日期和时间，但最常用的还是DATETIME和TIMESTAMP类型。</p>
<p><del>MySQL能存储的最小的时间粒度是秒。</del></p>
<p><strong>a.</strong>   <strong>DATETIME</strong></p>
<p>DATETIME占用8个字节，表示的时间范围从1000-01-01 00:00:00到9999-12-31 23:59:59 <strong>（从1000-01-01 00:00:00.000000到9999-12-31 23:59:59.999999）</strong>。</p>
<p>它把日期和时间封装到格式为yyyyMMddHHmmss的整数中，与时区无关。</p>
<p>默认情况下以yyyy-MM-dd HH:mm:ss显示，可以用yyyy-MM-dd HH:mm:ss或yyyyMMddHHmmss格式的数值进行INSERT。</p>
<p><strong>b.</strong>   <strong>TIMESTAMP</strong></p>
<p>TIMESTAMP占用4个字节，表示的范围从1970-01-01 00:00:01到2038-01-19 03:14:07 <strong>（切换到北京时间是从1970-01-01 08:00:01到2038-01-19 11:14:07，加上毫秒之后是从1970-01-01 08:00:01.000000到2038-01-19 11:14:07.999999）</strong>。</p>
<p>TIMESTAMP与时区有关，在MySQL服务器、操作系统以及客户端里连接都有时区设置。MySQL在存储时，用的是UTC时间。在查询时，将UTC时间转换为当前时区时间。所以在TIMESTAMP字段值的前提下，将系统时区进行修改后，再次查询会得到不同的结果。</p>
<p>如果字段允许为NULL，TIMESTAMP会存储为NULL。否则，在INSERT时会自动存储当前时间。如果勾选“根据当前时间戳更新”，在UPDATE时会自动更新该字段为当前时间。</p>
<p><strong>c.</strong>   <strong>YEAR</strong></p>
<p>YEAR占用4个字节，显示为yyyy，表示的范围从1901到2155。</p>
<p>如果赋值0-99的话，会有不同的情况：在0-69时，赋值为2000-2069。在赋值70-99时，赋值为1970-1999。</p>
<p><strong>d.</strong>   <strong>DATE</strong></p>
<p>DATE可以认为是DATETIME一部分，按照yyyy-MM-dd的格式，表示的范围是’1000-01-01’ to ‘9999-12-31’。</p>
<p><strong>e.</strong>   <strong>TIME</strong></p>
<p>TIME类型会显示为HH:mm:ss或者HHH:mm:ss，表示的范围从’-838:59:59’ to ‘838:59:59’<strong>（从’-838:59:59.000000’ to ‘838:59:59.000000’）</strong>。因为TIME类型并不完全用来代表一天中的时间，也会用来计时会表示时间间隔。</p>
<p>给TIME类型赋值时，如果赋值时写冒号了，例如赋值11:12，会被MySQL认为是11:12:00而不是00:11:12。如果赋值时没写冒号，例如赋值1112，那么正好相反，会被MySQL认为是00:11:12而不是11:12:00。如果赋值12，会被MySQL认为是00:00:12。</p>
<h4 id="1-5-位数据类型"><a href="#1-5-位数据类型" class="headerlink" title="1.5  位数据类型"></a>1.5  位数据类型</h4><p><strong>a.</strong>   <strong>BIT</strong></p>
<p>在MySQL5.0之前，BIT类型与TINYINT是同义词。在5.0及之后，BIT变为一个特性完全不同的数据类型。</p>
<p>BIT是一列中存储一个或多个true&#x2F;false值。BIT(1)定义包含单个位的字段，BIT(2)存储2个位。最大长度是64位。</p>
<p>当存储时，可以通过b’value’的格式，比如b’00111001’，将值写入该列。但是在查询时，可能会返回不同的结果，如下图：</p>
<p><img src="/2022/02/09/MySQL%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93-2/7.png" alt="img"></p>
<p>当在数字或者字符串型上下文中，BIT类型得到的结果是不同的。所以，对于绝大部分应用，应避免使用此类型。</p>
<p><strong>b.</strong>   <strong>SET</strong></p>
<p>如果需要保存很多的true&#x2F;false值，可以考虑用SET数据类型，它在MySQL内部是以一系列打包的位的集合来表示。</p>
<p>缺点是改变列的定义的代价较高，也无法在SET列上通过索引查找。</p>
<p><strong>c.</strong>   <strong>整数列</strong></p>
<p>一种替代SET的方式是用一个整数包装一系列的位，比如将8个位包装到一个TINYINT中，并且用按位操作来使用。</p>
<p>好处在于可以不使用ALTER TABLE改变字段代表的值，缺点是查询语句更难写更难理解。</p>
<h4 id="1-6-选择主键"><a href="#1-6-选择主键" class="headerlink" title="1.6  选择主键"></a>1.6  选择主键</h4><p>当选择主键时，不仅要考虑存储类型，还要考虑MySQL对这种类型怎么进行计算和比较。</p>
<p>一旦选定一种类型，要确保在所有的关联表中都是用同样的类型。类型之间需要精确匹配，比如UNSIGNED这样的属性。</p>
<p>在可以满足值的范围需求，并且预留未来增长空间的前提下，应该选择最小的数据类型。</p>
<p>常见技巧如下：</p>
<p><strong>a.</strong>   <strong>整数类型</strong></p>
<p>自增的UNSIGNED BIGINT永远作为最优的主键类型。</p>
<p><strong>b.</strong>   <strong>字符串类型</strong></p>
<p>如果有可能，尽量减少字符串类型作为主键的情况。因为字符串类型通常比较耗空间，而且比数字型慢。</p>
<p>一些用MD5(), SHA1(), UUID()产生的字符串，因为是非连续的，会因为索引存储方式导致数据分布在很大的空间内，也会产生碎片，同时，相邻的行分布在不同的地方，缓存赖以工作的局部性原理失效，导致INSERT以及一些SELECT语句变得很慢。</p>
<p><strong>c.</strong>   <strong>UUID类型</strong></p>
<p>如果一定要用UUID类型作为主键，应当移除”-”后进行存储;</p>
<p>或者在移除之后，用UNHEX()函数转换为字节型字符串，并且存储在BINARY(16)中。检索时可以通过HEX()函数来获取转换之前的值。</p>
<h4 id="1-7-特殊数据类型"><a href="#1-7-特殊数据类型" class="headerlink" title="1.7  特殊数据类型"></a>1.7  特殊数据类型</h4><p><strong>a.</strong>   <strong>精确度高于秒的时间</strong></p>
<p><strong>MySQL的最高时间精度是秒。如果存储高于秒精度的时间，可以用BIGINT存储毫秒或者微秒级别的时间戳。或者用DOUBLE存储秒之后的小数部分。</strong></p>
<p><strong>b.</strong>   <strong>IPv4地址</strong></p>
<p>虽然可以用VARCHAR(15)来存储IPv4地址，但是它实际上是无符号32位整数。用整型来存储要比字符型效率更高。所以推荐在数据库中用INET_ATON()将地址转换为整型存储，取出是用INET_NTOA()将整型转换为地址。</p>
<h3 id="2-范式与反范式"><a href="#2-范式与反范式" class="headerlink" title="2     范式与反范式"></a>2     范式与反范式</h3><p>范式定义：符合某一种级别的关系模式的集合，表示一个关系内部各属性之间的联系的合理化程度。</p>
<p>人话：一张数据库的表结构设计所符合的标准。</p>
<p>数据库的三范式：</p>
<p>1NF:表中的每个属性都不可再分。</p>
<p>2NF:每一列的都与主键相关。</p>
<p>3NF:每一列都不能与其他非主键列相关。</p>
<p>关于三范式的讲解： </p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/24696366/answer/29189700">https://www.zhihu.com/question/24696366/answer/29189700</a></p>
<p>范式的优点：</p>
<p><strong>1.</strong>   当完全或者较好的范式化时，就不会或者很少有冗余数据，可以尽量减少使用DISTINCT或者GROUP BY；</p>
<p><strong>2.</strong>   范式化的表通常更小，可以更好地放在内存里进行更快的CRUD操作.</p>
<p>缺点：</p>
<p>通常需要连表查询，造成性能开销变大，甚至索引无效。</p>
<p>实际中，完全的范式化或者完全的反范式化都是实验室中才有的东西，在实际应用中，通常需要进行综合考虑，进行混用。例如缓存表，中间表，汇总表，统计表等等。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://basonson.github.io/2022/02/08/MySQL%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="郭超">
      <meta itemprop="description" content="学习,分享,进步">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大牙技术">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/02/08/MySQL%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93-1/" class="post-title-link" itemprop="url">MySQL技术总结-1</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-02-08 16:32:35" itemprop="dateCreated datePublished" datetime="2022-02-08T16:32:35+08:00">2022-02-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-02-09 10:14:43" itemprop="dateModified" datetime="2022-02-09T10:14:43+08:00">2022-02-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="1-MySQL逻辑架构"><a href="#1-MySQL逻辑架构" class="headerlink" title="1.       MySQL逻辑架构"></a>1.       MySQL逻辑架构</h3><p><img src="/2022/02/08/MySQL%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93-1/%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84%E5%9B%BE.png"></p>
<p><strong>1)</strong> 客户端</p>
<p>不是MySQL独有。 程序、网站、客户端、服务器工具等等。</p>
<p><strong>2)</strong> 服务层</p>
<p>包含大多数MySQL的核心服务功能，比如查询解析、分析、优化、缓存以及所有的内置函数（日期、时间、数学等）、所有跨存储引擎的功能：存储过程、触发器、视图。</p>
<p><strong>3)</strong> 引擎层</p>
<p>负责MySQL数据的存储和提取，服务层通过API与引擎层交互，例如“开始一个事务”、“根据主键提取一行记录”等操作。</p>
<h4 id="1-1-连接管理与安全性"><a href="#1-1-连接管理与安全性" class="headerlink" title="1.1    连接管理与安全性"></a>1.1    连接管理与安全性</h4><p>每个客户端连接都会在服务器进程中拥有一个线程。服务器会负责缓存线程，因为“不需要”为每一个新建的连接创建或者销毁线程。MySQL 5.5之后的版本提供了线程池的API。</p>
<p>当客户端连接到MySQL服务器时，服务器需要基于主机信息、用户名、密码进行认证。当客户端连接成功时，还会继续验证客户端是否具有某个查询的权限。</p>
<h4 id="1-2-优化与执行"><a href="#1-2-优化与执行" class="headerlink" title="1.2    优化与执行"></a>1.2    优化与执行</h4><p>MySQL会解析查询，对其进行各种优化，包括重写查询、决定表的读取顺序、以及选择合适的索引等。用户可以通过特殊的关键字提示（hint）优化器，影响他的决策过程，也可以请求优化器解释（explain）优化过程的各个因素。</p>
<p>优化器不关心存储引擎的类型， 但是存储引擎对优化查询是有影响的。比如优化器会请求存储引擎提供容量或者某个操作的开销信息，表数据的统计信息等等。</p>
<p>对于SELECT语句，在解析查询之前，服务器会先检查查询缓存（query cache），如果能找到对应查询，服务器就不再进行查询解析、优化、执行，而是直接返回查询缓存中的结果集。</p>
<h3 id="2-并发控制"><a href="#2-并发控制" class="headerlink" title="2.       并发控制"></a>2.       并发控制</h3><h4 id="2-1-读写锁"><a href="#2-1-读写锁" class="headerlink" title="2.1    读写锁"></a>2.1    读写锁</h4><p>只要有多个操作同时修改数据，就会产生并发控制问题，解决方法就是锁。锁分为共享锁（shared lock）和排它锁（exclusive lock），也叫读锁（read lock）和写锁（write lock）。</p>
<p>读锁是共享的，或是相互不阻塞的。多个客户在同一时刻可以同时读取同一资源，互不干扰。写锁是排他的，一个写锁会阻塞其他的写锁和读锁。</p>
<p>实际数据库系统中，每时每刻都在发生锁定。</p>
<h4 id="2-2-锁粒度"><a href="#2-2-锁粒度" class="headerlink" title="2.2    锁粒度"></a>2.2    锁粒度</h4><p>理想的状态：只对会修改的数据进行精确的锁定。原因：任何时候，在给定的资源上，锁定的数据量越少，系统的并发程度越高，只要相互之间不发生冲突即可。</p>
<p>锁的各种操作：获得锁、检查锁状态、解除锁，都会增加系统的开销。</p>
<p>锁策略就是在数据的安全性和锁的开销之间寻求平衡。大多数数据库都是提供了行级锁（row-level lock），并以各种复杂的方式实现，以便在锁比较多的情况下尽可能的提供更好的性能。</p>
<p>MySQL有更多的选择，每种存储引擎都可以选择自己的锁策略和锁粒度。</p>
<p>表级锁和行级锁是两种最重要的锁策略，还有库级锁以及页级锁。</p>
<p><strong>a.</strong>   <strong>表级锁（table-level lock）</strong></p>
<p>表级锁是MySQL中开销最小的策略：锁定整张表。</p>
<p>用户对表进行写操作（CUD）时，首先获得写锁，这会阻塞其他用户对该表的所有读写操作。</p>
<p>虽然存储引擎可以管理自己的锁，但是MySQL本身还是会使用各种有效的表锁来实现不同的目的。例如，服务器层会为ALTER TABLE之类的语句使用表锁，而忽略存储引擎的锁机制。</p>
<p><strong>b.</strong>   <strong>行级锁（row-level lock）</strong></p>
<p>行级锁可以最大程度的支持并发处理。</p>
<p>行级锁只在存储引擎层实现，并未在服务层实现。</p>
<h3 id="3-事务"><a href="#3-事务" class="headerlink" title="3.       事务"></a>3.       事务</h3><p>事务是一组原子性的SQL查询，或者是一个独立的工作单元。事务内的语句，要么全部执行成功，要么全部执行失败。</p>
<p>举例：A-&gt;B转账。</p>
<p>1). 查询A的余额；</p>
<p>2). A账户减少100元;</p>
<p>3). B账户增加100元。</p>
<h4 id="3-1-ACID"><a href="#3-1-ACID" class="headerlink" title="3.1    ACID"></a>3.1    ACID</h4><p><strong>1)</strong>   <strong>A（Atomicity）原子性</strong></p>
<p>一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么失败全部回滚。</p>
<p><strong>2)</strong>   <strong>C（Consistency）一致性</strong></p>
<p>事务开始前与完成后，数据库的一致性状态不变。</p>
<p><strong>3)</strong>   <strong>I（Isolation）隔离性</strong></p>
<p>通常来说，一个事务所做的修改在最终提交以前，对其他事务是不可见的。</p>
<p><strong>4)</strong>   <strong>D（Durability）持久性</strong></p>
<p>一旦事务提交，所做的修改就会永久的保存在数据库中。</p>
<h4 id="3-2-隔离级别"><a href="#3-2-隔离级别" class="headerlink" title="3.2    隔离级别"></a>3.2    隔离级别</h4><p>在SQL标准中定义了4种隔离级别。</p>
<p><strong>1)</strong>   <strong>READ UNCOMMITTED（未提交读）</strong></p>
<p>在READ UNCOMMITTED级别，事务中的修改，即使没有提交，对其他事务也是可见的。事务可以读取未提交的数据，会引发脏读。实际中一般不使用。</p>
<p>脏读：一个事务读取到了别的事务还没提交时修改的数据。</p>
<p><strong>2)</strong>   <strong>READ COMMITTED（提交读）</strong></p>
<p>在READ COMMITTED级别，一个事务开始时，只能看到已经提交的事务所做的修改。也就是说，一个事务从开始直到提交，所做的任何修改对其他事务都是不可见的。这个级别也叫不可重复读，因为重复查询时会得到不一样的结果。</p>
<p>READ COMMITTED是SQL SERVER和Oracle等大多数数据库的默认隔离级别。</p>
<p>不可重复读：事务A第一次查询某值x时，为200。之后事务B对x进行了修改为100并提交。 之后事务A再次查询某值x，得到值为100。不可重复读指的是值的修改。</p>
<p><strong>3)</strong>   <strong>REPEATABLE READ（可重复读）</strong></p>
<p>在REPEATABLE READ级别，可以解决不可重复读的问题。但是不能解决幻读的问题。</p>
<p>REPEATABLE READ是MySQL的默认隔离级别。</p>
<p>幻读：事务A第一次依据某条件修改数据时，修改了10条数据。之后事务B在此范围内插入了一条数据，并提交。 之后事务A再次查询时，得到11条数据，其中10条修改过，1条未修改，仿佛发生了幻觉。幻读指的是数据条数的修改。</p>
<p>InnoDB引擎通过MVCC（多版本并发控制）解决了幻读问题。</p>
<p><strong>4)</strong>   <strong>SERIALIZABLE（可串行化）</strong></p>
<p>SERIALIZABLE是最高的隔离级别，会在读取的每一行数据上都加锁，强制事务串行执行，解决了幻读，但是会引发大量的锁征用问题。实际中也很少使用。</p>
<p>四种隔离级别及问题可能性如下：</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读可能性</th>
<th>不可重复读可能性</th>
<th>幻读可能性</th>
</tr>
</thead>
<tbody><tr>
<td>READ  UNCOMMITTED</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>READ  COMMITTED</td>
<td>×</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>REPEATABLE  READ</td>
<td>×</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td>SERIALIZABLE</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody></table>
<h4 id="3-3-死锁"><a href="#3-3-死锁" class="headerlink" title="3.3    死锁"></a>3.3    死锁</h4><p>死锁是指两个或多个实例在同一资源上相互占用，并请求锁定对方占用的资源，导致发生恶性循环的现象。当多个事务试图以不同顺序锁定资源时，就可能产生死锁。</p>
<p>死锁产生的原因主要包含如下两个：</p>
<p><strong>1)</strong>    真正的数据占用冲突，通常难以避免。</p>
<p><strong>2)</strong>    存储引擎的实现方式导致。</p>
<p>解决方法：</p>
<p><strong>1)</strong>    数据库提供了各种死锁检测和死锁超时机制，迅速检测到死锁的循环依赖并迅速返回错误。</p>
<p><strong>2)</strong>    当查询到达锁等待超时的设定时间后，放弃请求。比如InnoDB处理死锁的方式就是将持有最少行级排他锁的事务进行回滚。</p>
<h4 id="3-4-事务日志"><a href="#3-4-事务日志" class="headerlink" title="3.4    事务日志"></a>3.4    事务日志</h4><p>使用事务日志，存储引擎在修改表数据的时候，只需要修改其内存拷贝，再把该修改行为记录到硬盘上的事务日志中，而不用每次都将修改的数据本身持久化到硬盘。</p>
<p>事务日志采用追加的方式，写日志的操作是在磁盘的一小块区域内顺序IO，而不需要在随机IO，所以采用记录事务日志的方式要比直接将数据写入磁盘快很多。</p>
<p>事务日志持久化之后，内存中被修改的记录在后台慢慢的写入到磁盘。</p>
<p>这种方式被称为预写式日志（Write-Ahead Logging），每次修改数据需要写2次磁盘。</p>
<h4 id="3-5-MySQL中的事务"><a href="#3-5-MySQL中的事务" class="headerlink" title="3.5    MySQL中的事务"></a>3.5    MySQL中的事务</h4><p>MySQL中包含支持事务的引擎比如InnoDB， 不支持事务的引擎比如MyISAM。</p>
<p>MySQL采用的是自动提交（AUTOCOMMIT）模式，也就是说如果不是显示的开始一个事务，那么每次查询都会被当做一个事务执行提交操作。可以通过设置AUTOCOMMIT变量修改。</p>
<p>修改AUTOCOMMIT变量对非事务型的引擎表，没有任何影响。</p>
<p>有一些命令比如ALTER TABLE等，会在执行前强制提交当前活动事务。</p>
<p>如果在同一个事务中混合操作了事务型引擎表和非事务型引擎表。当事务正常提交时没有问题，当事务失败想回滚时，非事务型引擎表的操作不会回滚。这样就会造成一致性的问题。</p>
<h3 id="4-多版本并发控制"><a href="#4-多版本并发控制" class="headerlink" title="4.       多版本并发控制"></a>4.       多版本并发控制</h3><p>多版本并发控制（MVCC, Multi-Version Concurrency Control）是数据库基于性能考虑，用于实现并发访问的技术手段。不止MySQL，SQLServer、Oracle都实现了MVCC但方式不尽相同。</p>
<p>在MySQL中，MVCC在很多情况下避免了加锁操作，他是通过保存数据在某个时间点的快照来实现的。</p>
<p>在InnoDB中，通过在每行数据中添加2个隐藏列实现MVCC。这两个列，一个保存了该行数据的创建版本，另一个保存了该行数据的删除版本。当然存储的并不是系统时间，而是系统版本号。每开始一个新的事务，系统版本号都会自动增加。事务开始时刻的系统版本号，会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。</p>
<p>以下是具体操作方式：</p>
<p><strong>1.</strong>    <strong>SELECT</strong></p>
<p>InnoDB根据以下2个条件检查每行记录：</p>
<p>a.   创建版本小于等于当前事务版本的数据行。这样可以保证事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或修改过的。</p>
<p>b.   删除版本要么未定义，要么大于当前事务版本号。确保事务读取到的行，在事务开始之前未被删除。</p>
<p>同时符合上述两个条件的记录，才会作为查询结果返回。</p>
<p><strong>2.</strong>    <strong>INSERT</strong></p>
<p>InnoDB为新插入的每一行保存当前系统版本号作为创建版本。</p>
<p><strong>3.</strong>    <strong>DELETE</strong></p>
<p>InnoDB为删除的每一行保存当前系统版本号作为删除版本。</p>
<p><strong>4.</strong>    <strong>UPDATE</strong></p>
<p>InnoDB插入一行新记录，保存当前系统版本号作为创建版本，同时将原来行的删除版本保存为当前系统版本号。</p>
<p>保存两个隐藏列，可以是大多数的读操作都不需要加锁，提升了数据库的性能。但是不足之处是每行记录都需要额外的存储空间，以及一些额外的维护工作。</p>
<p>MVCC只在REPEATABLE READ和READ COMMITTED两个隔离级别下工作。READ UNCOMMITTED总是读取最新行，而不是符合当前事务版本的行。而SERIALIZABLE会对所有的读取行都加锁。</p>
<h3 id="5-MySQL的存储引擎"><a href="#5-MySQL的存储引擎" class="headerlink" title="5.       MySQL的存储引擎"></a>5.       MySQL的存储引擎</h3><h4 id="5-1-InnoDB引擎"><a href="#5-1-InnoDB引擎" class="headerlink" title="5.1    InnoDB引擎"></a>5.1    InnoDB引擎</h4><p><strong>1)</strong>    InnoDB是MySQL默认的引擎，是最重要也是最广泛的事务型引擎。</p>
<p><strong>2)</strong>    数据存储在单独的文件（.ibd或者.ibdata）中。</p>
<p><strong>3)</strong>    采用MVCC支持高并发，默认级别是REPEATABLE READ，通过间隙锁（next-key locking）策略防止幻读的出现。间隙锁使得InnoDB不仅仅锁定查询涉及的行，还会对索引中的间隙进行锁定，以防止幻影行的插入。</p>
<p><strong>4)</strong>    InnoDB表是基于聚簇索引建立。聚簇索引对主键查询有很高的性能，但是二级索引（非主键索引）中必须包含主键列，所以如果主键列很大的话，所有索引都会很大。所以应当尽可能的减小主键。</p>
<p><strong>5)</strong>    InnoDB在内部做了很多优化，比如从磁盘读取数据时采用可预测性预读，能够自动在内存中创建hash索引以加速读操作的自适应哈希索引（adaptive hash index），以及能够加速插入操作的缓冲区（insert buffer）。</p>
<p><strong>6)</strong>    InnoDB可以支持真正的热备份，而MySQL的其他存储引擎不支持热备份（要获取一致性视图必须停止对所有表的写入）。</p>
<h4 id="5-2-MyISAM引擎"><a href="#5-2-MyISAM引擎" class="headerlink" title="5.2    MyISAM引擎"></a>5.2    MyISAM引擎</h4><p><strong>1)</strong>    在MySQL 5.1及之前的版本，是默认的存储引擎。不支持事务。</p>
<p><strong>2)</strong>    数据存储在两个文件中：数据文件和索引文件，分别是.MYD和.MYI文件。</p>
<p><strong>3)</strong>    MyISAM是表级锁而不是行级锁。</p>
<p><strong>4)</strong>    MyISAM表会崩溃并且不自动修复。虽然可以通过手动修复的方式，但是可能会导致一些数据丢失，而且修复操作是非常慢的。</p>
<p><strong>5)</strong>    MyISAM表中，即使是BLOB或者TEXT等长字段，也可以基于前500个字符创建索引。也支持全文索引。</p>
<p><strong>6)</strong>    MyISAM表可以在创建时指定延迟更新索引键（DELAY_KEY_WRITE）选项，在每次修改完成后，不会立刻将修改的索引数据写入磁盘，而是写入到内存的键缓冲区（in-memory key buffer），只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大提升写入性能，但是在数据库或主机崩溃时会造成索引损坏，需要修复。</p>
<p><strong>7)</strong>    MyISAM表可以用myisampack对整张表进行压缩，将表变为只读表。极大的减少了存储空间，减少了磁盘的I&#x2F;O，提高的查询的性能。压缩表中的每行记录是单独压缩的，所以读取单行并不需要解压。（但是修改需要解压）</p>
<h4 id="5-3-其他引擎"><a href="#5-3-其他引擎" class="headerlink" title="5.3    其他引擎"></a>5.3    其他引擎</h4><p><strong>1)</strong>    Memory</p>
<p>所有数据都在内存中，不进行磁盘I&#x2F;O。结构在重启后保留，但是数据丢失。使用表级锁，并发写入性能较低。如果MySQL查询中需要使用临时表来保存中间结果，内部使用的表就是Memory表。</p>
<p><strong>2)</strong>    CSV</p>
<p>将CSV文件作为表来处理，不支持索引。</p>
<p><strong>3)</strong>    Archive</p>
<p>只支持INSERT和SELECT操作。对数据压缩所以比MyISAM更快，磁盘I&#x2F;O更少。支持行级锁和专用缓冲区，实现高并发的插入，不支持事务。是一个针对高速插入和压缩做了优化的简单引擎。</p>
<p><strong>4)</strong>    Blackhole</p>
<p>没有存储机制，不存任何数据，只是服务器会记录Blackhole表的日志。问题较多，不建议使用。</p>
<p><strong>5)</strong>    Federated</p>
<p>访问其他MySQL服务器的一个代理，创建一个连接，将查询传输到远程服务器执行。已经被禁用。</p>
<p><strong>6)</strong>    Merge</p>
<p>用于分表，在引入分区功能后，被禁用。</p>
<h4 id="5-4-关于引擎的选择"><a href="#5-4-关于引擎的选择" class="headerlink" title="5.4    关于引擎的选择"></a>5.4    关于引擎的选择</h4><p>除非需要用到InnoDB不具备的特性，并且没有其他方法可以替代，否则都应该优先选择InnoDB引擎。</p>
<p>正例：如果用到全文索引，优先考虑InnoDB+ElasticSearch&#x2F;Sphinx，而不是支持全文索引的MyISAM。</p>
<p>反例：如果不在乎可扩展能力和并发能力，也不要求事务，也不在乎频繁崩溃以及崩溃后的数据丢失问题，却对InnoDB的空间占用过多很敏感，可以选择MyISAM。</p>
<p>除非万不得已，否则不要混合使用多种存储引擎，容易引发一系列复杂的问题、潜在的bug和边界问题等等。</p>
<p>如果一定需要不同的引擎，那么需要从事务、备份、崩溃恢复、特性等方面去进行综合的考虑与选择。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://basonson.github.io/2022/02/07/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="郭超">
      <meta itemprop="description" content="学习,分享,进步">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大牙技术">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/02/07/hello-world/" class="post-title-link" itemprop="url">Hello World</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-02-07 16:51:59 / Modified: 15:36:21" itemprop="dateCreated datePublished" datetime="2022-02-07T16:51:59+08:00">2022-02-07</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>





</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">郭超</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
