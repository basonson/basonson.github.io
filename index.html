<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.0.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"basonson.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.10.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

  <meta name="description" content="学习,分享,进步">
<meta property="og:type" content="website">
<meta property="og:title" content="大牙技术">
<meta property="og:url" content="https://basonson.github.io/index.html">
<meta property="og:site_name" content="大牙技术">
<meta property="og:description" content="学习,分享,进步">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="郭超">
<meta property="article:tag" content="程序员,架构师,极客">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://basonson.github.io/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>大牙技术</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">大牙技术</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Chaos Guo's Personal WebSite</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="郭超"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">郭超</p>
  <div class="site-description" itemprop="description">学习,分享,进步</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">13</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">27</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://basonson.github.io/2022/05/18/Linux%E7%9B%AE%E5%BD%95%E4%B8%8B%E6%8C%89%E7%85%A7%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F%E6%8E%92%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="郭超">
      <meta itemprop="description" content="学习,分享,进步">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大牙技术">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/05/18/Linux%E7%9B%AE%E5%BD%95%E4%B8%8B%E6%8C%89%E7%85%A7%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F%E6%8E%92%E5%BA%8F/" class="post-title-link" itemprop="url">Linux目录下按照文件大小排序</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-05-18 17:35:19" itemprop="dateCreated datePublished" datetime="2022-05-18T17:35:19+08:00">2022-05-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-05-19 09:28:07" itemprop="dateModified" datetime="2022-05-19T09:28:07+08:00">2022-05-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="Linux对目录下文件排序命令"><a href="#Linux对目录下文件排序命令" class="headerlink" title="Linux对目录下文件排序命令"></a>Linux对目录下文件排序命令</h3><p>实际工作中我们经常需要对目录下的文件进行由大到小的排序后进行清理，释放磁盘空间。<br>有常用的三个命令可以将文件进行大小排序，如下：</p>
<h4 id="1-ll"><a href="#1-ll" class="headerlink" title="1. ll"></a>1. ll</h4><p><strong>1) 按照文件大小降序排列</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ll -hS</span><br></pre></td></tr></table></figure>

<p><img src="/2022/05/18/Linux%E7%9B%AE%E5%BD%95%E4%B8%8B%E6%8C%89%E7%85%A7%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F%E6%8E%92%E5%BA%8F/1.png" alt="img"></p>
<p><strong>2) 按照文件大小升序排列</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ll -hrS</span><br></pre></td></tr></table></figure>

<p><img src="/2022/05/18/Linux%E7%9B%AE%E5%BD%95%E4%B8%8B%E6%8C%89%E7%85%A7%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F%E6%8E%92%E5%BA%8F/2.png" alt="img"></p>
<h4 id="2-du"><a href="#2-du" class="headerlink" title="2. du"></a>2. du</h4><p><strong>1) 按照 B（字节）单位转换排序（升序排序）</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">du</span> -b * | <span class="built_in">sort</span> -n</span><br></pre></td></tr></table></figure>

<p>-b的意思是字节，可以改为-k或者-m，分别为KB,MB的单位。</p>
<p><img src="/2022/05/18/Linux%E7%9B%AE%E5%BD%95%E4%B8%8B%E6%8C%89%E7%85%A7%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F%E6%8E%92%E5%BA%8F/3.png" alt="img"></p>
<p><strong>2) 按照 B（字节）单位转换排序（降序排序）</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">du</span> -b * | <span class="built_in">sort</span> -rn</span><br></pre></td></tr></table></figure>

<p><img src="/2022/05/18/Linux%E7%9B%AE%E5%BD%95%E4%B8%8B%E6%8C%89%E7%85%A7%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F%E6%8E%92%E5%BA%8F/4.png" alt="img"></p>
<h4 id="3-find"><a href="#3-find" class="headerlink" title="3. find"></a>3. find</h4><p><strong>1) 按照文件大小进行降序排列</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find ./ -<span class="built_in">type</span> f -<span class="built_in">printf</span> <span class="string">&#x27;%s %p\n&#x27;</span> | <span class="built_in">sort</span> -rn</span><br></pre></td></tr></table></figure>

<p><img src="/2022/05/18/Linux%E7%9B%AE%E5%BD%95%E4%B8%8B%E6%8C%89%E7%85%A7%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F%E6%8E%92%E5%BA%8F/5.png" alt="img"></p>
<p><strong>2) 按照文件大小进行升序排列</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find ./ -<span class="built_in">type</span> f -<span class="built_in">printf</span> <span class="string">&#x27;%s %p\n&#x27;</span> | <span class="built_in">sort</span> -n</span><br></pre></td></tr></table></figure>

<p><img src="/2022/05/18/Linux%E7%9B%AE%E5%BD%95%E4%B8%8B%E6%8C%89%E7%85%A7%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F%E6%8E%92%E5%BA%8F/6.png" alt="img"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://basonson.github.io/2022/02/15/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%938-%E5%85%B6%E4%BB%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="郭超">
      <meta itemprop="description" content="学习,分享,进步">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大牙技术">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/02/15/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%938-%E5%85%B6%E4%BB%96/" class="post-title-link" itemprop="url">Redis技术总结8-其他</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-02-15 15:50:35 / Modified: 16:00:41" itemprop="dateCreated datePublished" datetime="2022-02-15T15:50:35+08:00">2022-02-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/NoSQL/" itemprop="url" rel="index"><span itemprop="name">NoSQL</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/NoSQL/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="1-发布与订阅"><a href="#1-发布与订阅" class="headerlink" title="1.  发布与订阅"></a>1.  发布与订阅</h3><p>Redis提供了基于发布&#x2F;订阅模式的消息机制，此种模式下，消息发布者和订阅者不直接通信。发布者客户端向指定频道发送消息，订阅该频道的客户端都可以收到该消息。</p>
<p>Redis的发布与订阅由PUBLISH，SUBSCRIBE，UNSUBSCRIBE，PSUBSCRIBE等命令组成。</p>
<p>通过SUBSCRIBE命令，客户端可以订阅一个或多个频道：</p>
<p>​<br><img src="/2022/02/15/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%938-%E5%85%B6%E4%BB%96/1.png" alt="img"><center><em>news.it频道和他的三个订阅者</em></center></p>
<p><img src="/2022/02/15/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%938-%E5%85%B6%E4%BB%96/2.png" alt="img"><center><em>向news.it频道发送消息</em></center></p>
<p>通过PSUBSCRIBE命令可以订阅一个或多个模式，如下图：</p>
<p>​<br><img src="/2022/02/15/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%938-%E5%85%B6%E4%BB%96/3.png" alt="img"><center><em>频道订阅与模式订阅</em></center></p>
<h4 id="1-1-频道订阅与退订"><a href="#1-1-频道订阅与退订" class="headerlink" title="1.1  频道订阅与退订"></a>1.1  频道订阅与退订</h4><p>Redis将所有频道订阅关系保存在redisServer中的pubsub_channels字典里。这个字典的键是某个被订阅的频道，而值就是一个链表，链表里记录了所有订阅这个频道的客户端。如下图：</p>
<p>​<br><img src="/2022/02/15/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%938-%E5%85%B6%E4%BB%96/4.png" alt="img"><center><em>pubsub_channels结构示意</em></center></p>
<p>当订阅频道时，如果频道已经在pubsub_channels中，那么只需在链表末尾加上新的客户端即可。如果频道未在pubsub_channels中，那么需要先在字典中为频道创建一个键，值为空链表，然后将客户端插入链表作为第一个元素。</p>
<p>当退订频道时，在pubsub_channels中找到对应的频道及链表，将链表中客户端删除。如果删除完之后链表元素个数为0，那么在pubsub_channels移除这个频道。</p>
<h4 id="1-2-模式订阅与退订"><a href="#1-2-模式订阅与退订" class="headerlink" title="1.2  模式订阅与退订"></a>1.2  模式订阅与退订</h4><p>Redis将所有模式订阅关系保存在redisServer中的pubsub_patterns链表（而不是字典）里。链表中的每个元素都是一个pubsub_pattern结构，这个结构的pattern属性记录了被订阅的模式，client属性则记录了订阅模式的客户端。如下图：</p>
<p>​<br><img src="/2022/02/15/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%938-%E5%85%B6%E4%BB%96/5.png" alt="img"><center><em>pubsubPattern代码示意</em></center></p>
<p><img src="/2022/02/15/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%938-%E5%85%B6%E4%BB%96/6.png" alt="img"><center><em>pubsub_pattern链表</em></center></p>
<p>当订阅模式时，新增一个pubsubPattern结构，将pattern属性设置为被订阅的模式，将client属性设置为订阅模式的客户端。然后将pubsubPattern结构添加到pubsub_patterns链表的表尾。</p>
<p>当退订模式时，服务器将在链表中查找并删除模式和客户端分别都匹配的pubsubPattern结构。</p>
<h4 id="1-3-发送消息"><a href="#1-3-发送消息" class="headerlink" title="1.3  发送消息"></a>1.3  发送消息</h4><p>当一个Redis客户端执行PUBLISH <channel> <message>命令将消息发送给频道时，服务器需要执行以下两个动作：</p>
<p><strong>1)</strong>    将消息message发送给channel的所有订阅者。</p>
<p><strong>2)</strong>    将消息message发送给所有与channel匹配的模式的订阅者。</p>
<h4 id="1-4-查看订阅信息"><a href="#1-4-查看订阅信息" class="headerlink" title="1.4  查看订阅信息"></a>1.4  查看订阅信息</h4><p>PUBSUB命令可以查看频道和模式的订阅信息，它有三个子命令：</p>
<p><strong>1)</strong>    PUBSUB CHANNELS [pattern]</p>
<p>返回服务器当前被订阅的频道。也可以根据模式pattern进行匹配返回。</p>
<p><strong>2)</strong>    PUBSUB NUMSUB [channel1,channel2…]</p>
<p>返回参数中频道的订阅者数量</p>
<p><strong>3)</strong>    PUBSUB NUMPAT</p>
<p>返回服务器被订阅模式的数量（即pubsub_patterns的长度）。</p>
<h4 id="1-5-关于订阅"><a href="#1-5-关于订阅" class="headerlink" title="1.5  关于订阅"></a>1.5  关于订阅</h4><p>客户端在执行订阅命令之后进入了订阅状态，只能接收PUBLISH命令发送的消息以及SUBSCRIBE，PSUBSCRIBE，UNSUBSCRIBE，PUNSUBSCRIBE四个命令。新开启的客户端，无法接收该频道之前的消息，因为Redis不会对发布的消息进行持久化。</p>
<h3 id="2-事务"><a href="#2-事务" class="headerlink" title="2.  事务"></a>2.  事务</h3><p>Redis通过MULTI,EXEC,WATCH等命令实现事务功能。</p>
<p>事务以一个MULTI命令开始，接着将多个命令放入事务中，最后以EXEC提交给服务器结束。</p>
<p>​<br><img src="/2022/02/15/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%938-%E5%85%B6%E4%BB%96/7.png" alt="img"><center><em>事务示例</em></center></p>
<p>事务以MULTI命令的执行标记为开始：在redisClient中将flags属性里打开REDIS_MULTI标识。</p>
<p>当事务开始后，服务器会根据收到的命令的不同，执行不同的操作：如果是MULTI、WATCH、DISCARD、WATCH，那么直接执行。如果不是，则会放到事务队列中，返回给客户端QUEUED。如下图：</p>
<p>​<br><img src="/2022/02/15/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%938-%E5%85%B6%E4%BB%96/8.png" alt="img"><center><em>事务状态的服务器判断命令</em></center></p>
<p>每个Redis客户端都有自己的事务状态，保存在redisClient中。即multiState结构的msate属性。如下图：</p>
<p>​<br><img src="/2022/02/15/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%938-%E5%85%B6%E4%BB%96/9.png" alt="img"><center><em>multiState代码示意</em></center></p>
<p>​<br><img src="/2022/02/15/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%938-%E5%85%B6%E4%BB%96/10.png" alt="img"><center><em>multiCmd代码示意</em></center></p>
<p><img src="/2022/02/15/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%938-%E5%85%B6%E4%BB%96/11.png" alt="img"><center><em>事务状态</em></center></p>
<p>​     </p>
<p>EXEC命令会遍历事务队列，执行事务队列中的所有命令，最后将执行结果全部返回给客户端。</p>
<p>DISCARD命令会放弃事务，清空事务队列。</p>
<p>WATCH命令是一个乐观锁，他会在EXE命令执行之前，监视若干键，并在EXE命令执行之时，检查监视的键是否至少有一个已经被修改过了。如果是，那么服务器拒绝执行事务，并返回失败。</p>
<p>每个redisDb都保存着一个watched_keys字典。这个字典的键是某个被WATCH命令监视的数据库键，而字典的值是一个链表，链表中记录了所有监视相应数据库键的客户端。</p>
<p>​<br><img src="/2022/02/15/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%938-%E5%85%B6%E4%BB%96/12.png" alt="img"><center><em>redisDb代码示意</em></center></p>
<p>所有对数据库进行修改的命令，执行之后都会调用touchWatchKey函数对watched_key字典进行检查，查看是否有客户端正在监视刚刚被修改的键。如果有的话，那么会将监视的客户端的flags中的REDIS_DIRTY_CAS标识打开，证明事务安全性已经被破坏。</p>
<p>当服务器收到客户端发来的EXEC命令时，会判断该客户端的REDIS_DIRTY_CAS标识否已经已经打开，如果打开，证明客户端所监视的键，至少一个有一个被修改过了，客户端提交的事务已经不再安全，所以服务器会拒绝执行客户端的事务。</p>
<h3 id="3-慢查询日志"><a href="#3-慢查询日志" class="headerlink" title="3.  慢查询日志"></a>3.  慢查询日志</h3><p>Redis的慢查询日志可以记录执行时长超过设定时长的命令，用户可以通过这个功能来监视和优化查询速度。</p>
<p>Redis执行一条命令分为4步：</p>
<p><strong>1)</strong>    发送命令</p>
<p><strong>2)</strong>    命令排队</p>
<p><strong>3)</strong>    命令执行</p>
<p><strong>4)</strong>    返回结果</p>
<p>慢查询只统计<strong>命令执行</strong>这一步的时间。</p>
<p>可配置项包括：超时时间与日志数量。</p>
<p>使用SLOWLOG GET命令可以查看服务器所保存的慢查询日志，如下图：</p>
<p>​<br><img src="/2022/02/15/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%938-%E5%85%B6%E4%BB%96/13.png" alt="img"><center><em>慢查询命令显示结果</em></center></p>
<p>使用SLOWLOG LEN可以获取慢查询日志当前列表长度，使用SLOWLOG RESET可以清空慢查询日志列表。</p>
<p>服务器状态redisServer中保存了几个和慢查询功能有关的属性：</p>
<p>​<br><img src="/2022/02/15/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%938-%E5%85%B6%E4%BB%96/14.png" alt="img"><center><em>redisServer代码示意</em></center></p>
<p>其中slowlog链表，保存了所有慢查询日志，以表头插入的方式进行新增，每个节点都是一个slowlogEntry结构，如下图：</p>
<p>​<br><img src="/2022/02/15/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%938-%E5%85%B6%E4%BB%96/15.png" alt="img"><center><em>slowlogEntry代码示意</em></center></p>
<p>每次执行命令的之前和之后，程序都会以微妙格式记录当前UNIX时间戳，这两个时间戳之差就是服务器执行命令所耗费的时长。</p>
<p>执行命令之后，程序检查执行时长是否超过slowlog-log-slower-than的值，如果是，就会创建一个新的日志，并添加到slowlog链表的表头。之后检查slowlog链表的长度是否超过slowlog-max-len选项设置的长度，如果是，那么多出来的日志会从链表中删除。</p>
<p>配置建议：</p>
<p><strong>1)</strong>    slowlog-log-slower-than:未修改时，默认为10ms。对高流量场景，如果命令执行时间超过1ms的话，那么Redis最多可支持的QPS不超过1000，不符合Redis的期望。因此高QPS的场景应当将超时时间设置为1ms。</p>
<p><strong>2)</strong>    slowlog-max-len：线上建议调大慢查询列表，记录慢查询时Redis会将长命令做截断，不会占用太多内存。线上建议设置为1000以上。</p>
<p><strong>3)</strong>    慢查询只记录命令执行时间。因此客户端输入命令到得到回复的时间，大于命令执行时间。当客户端出现请求超时，慢查询可能只是其中一种原因。</p>
<h3 id="4-Pipeline"><a href="#4-Pipeline" class="headerlink" title="4.  Pipeline"></a>4.  Pipeline</h3><p>关于命令的4个步骤的执行时间：</p>
<p><strong>1)</strong>    发送命令</p>
<p><strong>2)</strong>    命令排队</p>
<p><strong>3)</strong>    命令执行</p>
<p><strong>4)</strong>    返回结果</p>
<p>其中第1)和第4)的时间之和为Round Trip Time（RTT，往返时间）。Redis提供了批量操作的命令(mset,mget等)，但并不是所有命令都支持批量操作。当服务端与客户端相距较远并且网络延迟较高时，会严重影响Redis服务器接收命令、返回结果的速度。而Redis服务器执行命令的时间通常都在微秒级别。所以有种说法：Redis性能瓶颈是网络。</p>
<p>Redis提供了一个Pipeline机制（流水线），能够将一组Redis命令进行组装，通过1次RTT（而不是N次）传输、处理并按顺序返回结果。下表显示了在不同网路下，10000条set语句使用非Pipeline和Pipeline执行时间对比：</p>
<table>
<thead>
<tr>
<th>网络</th>
<th>延迟</th>
<th>非pipeline</th>
<th>pipeline</th>
</tr>
</thead>
<tbody><tr>
<td>本机</td>
<td>0.17ms</td>
<td>573ms</td>
<td>134ms</td>
</tr>
<tr>
<td>内网服务器</td>
<td>0.41ms</td>
<td>1610ms</td>
<td>240ms</td>
</tr>
<tr>
<td>异地机房</td>
<td>7ms</td>
<td>78499ms</td>
<td>1104ms</td>
</tr>
</tbody></table>
<p>Pipeline与原生的批量命令有不同的地方：</p>
<p><strong>1)</strong>    原生的批量命令是原子性的，Pipeline不是。</p>
<p><strong>2)</strong>    原生的批量命令是一个命令对应多个key，Pipeline是支持多个命令。</p>
<p><strong>3)</strong>    原生的批量命令是服务器端实现，而Pipeline需要服务器端和客户端共同实现。</p>
<p>Pipeline在很多语言中都有实现。但Pipeline不能滥用，如果一次组装的数据量过大，一方面会增加客户端等待时间，另一方面会造成网络阻塞。所以建议将大量命令的Pipeline拆分成较小的Pipeline来完成。</p>
<h3 id="5-监视器"><a href="#5-监视器" class="headerlink" title="5.  监视器"></a>5.  监视器</h3><p>客户端通过执行Monitor命令，可以将自己变为一个监视器，实时接收并打印出服务器当前处理的命令：</p>
<p>​<br><img src="/2022/02/15/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%938-%E5%85%B6%E4%BB%96/16.png" alt="img"><center><em>Monitor命令示意</em></center></p>
<p>每当一个客户端向服务器发送一条命令请求，服务器除了处理这条请求之外，还会将关于这条命令请求的信息发给所有监视器。</p>
<p>客户端发送MONITOR命令后，自身flags标识REDIS_MONITOR会被打开。redisServer维护一个monitors链表，每个节点就是客户端本身。收到命令后，链表中会增加这个客户端。之后服务器收到命令都会对链表进行遍历，然后发送给链表中的所有客户端。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://basonson.github.io/2022/02/15/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%937-%E9%9B%86%E7%BE%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="郭超">
      <meta itemprop="description" content="学习,分享,进步">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大牙技术">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/02/15/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%937-%E9%9B%86%E7%BE%A4/" class="post-title-link" itemprop="url">Redis技术总结7-集群</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-02-15 14:11:43 / Modified: 15:52:36" itemprop="dateCreated datePublished" datetime="2022-02-15T14:11:43+08:00">2022-02-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/NoSQL/" itemprop="url" rel="index"><span itemprop="name">NoSQL</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/NoSQL/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="1-集群"><a href="#1-集群" class="headerlink" title="1.  集群"></a>1.  集群</h3><p>集群与复制不同，复制分为主从服务器，主负责写，从负责读。集群中每个服务器都是独立，共同完成读写任务。</p>
<h4 id="1-节点"><a href="#1-节点" class="headerlink" title="1  节点"></a>1  节点</h4><p>一个Redis集群由多个节点构成。连接各个节点使用CLUSTER MEET命令完成。</p>
<p>比如现在有3个独立节点127.0.0.1:7000,127.0.0.1:7001,127.0.0.1:7002（分别以7000,7001,7002代替）。如果我们登陆127.0.0.1.7000，然后输入命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CLUSTER MEET 127.0.0.1 7001</span><br><span class="line"></span><br><span class="line">CLUSTER MEET 127.0.0.1 7002</span><br></pre></td></tr></table></figure>

<p>那么结果会如下4张图：</p>
<p>​<br><img src="/2022/02/15/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%937-%E9%9B%86%E7%BE%A4/1.png" alt="img"><center><em>节点7000与7001握手</em></center></p>
<p><img src="/2022/02/15/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%937-%E9%9B%86%E7%BE%A4/2.png" alt="img"><center><em>7000与7001建立集群</em></center></p>
<p><img src="/2022/02/15/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%937-%E9%9B%86%E7%BE%A4/3.png" alt="img"><center><em>7000与7002握手</em></center></p>
<p><img src="/2022/02/15/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%937-%E9%9B%86%E7%BE%A4/4.png" alt="img"><center><em>3个节点位于同一个集群</em></center></p>
<p>在服务器启动时，会根据一个配置项cluster-enabled，来决定是否开启集群模式。</p>
<p>集群模式与普通模式并没有太大区别，该有的功能都会有。但是会使用3个结构来保存集群模式才会用到的数据。</p>
<p>每个节点会使用一个clusterNode结构保存了节点当前状态，比如节点名称、创建时间、IP地址、端口号等等。</p>
<p>每个clusterNode中包含一个clusterLink结构，该结构保存了连接节点所需的有关信息，比如socket描述符，输入缓冲区，输出缓冲区。</p>
<p>每个节点会保存着一个clusterState结构，这个结构记录了当前节点的视角下，集群的状态，所包含的节点等等。</p>
<p>​<br><img src="/2022/02/15/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%937-%E9%9B%86%E7%BE%A4/5.png" alt="img"><center><em>clusterNode结构</em></center></p>
<p>​<br><img src="/2022/02/15/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%937-%E9%9B%86%E7%BE%A4/6.png" alt="img"><center><em>clusterLink代码示意</em></center></p>
<p>​<br><img src="/2022/02/15/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%937-%E9%9B%86%E7%BE%A4/7.png" alt="img"><center><em>clusterState代码示意</em></center></p>
<p>集群结构如下图：</p>
<p>​<br><img src="/2022/02/15/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%937-%E9%9B%86%E7%BE%A4/8.png" alt="img"><center><em>集群结构示意</em></center></p>
<p>关于CLUSTER MEET命令的实现：</p>
<p>登录节点A，发送命令CLUSTER MEET命令，输入B的ip和port。</p>
<p><strong>1)</strong>    节点A为节点B创建一个clusterNode结构，并添加到自己的clusterState.nodes字典里。</p>
<p><strong>2)</strong>    节点A向节点B发送MEET消息。</p>
<p><strong>3)</strong>    节点B收到MEET消息，为节点A创建一个clusterNode结构，并添加到自己的clusterState.nodes字典里。</p>
<p><strong>4)</strong>    节点B向节点A返回一条PONG消息。</p>
<p><strong>5)</strong>    节点A收到后，知道B已经收到了自己发送的MEET消息。</p>
<p><strong>6)</strong>    节点A向B返回一条PING消息。</p>
<p><strong>7)</strong>    节点B收到后，知道A已经收到了自己发送的PONG消息。</p>
<p>握手完毕。</p>
<p>之后节点A会将节点B的信息通过Gossip协议传播给集群中其他节点，让其他节点与B握手。这样过了一段时间之后，节点B会被集群中所有节点都认识（互相拥有对方的结构）。</p>
<h4 id="2-槽"><a href="#2-槽" class="headerlink" title="2  槽"></a>2  槽</h4><p>集群中的整个数据库被分为16384个槽（slot），每个键都属于这16384个槽中的一个，集群中的每个节点都可以处理0个或16384个槽。</p>
<p>当这16384个槽都有节点处理时，集群处于上线状态；相反的，如果有任何一个槽没有得到处理，集群处于下线状态。</p>
<p>登录7000之后，使用CLUSTER ADDSLOTS命令指定槽。当所有槽都被指定到节点之后，集群自动上线。（如果有槽已经被指派给其他节点，那么会返回错误）</p>
<p>clusterNode结构中的slots属性和numslot属性记录了节点负责处理哪些槽以及槽的数量。每个节点还会将自己负责处理哪些槽通过消息发送给其他节点，其他节点收到之后，会更新自己clusterState.nodes字典中对应节点的clusterNode结构对slots和numslots进行更新。</p>
<p>clusterState结构中记录了集群中16384个槽的指派信息。</p>
<p>​<br><img src="/2022/02/15/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%937-%E9%9B%86%E7%BE%A4/9.png" alt="img"><center><em>redisState代码示意</em></center></p>
<p>这是一个Redis里很经典的冗余。从nodes属性，可以快速找到每个节点负责的槽。从slots属性，可以快速找到每个槽对应的节点。单纯用哪种存储都可以完成所有任务，但是两种存储方式一起用可以将复杂度由O(N)变成O(1)。</p>
<h4 id="3-在集群中执行命令"><a href="#3-在集群中执行命令" class="headerlink" title="3  在集群中执行命令"></a>3  在集群中执行命令</h4><p>当客户端向节点发送有关键的命令时，收到命令的节点会计算要处理的键属于哪个槽，并判断这个槽指派的节点：</p>
<p>如果指派的节点是自己，那么节点执行这个命令；</p>
<p>如果指派的节点不是自己，那么节点会给客户端返回一个MOVED错误，指向客户端转向正确的节点，并再次发送之前想要执行的命令。</p>
<p>​<br><img src="/2022/02/15/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%937-%E9%9B%86%E7%BE%A4/10.png" alt="img"><center><em>节点收到命令后的判断</em></center></p>
<p>节点使用如下算法确定key属于哪个槽：</p>
<p>int i &#x3D; CRC16(key) &amp; 16383</p>
<p>计算出i之后，节点检查clusterState.slots[i]，判断是否等于clusterState.myself。如果相同，那么就直接执行命令。如果不同，那么根据clusterState.slots[i]指向的clusterNode结构记录的节点IP和port，向客户端返回MOVED错误。</p>
<p>客户端收到MOVED错误后，会跟据错误中提供的IP地址和端口号，转到负责该槽的节点，并向该节点重新发送命令。</p>
<p>节点与单机服务器的一个区别是，节点只使用0号数据库，单机服务器没有这一个限制。</p>
<p>另外，除了将键值保存在数据库中之外，节点还会使用clusterState结构中的slots_to_keys跳跃表来保存槽和键的关系。跳跃表中的分值是槽号，节点成员是数据库键。如下图：</p>
<p>​<br><img src="/2022/02/15/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%937-%E9%9B%86%E7%BE%A4/11.png" alt="img"><center><em>slots_to_keys跳跃表</em></center></p>
<p>通过跳跃表，可以很方便的对属于某个或某些个槽的数据库键进行批量操作。</p>
<h4 id="4-重新分片"><a href="#4-重新分片" class="headerlink" title="4  重新分片"></a>4  重新分片</h4><p>集群重新分片的操作可以将任意数量已经分配给某个节点的槽，改为指向另一个节点，并且所属的键值对也会移动到目标节点。</p>
<p>重新分片的过程中，集群不需要下线，并且源节点和目标节点都是继续处理命令请求。</p>
<p>集群重新分片操作由redis-trib负责执行，步骤如下图：</p>
<p>​<br><img src="/2022/02/15/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%937-%E9%9B%86%E7%BE%A4/12.png" alt="img"><center><em>对槽slot进行重新分片的过程</em></center></p>
<h4 id="5-复制"><a href="#5-复制" class="headerlink" title="5  复制"></a>5  复制</h4><p>Redis集群中的节点分为主节点和从节点。其中主节点用于处理槽，而从节点用于复制某个主节点，并在被复制的主节点下线时，代替主节点继续处理命令请求。</p>
<p>假设现有6个节点集群如下图：</p>
<p>​<br><img src="/2022/02/15/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%937-%E9%9B%86%E7%BE%A4/13.png" alt="img"><center><em>集群</em></center></p>
<p>各节点如下表：</p>
<p><img src="/2022/02/15/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%937-%E9%9B%86%E7%BE%A4/14.png" alt="img"></p>
<p>当7000下线时，集群中其他主节点会从7000的两个从节点中选出1个作为新的主节点，假如是7004。7004会接管7000负责的槽，并处理客户端发送的命令请求。7005也会从复制7000改为复制7004。当7000重新上线时，它会成为7004的从节点。如下表：</p>
<p><img src="/2022/02/15/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%937-%E9%9B%86%E7%BE%A4/15.png" alt="img"></p>
<p>向一个节点发送命令CLUSTER REPLICATE <node_id>会将该节点变为node_id对应节点的从节点。</p>
<p><strong>1)</strong>    收到该命令的节点会在自己的clusterState.nodes字典中找到node_id对应节点的clusterNode，并将自己的clusterState.myself.slaveof指向该clusterNode，标识自己正在复制该节点。</p>
<p><strong>2)</strong>    从节点修改自己的clusterState.myself.flags属性，关闭REDIS_NODE_MASTER标识，打开REDIS_NODE_SLAVE标识。</p>
<p><strong>3)</strong>    从节点调用复制代码（与复制功能相同），复制主节点的状态。</p>
<p>一个节点变成从节点，这个信息会通过消息发送给集群中其他节点，最终节点都会知道某个从节点正在复制某个主节点。</p>
<h4 id="6-消息"><a href="#6-消息" class="headerlink" title="6  消息"></a>6  消息</h4><p>集群中的消息分为以下五种：</p>
<p><strong>1)</strong>    MEET消息</p>
<p>发送者收到客户端发送的CLUSTER MEET命令时，会向接收者发送MEET消息，请求接收者加入到发送者当前所处的集群中。</p>
<p><strong>2)</strong>    PING消息</p>
<p>集群中的节点，每隔1s就会从已知节点列表中随机选择5个节点，然后对其中最长时间没有发送过PING消息的节点发送PING消息，以此来检测被选中的节点是否在线。</p>
<p>除此之外，节点A最后一次收到节点B的PONG消息时间，如果已经超过节点A的cluster-node-timeout时间的一半，节点A也会向节点B发送PING消息，防止节点A长时间没有随机选择B作为PING消息对象而导致节点B的消息更新之后。</p>
<p><strong>3)</strong>    PONG消息</p>
<p>接收者收到发送者发送的MEET消息或PING消息，为了确认收到，会向发送者返回一条PONG消息。</p>
<p>另外，一个节点也可以像集群广播PONG小让集群中其他节点立刻刷新对此节点的认识。</p>
<p><strong>4)</strong>    FAIL消息</p>
<p>当一个主节点A判断另一个主节点B已经进入FAIL状态时，主节点A会向集群广播一条关于节点B的FAIL消息，所有收到这条消息的节点会将节点B标记为已下线。</p>
<p><strong>5)</strong>    PUBLISH消息</p>
<p>当节点接收到PUBLISH消息时，节点会执行这个命令，并向集群广播一条PUBLISH消息，素有接收到这条消息的节点会执行相同的PUBLISH命令。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://basonson.github.io/2022/02/15/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%936-%E5%A4%8D%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="郭超">
      <meta itemprop="description" content="学习,分享,进步">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大牙技术">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/02/15/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%936-%E5%A4%8D%E5%88%B6/" class="post-title-link" itemprop="url">Redis技术总结6-复制</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-02-15 14:06:37 / Modified: 15:51:18" itemprop="dateCreated datePublished" datetime="2022-02-15T14:06:37+08:00">2022-02-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/NoSQL/" itemprop="url" rel="index"><span itemprop="name">NoSQL</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/NoSQL/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="1-复制"><a href="#1-复制" class="headerlink" title="1.  复制"></a>1.  复制</h3><p>用户可以通过执行SLAVEOF命令，或者设置slaveof选项，让一个服务器去复制另外一个服务器。被复制的服务器叫做主服务器，去复制主服务器的服务器叫做从服务器。主从服务器会保存相同的数据，称为“数据库状态一致”。</p>
<h4 id="1-建立复制"><a href="#1-建立复制" class="headerlink" title="1  建立复制"></a>1  建立复制</h4><p>主从服务器也分别叫做主节点和从节点。每个从节点只能有一个主节点，而主节点可以有多个从节点。建立复制的方法有3种：</p>
<p><strong>1)</strong> 在配置文件中加入slaveof [masterhost] [masterport]，随着redis启动而生效。</p>
<p><strong>2)</strong> 在redis-server命令后加入–slaveof [masterhost] [masterport]生效。</p>
<p><strong>3)</strong> 启动后直接使用命令：slaveof [masterhost] [masterport]生效。</p>
<p>注意：以上都是针对从节点，主节点不需进行配置。</p>
<h4 id="2-断开复制"><a href="#2-断开复制" class="headerlink" title="2  断开复制"></a>2  断开复制</h4><p>使用slaveof no one断开。不会丢失原有数据，只是不再与主节点进行同步。</p>
<p>也可以直接使用salveof [newmasterhost] [newmasterport]来切换主节点。执行命令后，从节点会首先断开与旧主节点的复制关系，然后与新主节点建立复制关系，之后删除从节点当前所有数据，从新的主节点进行复制操作。</p>
<p>注意：切换主节点会清空从节点所有数据，线上操作时避免出现salveof错误的节点的情况。</p>
<h4 id="3-只读"><a href="#3-只读" class="headerlink" title="3  只读"></a>3  只读</h4><p>从节点默认为只读模式。因为从节点数据的修改，主节点是无法感知的，修改从节点会导致主从数据不一致。所以建议线上不要修改从节点的只读模式。</p>
<h4 id="4-拓扑"><a href="#4-拓扑" class="headerlink" title="4  拓扑"></a>4  拓扑</h4><p>复制的拓扑结构可以分为单层或者多层。按照复杂性分为一主一从，一主多从，树状主从三种。</p>
<p><strong>1)   一主一从结构</strong></p>
<p>最简单的拓扑结构。当写并发量较高并且需要持久化的时候，可以只在从节点开启AOF，这样保证了数据安全性也避免了持久化对主节点的性能干扰。但是需要注意的是，主节点关闭持久化功能后，如果需要重启，主节点数据会清空，从节点数据也会清空。</p>
<p>所以，当需要重启主节点时，建议的做法是在从节点执行slaveof no one后，再在主节点执行重启。</p>
<p><strong>2)   一主多从结构</strong></p>
<p>对于读操作占比较高的场景，可以把读命令发送到各个从节点分担主节点压力。同时一些耗时较高的命令，可以在特定从节点执行，防止慢查询影响生产环境效率。</p>
<p>但对于写并发量较高的场景，多个从节点会导致主节点写命令的多次发送从而过度消耗网络带宽，同时也加重了主节点的负载影响服务稳定性。</p>
<p><strong>3)   树状主从结构</strong></p>
<p>在此结构中，从节点不但复制主节点数据，同时也作为其他从节点的主节点往下传递数据。这样有效地降低了主节点负载和需要传输给其他从节点的数据量。</p>
<h4 id="5-旧版复制功能"><a href="#5-旧版复制功能" class="headerlink" title="5  旧版复制功能"></a>5  旧版复制功能</h4><p>旧版复制功能分为同步和命令传播两个操作。</p>
<p>同步功能用于将从服务器的数据库状态更新为主服务器的数据库状态。</p>
<p>命令传播用于主服务器数据库状态被修改时，让主从服务器状态一致。</p>
<p><strong>5.1    同步</strong></p>
<p>从服务器从主服务器发送SYNC命令。</p>
<p>主服务器收到SYNC命令后，执行BGSAVE命令，开始生成一个RDB文件，并且使用一个缓冲区记录当前开始执行的所有写命令。</p>
<p>BGSAVE执行完毕后，RDB文件发送给从服务器，从服务器接收并载入这个文件。</p>
<p>主服务器将缓冲区内所有命令发送给从服务器，从服务器一一执行。</p>
<p>这样主从服务器的状态到达一致。</p>
<p><strong>5.2    命令传播</strong></p>
<p>主服务器会将自己执行过的写命令，发送给从服务器执行。这样双方的状态始终保持一致。</p>
<p>缺陷：</p>
<p>主从服务器的复制可以分为初次复制和断线之后的复制。对初次复制来说，上述功能可以很好地完成任务。但对断线后的复制来说，全量SYNC效率很低。</p>
<p>例如主从服务器现在已经各有10000个键。此时网络断开2秒，期间主服务器新增2个键。2秒后网络恢复。如果按照旧版同步方式，主服务器需要生成一个包含10002个键的RDB文件同步给从服务器，但其实他只需要将额外的2个键同步给从服务器即可。RDB文件的生成、传输、载入都需要耗费大量的CPU、内存、网络资源。</p>
<h4 id="6-新版复制功能"><a href="#6-新版复制功能" class="headerlink" title="6  新版复制功能"></a>6  新版复制功能</h4><p>新版采用PSYNC命令代替SYNC命令。PSYNC命令包括完整重同步和部分重同步两种模式。完整重同步适用于初次赋值，部分重同步适用于断线后复制。</p>
<p>部分重同步由以下三部分共同完成：</p>
<p><strong>1)</strong>   主从双方各维护一个复制偏移量。</p>
<p><strong>2)</strong>   主服务器维护复制积压缓冲区。</p>
<p><strong>3)</strong>   主服务器的运行ID。</p>
<p><strong>6.1    复制偏移量</strong></p>
<p>主服务器每次向从服务器传输N个字节的数据时，就将自己的复制偏移量+N。</p>
<p>从服务器每次接收N个字节的数据时，就将自己的复制偏移量+N。</p>
<p>通过对比双方的复制偏移量，程序就能够了解双方的状态是否一致。</p>
<p><strong>6.2    复制积压缓冲区</strong></p>
<p>复制积压缓冲区是由主服务器维护的一个固定长度的、先进先出的队列，默认1M。</p>
<p>当主服务器进行命令传输时，它不仅会将命令发送给所有从服务器，也会将命令写入到复制积压缓冲区里，并且为每个字节记录偏移量。</p>
<p>当从服务器连接到主服务器时，通过PSYNC命令将复制偏移量发送给主服务器，主服务器比较之后，如果发现偏移量不同，那么：</p>
<p><strong>1)</strong>    如果从服务器偏移量之后的数据仍然存在于复制积压缓冲区中，那么主服务器会对从服务器按照偏移量差，进行部分重同步操作。</p>
<p><strong>2)</strong>    如果从服务器偏移量之后的数据已经不存在于复制积压缓冲区中，那么进行完整重同步操作。</p>
<p><strong>6.3    运行ID</strong></p>
<p>每个Redis服务器，无论主从，都会有一个运行ID。在服务器启动时自动生成，是40个随机十六进制字符。</p>
<p>主从服务器初次同步时，主服务器会将自己的运行ID传输给从服务器，保存起来。</p>
<p>断线重连后，从服务器会将保存的主服务器运行ID发送给当前主服务器。</p>
<p>如果ID相同，会尝试判断偏移量。</p>
<p>如果ID不同，那么直接进行完整重同步操作。</p>
<p>如何在不改变运行ID的情况下重启呢？</p>
<p>使用debug reload命令重启。</p>
<p>注意：debug reload命令会阻塞当前Redis节点的主线程，阻塞期间生成本地的RDB快照并清空数据，之后重新加载RDB。所以对于大数据量的主节点和无法容忍阻塞的应用场景，谨慎使用。</p>
<h4 id="7-心跳"><a href="#7-心跳" class="headerlink" title="7  心跳"></a>7  心跳</h4><p>主从节点建立复制之后，他们之间维护着长连接并发送心跳命令。</p>
<p><strong>1)</strong>  主从节点批次都有心跳检测机制，他们各自模拟成对方的客户端去跟对方进行通信。（这些客户端可以通过client list命令查看到）</p>
<p><strong>2)</strong>  主节点默认每隔10s向从节点发送ping命令，判断从节点的存活性和连接状态。</p>
<p><strong>3)</strong>  从节点每隔1s向主节点发送replconf ack [offset]命令，给主节点上报自己当前的复制偏移量。</p>
<p>主节点根据replconf命令判断从节点超时时间，在info replication统计中的lag标识与从节点最后一次通信后的秒数，通常在0-1之间。如果超过60s（可以配置），则判断从节点下线并断开连接。</p>
<h4 id="8-异步复制"><a href="#8-异步复制" class="headerlink" title="8  异步复制"></a>8  异步复制</h4><p>主节点会将写命令同步给从节点，这个发送过程是异步完成的。</p>
<p><strong>1)</strong>  主节点接收并处理命令</p>
<p><strong>2)</strong>  命令处理完后返回响应结果</p>
<p><strong>3)</strong>  命令异步发送给从节点，从节点在主线程中执行该命令</p>
<p>异步操作决定了主从之间数据是有延迟的。延迟多少可以在主节点中执行info replication命令通过比较主从的offset来判断。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://basonson.github.io/2022/02/15/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%935-%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8E%E5%AE%A2%E6%88%B7%E7%AB%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="郭超">
      <meta itemprop="description" content="学习,分享,进步">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大牙技术">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/02/15/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%935-%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8E%E5%AE%A2%E6%88%B7%E7%AB%AF/" class="post-title-link" itemprop="url">Redis技术总结5-服务器与客户端</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-02-15 11:04:34 / Modified: 15:51:05" itemprop="dateCreated datePublished" datetime="2022-02-15T11:04:34+08:00">2022-02-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/NoSQL/" itemprop="url" rel="index"><span itemprop="name">NoSQL</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/NoSQL/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="1-客户端"><a href="#1-客户端" class="headerlink" title="1.  客户端"></a>1.  客户端</h3><p>Redis服务器是一个典型的一对多服务器程序：一个服务器可以与多个客户端建立网络连接，每个客户端想服务器发送命令请求，而服务器则接收并处理客户端发送的命令请求，向客户端返回命令回复。</p>
<p>Redis服务器状态redisServer结构中的clients是一个链表，保存了所有与服务器连接的客户端的状态结构，对客户端进行批量操作，或者查找某个指定的客户端，都可以通过遍历clients链表完成。如下图：</p>
<p>​<br><img src="/2022/02/15/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%935-%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8E%E5%AE%A2%E6%88%B7%E7%AB%AF/1.png" alt="img"><center><em>redisServer结构示意</em></center></p>
<p>客户端包含的属性分为两类：一类是通用属性，例如名字、标识等等；另一类是与特定功能相关的属性，比如操作数据库需要的db属性，执行事务需要用到的mstate属性等等。客户端信息可以通过CLIENT LIST（列出与Redis服务器相连的所有客户端链接信息）列出。客户端redisClient代码如下图：</p>
<p>​<br><img src="/2022/02/15/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%935-%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8E%E5%AE%A2%E6%88%B7%E7%AB%AF/2.png" alt="img"><center><em>redisClient代码示意</em></center></p>
<p>客户端基本属性如下：</p>
<h4 id="1-socket描述符：fd"><a href="#1-socket描述符：fd" class="headerlink" title="1)    socket描述符：fd"></a>1)    socket描述符：fd</h4><p>伪客户端（什么是伪客户端？）的fd值是-1，普通客户端的fd值是大于-1的整数。</p>
<h4 id="2-名字：name"><a href="#2-名字：name" class="headerlink" title="2)    名字：name"></a>2)    名字：name</h4><p>默认状态下没有名字，使用CLIENT SETNAME命令可以为客户端指定名字。</p>
<h4 id="3-标志：flags"><a href="#3-标志：flags" class="headerlink" title="3)    标志：flags"></a>3)    标志：flags</h4><p>标志记录了客户端目前所处的状态，例如主服务器(REDIS_MASTER)、从服务器(REDIS_SLAVE)、阻塞(REDIS_BLOCKED)、事务(REDIS_MULTI)等等。</p>
<h4 id="4-输入缓冲区：querybuf"><a href="#4-输入缓冲区：querybuf" class="headerlink" title="4)    输入缓冲区：querybuf"></a>4)    输入缓冲区：querybuf</h4><p>输入缓冲区用于保存客户端发送的命令请求。输入缓冲区最大不能超过1G，否则服务器会立刻关闭这个客户端连接。</p>
<p>输入缓冲区过大的原因就是因为Redis的处理速度跟不上输入缓冲区的输入速度。例如输入命令包含了大量的长度很大的键值，或者Redis发生阻塞不能处理命令。</p>
<p>监控缓冲区异常的方法有2种：</p>
<p>A.   通过定期执行CLIENT LIST命令，寻找qbuf异常的链接并分析，找出可能出问题的客户端（可以使用CLIENT KILL ip:port命令关闭）；</p>
<p>B.    通过INFO命令的info clients模块，找到最大的输入缓冲区client_biggest_input_buf，设置为10M（超过10M即报警）。</p>
<h4 id="5-命令与命令参数：argv-argc"><a href="#5-命令与命令参数：argv-argc" class="headerlink" title="5)    命令与命令参数：argv,argc"></a>5)    命令与命令参数：argv,argc</h4><p>服务器将客户端命令存储在输入缓冲区后，会对命令内容进行解析，得出命令参数以及参数的个数，保存在argv和argc属性。如下图：</p>
<p>​<br><img src="/2022/02/15/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%935-%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8E%E5%AE%A2%E6%88%B7%E7%AB%AF/3.png" alt="img"><center><em>redisClient结构示意图</em></center></p>
<h4 id="6-命令的实现函数"><a href="#6-命令的实现函数" class="headerlink" title="6)    命令的实现函数"></a>6)    命令的实现函数</h4><p>服务器会根据argv[0]的值，在命令表中查询命令所对应的命令实现函数。命令表是一个字典，字典的键是SDS，值是redisCommand结构，这个结构保存了命令的实现函数、标志、给定参数个数、总执行次数、总消耗时长等。</p>
<p>​<br><img src="/2022/02/15/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%935-%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8E%E5%AE%A2%E6%88%B7%E7%AB%AF/4.png" alt="img"><center><em>命令表</em></center></p>
<p>程序在命令表中找到对应的redisCommand结构时，会将redisClient中的cmd指向这个结构。之后服务器就可以根据cmd,argv,argc调用命令实现函数，执行命令。</p>
<p>​<br><img src="/2022/02/15/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%935-%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8E%E5%AE%A2%E6%88%B7%E7%AB%AF/5.png" alt="img"><center><em>查找命令并设置cmd属性</em></center></p>
<h4 id="7-输出缓冲区"><a href="#7-输出缓冲区" class="headerlink" title="7)    输出缓冲区"></a>7)    输出缓冲区</h4><p>执行命令之后的回复会被保存在redisClient的输出缓冲区中，每个客户端有2个输出缓冲区，一个大小固定，一个大小可变。</p>
<p><strong>a)</strong>    固定大小的缓冲区用于保存长度较小的回复，比如OK，简短的字符串，数值，错误恢复等等。如下图：</p>
<p>​<br><img src="/2022/02/15/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%935-%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8E%E5%AE%A2%E6%88%B7%E7%AB%AF/6.png" alt="img"><center><em>固定大小缓冲区</em></center></p>
<p>buf是直接数组，默认16*1024。bufpos是目前已用数量。</p>
<p><strong>b)</strong>   可变大小的缓冲区用于保存长度较大的回复，比如一个长字符串，很多项的列表，很多元素的集合等等。</p>
<p>​<br><img src="/2022/02/15/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%935-%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8E%E5%AE%A2%E6%88%B7%E7%AB%AF/7.png" alt="img"><center><em>可变大小缓冲区</em></center></p>
<p>reply是一个包含多个字符串对象的链表。</p>
<p>输出缓冲区是有一定限制的，如果输出缓冲区大小超过了服务器设置的硬性限制，那么客户端会立刻关闭；另外，如果客户端在一定时间内，一直超过服务器设置的软性限制，客户端也会关闭。</p>
<h4 id="8-身份验证"><a href="#8-身份验证" class="headerlink" title="8)    身份验证"></a>8)    身份验证</h4><p>authenticated属性用于记录客户端是否通过了身份验证。当值为0时，除了AUTH命令外，所有其他命令都会被服务器拒绝执行。但这仅仅在服务器启用了身份验证功能时才会发生，如果服务器未启用身份验证，无论何值都不会拒绝客户端的命令请求。</p>
<h3 id="2-服务器"><a href="#2-服务器" class="headerlink" title="2.  服务器"></a>2.  服务器</h3><h4 id="1-命令请求执行的过程"><a href="#1-命令请求执行的过程" class="headerlink" title="1)  命令请求执行的过程"></a>1)  命令请求执行的过程</h4><p>如果客户端发送SET KEY VALUE到获得回复OK期间，客户端和服务器共需要执行以下操作：</p>
<p><strong>1)</strong>    客户端向服务器发送命令请求SET KEY VALUE。</p>
<p><strong>2)</strong>    服务器接收并处理客户端发来的命令请求，在数据库进行设置操作，并产生命令回复OK。</p>
<p><strong>3)</strong>    服务器将命令回复OK发送给客户端。</p>
<p><strong>4)</strong>    客户端接收命令回复OK，并将这个回复打印给用户观看。</p>
<p>2.1.1    发送命令请求</p>
<p>用户在客户端输入一个命令，客户端将这个命令请求转换成协议格式，然后通过socket将命令请求发送给服务器。</p>
<p>2.1.2    读取命令请求</p>
<p>服务器读取命令请求，保存在redisClient中的输入缓冲区中。然后对其进行分析，解析出argv和argc。调用命令执行器，执行客户端指定的命令。</p>
<p>2.1.3    命令执行器(1)：查找命令实现</p>
<p>命令执行器根据argv[0]参数(SET,GET,等等)，在命令表当中查询指定的命令，并将找到的命令保存到redisClient的cmd属性中。</p>
<p>2.1.4    命令执行器(2)：执行预备操作</p>
<p>截止目前，服务器已经将所需命令实现函数（cmd），参数（argv），参数个数（argc）都收集齐了。但是在真正执行命令之前，还需要一些预备操作，比如：检查cmd是否指向NULL，检查参数个数是否正确，检查是否通过身份验证，检查内存占用情况等等。</p>
<p>2.1.5    命令执行器(3)：调用实现函数</p>
<p>当服务器准备好，决定执行命令，只需要执行以下语句：</p>
<p>client-&gt;cmd-&gt;proc(client);</p>
<p>语句产生的回复被保存在客户端状态的输出缓冲区里面（buf属性和reply属性），之后实现函数还会为客户端的socket关联命令回复处理器，这个处理器负责将命令回复返回给客户端。</p>
<p>2.1.6    命令执行器(4)：调用实现函数</p>
<p><strong>1)</strong>    如果开启慢查询，检查刚刚执行的命令是否需要添加到慢查询日志中。</p>
<p><strong>2)</strong>    更新cmd中的milliseconds属性，并将calls属性加1。</p>
<p><strong>3)</strong>    如果开启AOF，命令写入到AOF缓冲区中。</p>
<p><strong>4)</strong>    如果有复制，命令传递给从服务器。</p>
<h4 id="2-serverCron函数"><a href="#2-serverCron函数" class="headerlink" title="2)  serverCron函数"></a>2)  serverCron函数</h4><p>serverCron函数默认每隔100ms执行一次。这个函数负责管理服务器的资源，并保持服务器自身的良好运转。</p>
<p>2.2.1    更新服务器缓存</p>
<p>Redis服务器中很多功能需要获取系统当前时间，但是获取系统时间会执行系统调用。为了减少系统调用次数，redisServer中的unixtime属性和mstime属性被当做当前时间的缓存。</p>
<p>serverCron函数每次运行会更新这两个属性。</p>
<p>注意：</p>
<p>服务器只会在打印日志、更新LRU时钟、决定是否执行持久化任务、计算服务器上线时间等这类对时间精度要求不高的功能上使用缓存。</p>
<p>在为键设置过期时间、添加慢查询日志这种需要高精度时间的功能来说，服务器还是会进行系统调用，获取精准时间。</p>
<p>2.2.2    更新LRU时钟</p>
<p>redisServer中保存着LRU时钟：unsigned属性的 lruclock。这个属性与unixtime和mstime一样，都是服务器时间缓存的一种。</p>
<p>每个Redis对象都有一个lru属性：unsigned lru。这个lru属性保存了对象最后一次被访问的时间。</p>
<p>计算对象的空转时间：用服务器的lruclock-对象的lru</p>
<p>2.2.3    更新每秒执行命令次数</p>
<p>serverCron中的trackOperationsPerSecond函数以抽样计算的方式，估算并记录服务器在最近一秒钟内处理的命令数量。这个值可以通过INFO STATUS命令查看。</p>
<p>2.2.4    更新服务器内存峰值纪录</p>
<p>serverCron函数运行时会更新服务器内存峰值，即最大使用内存值。</p>
<p>2.2.5    管理客户端资源</p>
<p>serverCron中的clientsCron函数，会对连接超时、输入输出缓冲区过大的客户端进行释放。</p>
<p>2.2.6    执行被延迟的BGREWRITEAOF</p>
<p>BGSAVE执行期间，BGREWRITEAOF会被延迟。serverCron函数会处理被延迟的BGREWRITEAOF命令。</p>
<p>2.2.7    检查持久化操作的状态</p>
<p>redisServer中使用两个属性值记录BGSAVE和BGREWRITEAOF是否正在执行。</p>
<p>2.2.8    将AOF缓冲区内容写入AOF文件</p>
<p>serverCron负责将缓冲区内的内容写入AOF文件。</p>
<h4 id="3-初始化服务器"><a href="#3-初始化服务器" class="headerlink" title="3)  初始化服务器"></a>3)  初始化服务器</h4><p>初始化服务器的第一步是创建redisServer结构的变量实例作为服务器状态，同时为各个属性值设置默认值，例如设置运行ID，运行频率、配置文件路径、运行架构、默认端口号、持久化条件、LRU时钟、创建命令表。</p>
<p>启动服务器时，可以通过默认配置文件、指定配置文件、指定配置参数三种方式来进行。</p>
<p>在正确载入配置选项后，服务器会初始化数据结构，比如redisClients，redisDb等等，并设置初始值。</p>
<p>初始化数据结构之后，服务器需要载入AOF文件或RDB文件，还原数据库状态。</p>
<p>最后一步，服务器打印出如下日志：</p>
<p>The server is now ready to accept connections on port 6379</p>
<p>并开始执行服务器的事件循环(loop)。</p>
<h3 id="3-客户端与服务器端通信协议"><a href="#3-客户端与服务器端通信协议" class="headerlink" title="3.  客户端与服务器端通信协议"></a>3.  客户端与服务器端通信协议</h3><p>主流编程语言都会支持Redis，例如Java，C#，PHP，Python，Node.js，C，C++等。一是因为Redis非常流行，非常高效；二是因为Redis客户端与服务器端的通信是基于TCP的；三是因为Redis制定了RESP（Redis Serialization Protocal，Redis序列化协议）实现客户端与服务端的正常交互。</p>
<h4 id="1-发送命令格式"><a href="#1-发送命令格式" class="headerlink" title="1)  发送命令格式"></a>1)  发送命令格式</h4><p>RESP标准发送命令格式如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">*[参数数量]\r\n</span><br><span class="line"></span><br><span class="line">$[参数1的字节数量]\r\n</span><br><span class="line"></span><br><span class="line">[参数1]\r\n</span><br><span class="line"></span><br><span class="line">…</span><br><span class="line"></span><br><span class="line">$[参数N的字节数量]\r\n</span><br><span class="line"></span><br><span class="line">[参数N]\r\n</span><br></pre></td></tr></table></figure>


<p>例如执行命令SET hello world，客户端会将其封装成如下格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">*3</span><br><span class="line"></span><br><span class="line"><span class="variable">$3</span></span><br><span class="line"></span><br><span class="line">SET</span><br><span class="line"></span><br><span class="line"><span class="variable">$5</span></span><br><span class="line"></span><br><span class="line">hello</span><br><span class="line"></span><br><span class="line"><span class="variable">$5</span></span><br><span class="line"></span><br><span class="line">world</span><br></pre></td></tr></table></figure>


<p>要注意的是，上面是格式化之后的结果，真正内容如下格式：</p>
<p>*3\r\n$3\r\nSET\r\n$5\r\nhello\r\n$5\r\nworld\r\n</p>
<h4 id="2-返回结果格式"><a href="#2-返回结果格式" class="headerlink" title="2)  返回结果格式"></a>2)  返回结果格式</h4><p>RESP标准返回结果类型有5种：</p>
<p><strong>1)</strong>    状态恢复：第一个字节为”+”。</p>
<p><strong>2)</strong>    错误恢复：第一个字节为”-”。</p>
<p><strong>3)</strong>    整数回复：第一个字节为”:”。</p>
<p><strong>4)</strong>    字符串回复：第一个字节为”$”。</p>
<p><strong>5)</strong>    多条字符串回复：第一个字节为”*”。</p>
<p>为什么客户端看到的结果没有这些符号？因为redis-cli本身就是按照RESP进行解析过了。对这些首字节符号进行了删除。</p>
<p>真实结果如下图：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">SET hello world</span><br><span class="line"></span><br><span class="line">+OK</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">SETFALSJFJFJFJFJ</span><br><span class="line"></span><br><span class="line">+ERR unknown <span class="built_in">command</span> ‘SETFALSJFJFJFJFJ’</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">INCR count</span><br><span class="line"></span><br><span class="line">:1</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">GET hello</span><br><span class="line"></span><br><span class="line"><span class="variable">$5</span></span><br><span class="line"></span><br><span class="line">world</span><br><span class="line"></span><br><span class="line">其实此处结果为<span class="variable">$5</span>\r\nworld\r\n</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">MSET java jedis python redis-py</span><br><span class="line"></span><br><span class="line">+OK</span><br><span class="line"></span><br><span class="line">MGET java python</span><br><span class="line"></span><br><span class="line">*2</span><br><span class="line"></span><br><span class="line"><span class="variable">$5</span></span><br><span class="line"></span><br><span class="line">jedis</span><br><span class="line"></span><br><span class="line"><span class="variable">$8</span></span><br><span class="line"></span><br><span class="line">redis-py</span><br></pre></td></tr></table></figure>

<h3 id="4-事件"><a href="#4-事件" class="headerlink" title="4.  事件"></a>4.  事件</h3><p>Redis是基于事件驱动，服务器需要处理以下两类事件：</p>
<p><strong>1)</strong>    文件事件</p>
<p>Redis服务器通过socket与客户端（或其他Redis服务器）进行连接，而文件事件就是服务器对socket操作的抽象。服务器与客户端（或其他服务器）的通信会产生相应的文件事件，服务器通过监听并处理这些时间来完成网络通信操作。</p>
<p><strong>2)</strong>    时间事件</p>
<p>Redis服务器的一些操作（比如serverCron函数）需要在给定的时间点执行，而时间事件就是对此类定时操作的抽象。</p>
<h4 id="1-文件事件"><a href="#1-文件事件" class="headerlink" title="1)  文件事件"></a>1)  文件事件</h4><p>Redis有自己的文件事件处理器：</p>
<p><strong>1)</strong>    使用I&#x2F;O多路复用程序来监听多个socket，并根据socket目前执行的任务来为socket关联不同的事件处理器。</p>
<p><strong>2)</strong>    当被监听的socket准备好执行连接应答(accept)，读取(read)，写入(write)，关闭(close)等操作时，与操作对应的文件事件就会产生。此时文件事件处理器就会调用socket之前的事件处理器来处理这些事件。</p>
<p>文件事件处理器构成如下图：</p>
<p>​<br><img src="/2022/02/15/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%935-%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8E%E5%AE%A2%E6%88%B7%E7%AB%AF/8.png" alt="img"><center><em>文件事件处理器的构成</em></center></p>
<p><strong>1)</strong>    一个服务器通常会连接多个socket，所以文件事件会有可能并发的出现。</p>
<p><strong>2)</strong>    I&#x2F;O多路复用程序负责监听，并向文件事件分派器传送那些产生了事件的socket。这个传送过程会首先将socket都放在一个队列中，然后以有序的、同步的、每次一个socket的方式传送给事件分派器。当上一个socket产生的事件被处理完毕后，I&#x2F;O多路复用程序才会向文件事件分派器传送下一个socket。</p>
<p><strong>3)</strong>    文件事件分派器接收socket之后，会根据socket产生的事件的类型，调用响应的事件处理器。</p>
<p><strong>4)</strong>    服务器为执行不同任务的socket关联不同的事件处理器，即一个一个不同的函数。</p>
<p>1.2  时间事件</p>
<p>Redis服务器将所有的时间事件都放在一个无序链表中，每当时间事件执行器运行时，它就遍历整个链表，查找已经到时的时间事件，并调用相应的事件处理器。这里的无序指的是链表中的事件并没有按照时间排序，而是简单的连在一起。所以必须遍历全部。</p>
<p>正常模式下的Redis服务器只有一个serverCron时间事件。它的主要工作包括：</p>
<p><strong>1)</strong>    更新服务器的各类统计信息，比如时间、内存占用、数据库占用情况等。</p>
<p><strong>2)</strong>    清理过期键值对。</p>
<p><strong>3)</strong>    关闭和清理连接失败的客户端。</p>
<p><strong>4)</strong>    尝试进行AOF或者RDB持久化。</p>
<p><strong>5)</strong>    如果服务器是主服务器，那么对从服务器进行同步。</p>
<p><strong>6)</strong>    如果处于集群模式，那么进行同步和连接测试。</p>
<p>1.3  事件的调度和运行</p>
<p>每次事件循环，服务器都会对文件事件和时间事件进行处理。如下图：</p>
<p>​<br><img src="/2022/02/15/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%935-%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8E%E5%AE%A2%E6%88%B7%E7%AB%AF/9.png" alt="img"><center><em>服务器运行流程</em></center></p>
<p>文件事件和时间事件是合作关系，服务器会轮流处理这两种时间，并且处理的过程中不会进行资源抢占。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://basonson.github.io/2022/02/15/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%934-%E6%8C%81%E4%B9%85%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="郭超">
      <meta itemprop="description" content="学习,分享,进步">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大牙技术">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/02/15/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%934-%E6%8C%81%E4%B9%85%E5%8C%96/" class="post-title-link" itemprop="url">Redis技术总结4-持久化</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-02-15 09:32:49 / Modified: 10:40:34" itemprop="dateCreated datePublished" datetime="2022-02-15T09:32:49+08:00">2022-02-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/NoSQL/" itemprop="url" rel="index"><span itemprop="name">NoSQL</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/NoSQL/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="1-数据库"><a href="#1-数据库" class="headerlink" title="1.  数据库"></a>1.  数据库</h3><h4 id="1-1-数据库结构"><a href="#1-1-数据库结构" class="headerlink" title="1.1  数据库结构"></a>1.1  数据库结构</h4><p>一个Redis服务器中有多个（默认16个）数据库。这些数据库都保存在redisServer结构中，每一个数据库都是一个redisDB结构，如下图：</p>
<p>​<br><img src="/2022/02/15/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%934-%E6%8C%81%E4%B9%85%E5%8C%96/1.png" alt="img"><center><em>redisServer代码示意</em></center></p>
<p>初始化服务器时，程序会根据dbnum属性来决定创建多少个数据库。如下图：</p>
<p>​<br><img src="/2022/02/15/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%934-%E6%8C%81%E4%B9%85%E5%8C%96/2.png" alt="img"><center><em>redisServer结构示意</em></center></p>
<p>每个Redis客户端都有自己的目标数据库，可以用SELECT命令进行切换。在程序中，客户端的状态记录在redisClient结构中，如下图：</p>
<p>​<br><img src="/2022/02/15/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%934-%E6%8C%81%E4%B9%85%E5%8C%96/3.png" alt="img"><center><em>redisClient代码示意</em></center></p>
<p>redisClient.db指向redisServer.db数组中的一个元素，而被指向的元素就是客户端的目标数据库。</p>
<p>如果客户端最开始指向数据库1，如下图：</p>
<p>​<br><img src="/2022/02/15/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%934-%E6%8C%81%E4%B9%85%E5%8C%96/4.png" alt="img"><center><em>客户端指向数据库1</em></center></p>
<p>当执行命令SELECT 2之后，客户端会指向数据库2，如下图：</p>
<p>​<br><img src="/2022/02/15/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%934-%E6%8C%81%E4%B9%85%E5%8C%96/5.png" alt="img"><center><em>客户端指向数据库2</em></center></p>
<p>redisClient.db指针的改变就是SELECT命令实现的原理。</p>
<h4 id="1-2-数据库的键空间"><a href="#1-2-数据库的键空间" class="headerlink" title="1.2  数据库的键空间"></a>1.2  数据库的键空间</h4><p>每个redisDb结构中，会有一个dict字典，保存了数据库的所有键值对，这个字段被称为键空间。</p>
<p>​<br><img src="/2022/02/15/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%934-%E6%8C%81%E4%B9%85%E5%8C%96/6.png" alt="img"><center><em>redisDb代码示意</em></center></p>
<p>键空间就是用户所能感知到的数据库：</p>
<p>键空间中的键就是数据库中的键，每个键是一个字符串对象。</p>
<p>键空间中的值就是数据库中的值，每个值可以是5种Redis对象中的一种。</p>
<p>例如一个包含了列表键alphabet，哈希键book，字符串对象message的数据库结构，如下图：</p>
<p>​<br><img src="/2022/02/15/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%934-%E6%8C%81%E4%B9%85%E5%8C%96/7.png" alt="img"><center><em>redisDb结构示意</em></center></p>
<p>所有针对数据库的操作，比如对键的增删改查，其实都是在对键空间字典进行操作。</p>
<p>不光是增删改查，其他的命令，比如FLUSHDB命令，其实是删除键空间所有键值对；比如DBSIZE命令，是返回键空间中键值对数量；RANDOMKEY命令，是随机返回键空间中某一个键。</p>
<p>当读写数据库的键空间时，服务器还会执行一些额外的维护操作：</p>
<p><strong>1)</strong>    在读取一个键后（读操作和写操作都要对键进行读取），服务器会根据键是否存在，来更新服务器的键空间命中次数和键空间不命中次数。这两个值可以在INFO STATS命令中查看。</p>
<p><strong>2)</strong>    在读取一个键后，服务器会更新键的LRU时间，这个值用于计算键的空转时间，使用OBJECT IDLETIME命令查看。</p>
<p><strong>3)</strong>    在读取一个键时，如果发现键已经过期，服务器会删除这个键。</p>
<p><strong>4)</strong>    当修改一个键后，服务器会将该键标记为脏dirty，让使用WATCH命令监视此键的客户端知道该键已经被修改。</p>
<p><strong>5)</strong>    服务器每修改一个键，都会对脏键计数器+1，这个计数器会触发服务器的持久化和复制操作。</p>
<p><strong>6)</strong>    对键进行修改之后，如果服务器开启了数据库通知功能，会按照配置发送相应的数据库通知。</p>
<h4 id="1-3-设置键的生存时间和过期时间"><a href="#1-3-设置键的生存时间和过期时间" class="headerlink" title="1.3  设置键的生存时间和过期时间"></a>1.3  设置键的生存时间和过期时间</h4><p>有4个命令来设置键的生存时间和过期时间：</p>
<p><strong>1)    EXPIRE</strong></p>
<p>以秒为单位，设置某个键的生存时间，指定秒后，键过期。</p>
<p><strong>2)    PEXPIRE</strong></p>
<p>以毫秒为单位，设置某个键的生存时间。</p>
<p><strong>3)    EXPIREAT</strong></p>
<p>以秒为精度，设置某个键的过期时间，UNIX秒数时间戳。</p>
<p><strong>4)    PEXPIREAT</strong></p>
<p>以毫秒为精度，设置某个键的过期时间，UNIX毫秒数时间戳。</p>
<p>实际上，EXPIRE,PEXPIRE,EXPIREAT命令，都是使用PEXPIREAT命令来实现的：即无论客户端执行哪一个命令，最终都是执行PEXPIREAT命令。</p>
<p>在redisDb结构中，字典expires保存了数据库中所有键的过期时间，我们称为过期字典，如下图：</p>
<p>​<br><img src="/2022/02/15/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%934-%E6%8C%81%E4%B9%85%E5%8C%96/8.png" alt="img"><center><em>redisDb代码示意</em></center></p>
<p>过期字典的键是一个指针，指向键空间中的某个键对象；</p>
<p>过期字典的值是一个long long型整数，保存着键指向的数据库键的过期时间：毫秒级精度的UNIX时间戳。</p>
<p>如下图：</p>
<p>​<br><img src="/2022/02/15/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%934-%E6%8C%81%E4%B9%85%E5%8C%96/9.png" alt="img"><center><em>redisDb结构示意</em></center></p>
<p>移除过期时间可以用PERSIST命令。PERSIST命令时PEXPIREAT命令的反操作，将键从过期字典中移除。</p>
<p>获取剩余时间可以用TTL命令（返回秒）和PTTL命令（返回毫秒）。</p>
<p>判断键是否过期步骤如下：</p>
<p><strong>1)</strong>    检查给定键是否在过期字典中，如果存在，那么获取键的过期时间；</p>
<p><strong>2)</strong>    检查当前UNIX时间戳是否大于键的过期时间，如果是那么键已经过期。如果不是，那么嗨未过期。</p>
<p>虽然用TTL和PTTL命令也可以判断键是否过期，但是访问字典要比执行一个命令稍微快一点。</p>
<h4 id="1-4-过期键删除策略"><a href="#1-4-过期键删除策略" class="headerlink" title="1.4  过期键删除策略"></a>1.4  过期键删除策略</h4><p>过期键删除有3种策略：</p>
<p><strong>1)</strong>    定时删除。</p>
<p>设置过期键的时候，同时生成一个定时器。当定时器到时之后，对键进行删除操作。</p>
<p>优点是对内存最友好，缺点是对CPU最不友好。</p>
<p><strong>2)</strong>    惰性删除</p>
<p>每次从键空间中读取键的时候，都检查是否过期，如果过期就删除。没过期正常操作。</p>
<p>优点是对CPU最友好，缺点是对内存不友好。</p>
<p><strong>3)</strong>    定期删除</p>
<p>每隔一段时间，程序对数据库进行一次检查，删除过期键。每次检查多少数据库、多少键、删除多少键，由算法决定。</p>
<p>优点是折中方案，兼顾CPU和内存。缺点是难以确定删除操作的算法策略。</p>
<p>Redis采用惰性删除和定时删除两种策略。</p>
<p><strong>1)</strong>    惰性删除就是由expireIfNeeded函数实现。所有读写数据库的Redis命令，在执行之前都会调用expireIfNeeded函数对输入键进行检查。</p>
<p><strong>2)</strong>    定时删除由activeExpireCycle函数实现。Redis服务器有一个周期性操作函数serverCron。每当serverCron函数执行时，activeExpireCycle函数会被调用。步骤如下：</p>
<p>a)    从一定数量的数据库中随机选取一定数量的键，删除其中过期键。</p>
<p>b)   使用current_db记录当前activeExpireCycle函数执行进度（数据库编号），下次执行从下一个数据库开始。</p>
<p>c)    所有数据检查完成后，current_db置0。之后开始新一轮。</p>
<h4 id="1-5-RDB、AOF、复制功能对过期键的处理"><a href="#1-5-RDB、AOF、复制功能对过期键的处理" class="headerlink" title="1.5  RDB、AOF、复制功能对过期键的处理"></a>1.5  RDB、AOF、复制功能对过期键的处理</h4><p>对RDB文件来说，过期键不会对服务器产生影响。因为：</p>
<p><strong>1)</strong>    生成RDB文件</p>
<p>当执行SAVE命令或者BGSAVE命令创建RDB文件时，程序会对数据库中的键进行检查，过期键不会生成在RDB文件中。</p>
<p><strong>2)</strong>    载入RDB文件</p>
<p>如果服务器以主服务器模式运行，载入时程序会对过期键进行忽略。</p>
<p>如果服务器以从服务器模式运行，所有键会全部载入。但是主从进行数据同步时，从服务器会按照主服务器数据进行更新，所以过期键也不会对服务器产生影响。</p>
<p>对AOF文件来说，略复杂：</p>
<p><strong>1)</strong>    写入AOF文件</p>
<p>如果某个键已经过期，但是还未被删除策略删除。那么对AOF文件，不会有影响。</p>
<p>当过期键被删除的时候，程序会在删除该键之后，向AOF文件追加一条DEL命令。</p>
<p><strong>2)</strong>    AOF重写</p>
<p>在执行AOF重写命令时，会忽略已过期的键，不会保存在重写之后的AOF文件中。</p>
<p>当服务器运行在复制模式下时，过期键删除操作由主服务器控制：</p>
<p><strong>1)</strong>    主服务器删除一个过期键后，向所有从服务器发送DEL命令，告诉从服务器对过期键进行删除。</p>
<p><strong>2)</strong>    从服务器执行读命令时，不会判断键是否过期，即使过期也按未过期处理。</p>
<p><strong>3)</strong>    从服务器只有接收到DEL命令后，才会对键进行删除。</p>
<h3 id="2-RDB持久化"><a href="#2-RDB持久化" class="headerlink" title="2.  RDB持久化"></a>2.  RDB持久化</h3><p>RDB（Redis DataBase）持久化功能，相当于提供一个数据库的快照，保存在磁盘，避免数据丢失。RDB持久化功能生成的RDB文件是一个经过压缩的二进制文件。</p>
<h4 id="2-1-RDB文件的创建和载入"><a href="#2-1-RDB文件的创建和载入" class="headerlink" title="2.1  RDB文件的创建和载入"></a>2.1  RDB文件的创建和载入</h4><p>有2个Redis命令可以用于生成RDB文件，SAVE和BGSAVE。</p>
<p><strong>1)    SAVE</strong></p>
<p>阻塞服务器进程，直到RDB文件创建完毕为止。在服务器阻塞期间，不能处理任何命令。待RDB文件生成之后，客户端发送的命令才会被处理。</p>
<p><strong>2)    BGSAVE</strong></p>
<p>fork一个子进程，由子进程负责创建RDB文件，服务器进程（父进程）继续处理命令。</p>
<p>但是要注意的是，对SAVE、BGSAVE、BGREWRITEAOF三个命令的处理会有所不同。</p>
<p>a)    SAVE和BGSAVE命令会被服务器拒绝。</p>
<p>b)   如果BGSAVE正在执行，那么BGREWRITEAOF会被延迟到BGSAVE执行完毕后执行。</p>
<p>c)    如果BGREWRITEAOF命令正在执行，那么BGSAVE命令会被拒绝。</p>
<p>和使用命令创建RDB文件不同的是，Redis并没有载入RDB文件的命令。载入RDB文件是在Redis启动时自动执行的。</p>
<p>服务器在载入RDB文件期间，会一直处于阻塞状态，直到载入工作完成为止。</p>
<h4 id="2-2-自动间隔性保存"><a href="#2-2-自动间隔性保存" class="headerlink" title="2.2  自动间隔性保存"></a>2.2  自动间隔性保存</h4><p>Redis允许用户通过配置项，设置服务器执行BGSAVE命令的频率（条件）。</p>
<p>默认：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">save 900 1 //900s内做了1次修改</span><br><span class="line"></span><br><span class="line">save 300 10 //300秒内做了10次修改</span><br><span class="line"></span><br><span class="line">save 60 10000 //60秒内做了10000次修改</span><br></pre></td></tr></table></figure>

<p>满足任何一个条件，服务器就会执行BGSAVE命令。</p>
<p>保存条件在redisServer中的结构如下：</p>
<p>​<br><img src="/2022/02/15/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%934-%E6%8C%81%E4%B9%85%E5%8C%96/10.png" alt="img"><center><em>redisServer代码示意</em></center></p>
<p>saveparams是一个数组，每个元素是一个saveparam结构，这个结构保存着save选项设置的保存条件：</p>
<p>​<br><img src="/2022/02/15/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%934-%E6%8C%81%E4%B9%85%E5%8C%96/11.png" alt="img"><center><em>saveparam代码示意</em></center></p>
<p>保存着saveparams的redisServer结构如下：</p>
<p>​<br><img src="/2022/02/15/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%934-%E6%8C%81%E4%B9%85%E5%8C%96/12.png" alt="img"><center><em>redisServer结构示意</em></center></p>
<p>除了saveparams数组外，服务器状态还同时维持着一个dirty计数器和一个lastsave属性。</p>
<p>\1)    dirty计数器记录了上一次执行SAVE或者BGSAVE命令后，服务器对数据库状态进行了多少次修改。</p>
<p>\2)    lastsave属性是一个UNIX时间戳，记录了上一次成功执行SAVE或者BGSAVE命令的时间。</p>
<p>如下图：</p>
<p>​<br><img src="/2022/02/15/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%934-%E6%8C%81%E4%B9%85%E5%8C%96/13.png" alt="img"><center><em>redisServer代码示意图</em></center></p>
<p>Redis服务器周期性操作函数serverCron默认每个100ms执行一次。该函数的其中一个工作就是检查save选项所设置的条件是否已经满足（遍历saveparams数组，只要一个条件满足即可），如果满足则执行BGSAVE命令。</p>
<p>除了满足save条件，还有3种触发RDB持久化操作的场景：</p>
<p><strong>1)</strong>    从节点执行全量复制操作时，主节点自动执行BGSAVE命令生成RDB文件传输给从节点。</p>
<p><strong>2)</strong>    执行DEBUG RELOAD命令重新加载Redis时，也会触发SAVE。</p>
<p><strong>3)</strong>    执行SHUTDOWN命令时，如果没有开启AOF持久化，则自动执行BGSAVE。</p>
<h4 id="2-3-优缺点"><a href="#2-3-优缺点" class="headerlink" title="2.3  优缺点"></a>2.3  优缺点</h4><p>RDB文件是一个紧凑压缩（如果开启了RDB压缩设置）的二进制文件，代表Redis在某个时间点的快照。非常适合用于备份、全量复制等场景。加载RDB文件恢复数据的速度也远快于AOF文件。</p>
<p>但RDB方式数据没有办法做到实时持久化（或者秒级持久化），因为BGSAVE命令需要fork子进程，属于重量级操作，耗费资源高。RDB文件也会有版本兼容性问题。</p>
<h3 id="3-AOF持久化"><a href="#3-AOF持久化" class="headerlink" title="3.  AOF持久化"></a>3.  AOF持久化</h3><p>AOF(Append Only File)持久化功能，是Redis提供的另一个持久化功能。</p>
<p>假设有3个命令依次执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SET msg “hello”</span><br><span class="line"></span><br><span class="line">SADD fruits “apple” “banana” “cherry”</span><br><span class="line"></span><br><span class="line">RPUSH numbers 128 231 456</span><br></pre></td></tr></table></figure>

<p>RDB持久化保存数据库的方式是将msg、fruits、numbers三个键值存储在RDB文件中，而AOF持久化的方式是保存3个命令到AOF文件中。</p>
<p>如果服务器开启了AOF持久化功能，那么会优先使用AOF进行数据库状态的还原。只有在AOF持久化功能处于关闭状态时，服务器才会使用RDB文件来还原数据库。</p>
<h4 id="3-1-AOF持久化功能的实现"><a href="#3-1-AOF持久化功能的实现" class="headerlink" title="3.1  AOF持久化功能的实现"></a>3.1  AOF持久化功能的实现</h4><p>AOF持久化功能可以分为**命令追加(append)、文件写入、文件同步(sync)**三步。</p>
<p>当AOF持久化功能处于打开状态时，服务器在执行完一个写命令后，会按照协议格式将执行的命令追加到服务器状态的aof_buf缓冲区末尾：</p>
<p>​<br><img src="/2022/02/15/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%934-%E6%8C%81%E4%B9%85%E5%8C%96/14.png" alt="img"><center><em>redisServer代码示意</em></center></p>
<p>Redis的服务器进程是一个<strong>事件循环</strong>。这个循环包含两类事件：</p>
<p><strong>1)    文件事件</strong></p>
<p>负责接收客户端的命令，以及向客户端发送命令回复。</p>
<p><strong>2)    时间事件</strong></p>
<p>负责执行像serverCron这样需要定时运行的函数。</p>
<p>服务器在每结束一个事件循环之前，都会调用flushAppendOnlyFile方法，考虑是否要将aof_buf缓冲区的内容<strong>写入和同步</strong>到AOF文件里。</p>
<p>注意：写入和同步是两个操作。</p>
<p>flushAppendOnlyFile函数的行为由服务器配置的appendfsync选项的值确定，如下表所示：</p>
<table>
<thead>
<tr>
<th>appendfsync</th>
<th>flushAppendOnlyFile函数行为</th>
</tr>
</thead>
<tbody><tr>
<td>always</td>
<td>将aof_buf缓冲区内所有内容写入并同步到AOF文件</td>
</tr>
<tr>
<td>everysec（默认）</td>
<td>将aof_buf缓冲区内所有内容写入到AOF文件，如果上次同步AOF时间距现在超过1秒钟，那么会再次同步，这个同步操作由一个线程专门负责执行</td>
</tr>
<tr>
<td>no</td>
<td>将aof_buf缓冲区内所有内容写入到AOF文件，但不对AOF文件进行同步，何时同步由操作系统指定。</td>
</tr>
</tbody></table>
<p><strong>关于文件的写入和同步：</strong></p>
<p>为了提高文件的写入效率，现代操作系统中，当用户调用write函数，操作系统通常会将写入数据暂时保存在一个内存缓冲区中，等到缓冲区的空间被填满，或者超过了指定的时限之后，才真正的将缓冲区中的数据写入到磁盘中。</p>
<p>虽然提高了效率，但是也带来了安全问题，加入计算机宕机，那么保存在内存缓冲区中的尚未同步到磁盘中的数据将会丢失。</p>
<p>所以，操作系统提供了fsync和fdatasync两个同步函数，他们可以强制让操作系统立刻将缓冲区中的数据写入到磁盘中，从而确保写入数据的安全性。</p>
<p><strong>关于三种方式的分析：</strong></p>
<p><strong>1)    always</strong></p>
<p>服务器在每个事件循环结束，都会进行写入和同步操作。所以效率是最慢的，但也是最安全的。</p>
<p><strong>2)    everysec</strong></p>
<p>服务器在每个事件循环结束，都会进行写入操作，同时每隔一秒进行同步操作。所以效率足够快，而且最多丢失1s的数据。</p>
<p><strong>3)    no</strong></p>
<p>服务器在每个事件循环结束，都会进行写入操作，无需程序执行同步操作。所以效率是最快的，但是最不安全。</p>
<h4 id="3-2-AOF文件的载入"><a href="#3-2-AOF文件的载入" class="headerlink" title="3.2  AOF文件的载入"></a>3.2  AOF文件的载入</h4><p>Redis读取AOF文件的步骤如下：</p>
<p><strong>1)</strong>    创建一个不带网络连接的伪客户端。</p>
<p>因为Redis的命令只能在客户端中执行，所以服务器使用了一个没有网络连接的伪客户端，执行命令的效果和带网络连接的真实客户端效果是完全一样的。</p>
<p><strong>2)</strong>    从AOF文件中分析并读取一条写命令；</p>
<p><strong>3)</strong>    使用伪客户端执行该命令。</p>
<p><strong>4)</strong>    重复执行2和3，直到AOF文件中的所有写命令都被处理完毕。</p>
<h4 id="3-3-AOF重写"><a href="#3-3-AOF重写" class="headerlink" title="3.3  AOF重写"></a>3.3  AOF重写</h4><p>随着服务器运行时间增加，AOF文件中的数据也会越来越多。为了解决AOF文件体积膨胀的问题，Redis提供了AOF文件重写(rewrite)功能。</p>
<p>AOF重写过程可以通过手动触发（直接调用BGREWRITEAOF命令）和自动触发（根据AOF重写时文件最小体积auto-aof-rewrite-min-size和当前AOF空间和上次重写后AOF空间比值auto-aof-rewrite-percentage自动重写）。</p>
<p>虽然这个功能被叫做AOF文件重写，但是他并不需要对现有的AOF文件进行任何读取、分析、写入操作，这个功能是通过读取服务器当前数据库的状态来实现的。</p>
<p>比如之前服务器对一个键执行了6次写命令，那么保存在AOF文件中，关于这个键的命令会有6条。当要重写时，不会依次分析6条语句，而是直接读取当前数据库该键的值，然后用一条写命令记录键值对，来代替之前的多条语句。这就是AOF重写功能的实现原理。</p>
<p>因为AOF文件重写可能会涉及到大量的命令写入和同步文件的操作，如果直接调用会造成服务器进程阻塞。所以Redis会单独fork一个子进程来执行重写操作。</p>
<p>但是如果在子进程重写期间，如果有命令到来，会对数据库状态造成不一致的现象。 为了解决这个问题，Redis服务器设置了一个<strong>AOF重写缓冲区</strong>，这个缓冲区会在服务器创建子进程之后开始使用，当Redis服务器执行完一个写命令后，他会将写命令同时写入AOF缓冲区和AOF重写缓冲区。</p>
<p>当子进程完成AOF重写工作后，他会向父进程发送一个信号，父进程收到信号会调用一个函数，执行以下操作：</p>
<p><strong>1)</strong>    将AOF重写缓冲区中的所有内容写入到新的AOF文件中。保证AOF文件所保存的数据库状态跟服务器当前状态一致。</p>
<p><strong>2)</strong>    对新的AOF文件改名，覆盖现有AOF文件，完成新旧两个AOF文件的替换。</p>
<p>具体过程如下表：</p>
<table>
<thead>
<tr>
<th>时间</th>
<th>父进程</th>
<th>子进程</th>
</tr>
</thead>
<tbody><tr>
<td>T1</td>
<td>执行命令SET k1 v1</td>
<td></td>
</tr>
<tr>
<td>T2</td>
<td>执行命令SET k1 v2</td>
<td></td>
</tr>
<tr>
<td>T3</td>
<td>执行命令SET k1 v3</td>
<td></td>
</tr>
<tr>
<td>T4</td>
<td>创建子进程，执行AOF文件重写</td>
<td>开始AOF文件重写</td>
</tr>
<tr>
<td>T5</td>
<td>执行命令SET k2 123</td>
<td>执行重写操作</td>
</tr>
<tr>
<td>T6</td>
<td>执行命令SET k3 456</td>
<td>执行重写操作</td>
</tr>
<tr>
<td>T7</td>
<td>执行命令SET k4 789</td>
<td>完成AOF重写，向父进程发送信号</td>
</tr>
<tr>
<td>T8</td>
<td>收到信号，将T5T6T7三个命令追加到新的AOF文件末尾</td>
<td></td>
</tr>
<tr>
<td>T9</td>
<td>用新的AOF文件替换旧AOF文件</td>
<td></td>
</tr>
</tbody></table>
<p>以上就是BGREWRITEAOF命令的实现原理。</p>
<p>在Redis启动时，持久化文件加载流程如下：</p>
<p><strong>1)</strong>    AOF持久化开启并且存在AOF时，优先加载AOF文件；</p>
<p><strong>2)</strong>    AOF关闭时，加载RDB文件；</p>
<p><strong>3)</strong>    加载AOF或者RDB文件成功后，Redis启动成功；</p>
<p><strong>4)</strong>    AOF或者RDB文件存在错误时，Redis启动失败并打印错误信息。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://basonson.github.io/2022/02/14/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%933-%E5%AF%B9%E8%B1%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="郭超">
      <meta itemprop="description" content="学习,分享,进步">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大牙技术">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/02/14/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%933-%E5%AF%B9%E8%B1%A1/" class="post-title-link" itemprop="url">Redis技术总结3-对象</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-02-14 16:01:03 / Modified: 16:57:30" itemprop="dateCreated datePublished" datetime="2022-02-14T16:01:03+08:00">2022-02-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/NoSQL/" itemprop="url" rel="index"><span itemprop="name">NoSQL</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/NoSQL/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="1-对象"><a href="#1-对象" class="headerlink" title="1.  对象"></a>1.  对象</h3><p>Redis 并没有直接使用123456所描述的来实现键值对数据库， 而是基于这些数据结构创建了一个对象系统， 这个系统包含字符串对象、列表对象、哈希对象、集合对象和有序集合对象这五种类型的对象， 每种对象都用到了至少一种我们前面所介绍的数据结构。</p>
<p><strong>1.</strong>   Redis可以在执行命令之前，根据对象的类型来判断一个对象是否可以执行给定的命令。</p>
<p><strong>2.</strong>   Redis针对不同的使用场景，为对象设置多种不同的数据结构实现，从而优化对象在不同场景下的使用效率。</p>
<p><strong>3.</strong>   Redis的对象系统还实现了基于引用计数技术的内存回收机制：当程序不再使用某个对象的时候，这个对象所占用的内存就会被自动释放；</p>
<p><strong>4.</strong>   Redis还通过引用计数技术实现了对象共享机制，这一机制可以在适当的条件下，通过让多个数据库键共享同一个对象来节约内存。</p>
<p><strong>5.</strong>   Redis的对象带有访问时间记录信息，该信息可以用于计算数据库键的空转时长，在服务器启用了maxmemory功能的情况下，空转时长较大的那些键可能会优先被服务器删除。</p>
<h4 id="对象的类型和编码"><a href="#对象的类型和编码" class="headerlink" title="对象的类型和编码"></a>对象的类型和编码</h4><p>Redis 使用对象来表示数据库中的键和值，当创建一个键值对时，我们至少会创建两个对象， 一个对象用作键值对的键（键对象）， 另一个对象用作键值对的值（值对象）。</p>
<p>比如当执行命令set msg “hello world”时，数据库中新增了一个键值对，其中键值对的键是一个包含了字符串值 “msg” 的对象， 而键值对的值则是一个包含了字符串值 “hello world” 的对象：</p>
<p>​       Redis中的每个对象由redisObject结构表示，如下图：</p>
<p><img src="/2022/02/14/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%933-%E5%AF%B9%E8%B1%A1/1.png" alt="img"><center><em>redisObject代码示意</em></center></p>
<p><strong>1.   type</strong></p>
<p>type属性记录了对象的类型，如下表列出的类型常量中的一个：</p>
<table>
<thead>
<tr>
<th>类型常量</th>
<th>对象名称</th>
<th>TYPE命令的输出</th>
</tr>
</thead>
<tbody><tr>
<td>REDIS_STRING</td>
<td>字符串对象</td>
<td>“string”</td>
</tr>
<tr>
<td>REDIS_LIST</td>
<td>列表对象</td>
<td>“list”</td>
</tr>
<tr>
<td>REDIS_HASH</td>
<td>哈希对象</td>
<td>“hash”</td>
</tr>
<tr>
<td>REDIS_SET</td>
<td>集合对象</td>
<td>“set”</td>
</tr>
<tr>
<td>REDIS_ZSET</td>
<td>有序集合对象</td>
<td>“zset”</td>
</tr>
</tbody></table>
<p>对于Redis数据库保存的键值对来说，键总是一个字符串对象，而值则可以是字符串对象、列表对象、哈希对象、集合对象或者有序集合对象的其中一种。</p>
<p><strong>2.   encoding和ptr</strong></p>
<p>对象的ptr指针指向对象的底层实现数据结构，而这些数据结构由对象的encoding属性决定。</p>
<p>encoding,ptr的关系如下表：</p>
<table>
<thead>
<tr>
<th>编码</th>
<th>底层数据结构</th>
<th>OBJECT  ENCODING输出</th>
</tr>
</thead>
<tbody><tr>
<td>REDIS_ENCODING_INT</td>
<td>long类型整数</td>
<td>“int”</td>
</tr>
<tr>
<td>REDIS_ENCODING_EMBSTR</td>
<td>embstr编码的简单动态字符串</td>
<td>“embstr”</td>
</tr>
<tr>
<td>REDIS_ENCODING_RAW</td>
<td>简单动态字符串</td>
<td>“raw”</td>
</tr>
<tr>
<td>REDIS_ENCODING_HT</td>
<td>字典</td>
<td>“hashtable”</td>
</tr>
<tr>
<td>REDIS_ENCODING_LINKEDLIST</td>
<td>双向链表</td>
<td>“linkedlist”</td>
</tr>
<tr>
<td>REDIS_ENCODING_ZIPLIST</td>
<td>压缩列表</td>
<td>“ziplist”</td>
</tr>
<tr>
<td>REDIS_ENCODING_INTSET</td>
<td>整数集合</td>
<td>“intset”</td>
</tr>
<tr>
<td>REDIS_ENCODING_SKIPLIST</td>
<td>跳跃表</td>
<td>“skiplist”</td>
</tr>
</tbody></table>
<p>每个type都至少对应了2种的encoding，type和encoding决定了对象的结构类型，如下表：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>编码</th>
<th>对象</th>
</tr>
</thead>
<tbody><tr>
<td>REDIS_STRING</td>
<td>REDIS_ENCODING_INT</td>
<td>整数值实现的字符串对象</td>
</tr>
<tr>
<td>REDIS_STRING</td>
<td>REDIS_ENCODING_EMBSTR</td>
<td>embstr编码的SDS的字符串对象</td>
</tr>
<tr>
<td>REDIS_STRING</td>
<td>REDIS_ENCODING_RAW</td>
<td>SDS实现的字符串对象</td>
</tr>
<tr>
<td>REDIS_LIST</td>
<td>REDIS_ENCODING_ZIPLIST</td>
<td>压缩列表实现的列表对象</td>
</tr>
<tr>
<td>REDIS_LIST</td>
<td>REDIS_ENCODING_LINKEDLIST</td>
<td>双向链表实现的列表对象</td>
</tr>
<tr>
<td>REDIS_HASH</td>
<td>REDIS_ENCODING_ZIPLIST</td>
<td>压缩列表实现的哈希对象</td>
</tr>
<tr>
<td>REDIS_HASH</td>
<td>REDIS_ENCODING_HT</td>
<td>字典实现的哈希对象</td>
</tr>
<tr>
<td>REDIS_SET</td>
<td>REDIS_ENCODING_INTSET</td>
<td>整数集合实现的集合对象</td>
</tr>
<tr>
<td>REDIS_SET</td>
<td>REDIS_ENCODING_HT</td>
<td>字典实现的集合对象</td>
</tr>
<tr>
<td>REDIS_ZSET</td>
<td>REDIS_ENCODING_ZIPLIST</td>
<td>压缩列表实现的有序集合对象</td>
</tr>
<tr>
<td>REDIS_ZSET</td>
<td>REDIS_ENCODING_SKIPLIST</td>
<td>跳跃表和字典实现的有序集合对象</td>
</tr>
</tbody></table>
<h3 id="2-对象类型"><a href="#2-对象类型" class="headerlink" title="2.  对象类型"></a>2.  对象类型</h3><h4 id="2-1-字符串对象"><a href="#2-1-字符串对象" class="headerlink" title="2.1  字符串对象"></a>2.1  字符串对象</h4><p>字符串对象的编码可以是int,raw,embstr。</p>
<p>如果一个字符串对象保存的是整数值，并且这个整数值（假设为10086）可以用long类型来表示，那么字符串对象会将整数值保存在字符串对象结构的ptr属性里面（将void*转换成long），并将字符串对象的编码设置为int。如下图：</p>
<p>​<br><img src="/2022/02/14/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%933-%E5%AF%B9%E8%B1%A1/2.png" alt="img"><center><em>int编码的字符串对象</em></center></p>
<p>如果字符串对象保存的是一个字符串值，并且这个字符串值（假设为”Long long ago, there lived a king…”）的长度大于39字节，那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串值，并将对象的编码设置为raw。如下图：</p>
<p>​<br><img src="/2022/02/14/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%933-%E5%AF%B9%E8%B1%A1/3.png" alt="img"><center><em>raw编码的字符串对象</em></center></p>
<p>如果字符串对象保存的是一个字符串值， 并且这个字符串值的长度小于等于 39 字节， 那么字符串对象将使用 embstr 编码的方式来保存这个字符串值。</p>
<p>embstr 编码是专门用于保存短字符串,和 raw编码一样，都使用redisObject结构和sdshdr结构来表示字符串对象，但raw编码会调用两次内存分配函数来分别创建redisObject结构和sdshdr结构，而embstr编码则通过调用一次内存分配函数来分配一块连续的空间，空间中依次包含redisObject和sdshdr两个结构，如图所示：</p>
<p><img src="/2022/02/14/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%933-%E5%AF%B9%E8%B1%A1/3.1.png" alt="img"><center><em>redisObject和sdshdr</em></center></p>
<p>使用embstr进行编码的好处：</p>
<p><strong>a.</strong>   embstr 编码将创建字符串对象所需的内存分配次数从 raw 编码的两次降低为一次。</p>
<p><strong>b.</strong>   释放 embstr 编码的字符串对象只需要调用一次内存释放函数， 而释放 raw 编码的字符串对象需要调用两次内存释放函数。</p>
<p><strong>c.</strong>   因为 embstr 编码的字符串对象的所有数据都保存在一块连续的内存里面，所以这种编码的字符串对象比起 raw 编码的字符串对象能够更好地利用缓存带来的优势。</p>
<p>除了整型之外，使用long double类型表示的浮点数在Redis中也是作为字符串值来保存的：如果我们要保存一个浮点数到字符串对象里面，那么程序会先将这个浮点数转换成字符串值，然后再保存起转换所得的字符串值。在有需要的时候，程序会将保存在字符串对象里面的字符串值转换回浮点数值，执行某些操作，然后再将执行操作所得的浮点数值转换回字符串值，并继续保存在字符串对象里面。</p>
<p>字符串对象保存各类型值的编码方式：</p>
<table>
<thead>
<tr>
<th>值</th>
<th>编码</th>
</tr>
</thead>
<tbody><tr>
<td>可以用 long 类型保存的整数</td>
<td>int</td>
</tr>
<tr>
<td>可以用 long double 类型保存的浮点数</td>
<td>embstr或者raw</td>
</tr>
<tr>
<td>字符串值，或者因为长度太大而没办法用long类型表示的整数，又或者因为长度太大而没办法用long double类型表示的浮点数</td>
<td>embstr或者raw</td>
</tr>
</tbody></table>
<p>int 编码的字符串对象和 embstr 编码的字符串对象在条件满足的情况下， 会被转换为 raw 编码的字符串对象。</p>
<p><strong>1)</strong>   对于 int 编码的字符串对象来说， 如果我们向对象执行了一些命令， 使得这个对象保存的不再是整数值， 而是一个字符串值， 那么字符串对象的编码将从 int 变为 raw 。</p>
<p><strong>2)</strong>   对embstr 编码的字符串对象，Redis没有编写任何相应的修改程序 （只有 int 编码的字符串对象和 raw 编码的字符串对象有这些程序）， 所以 embstr 编码的字符串对象实际上是<strong>只读</strong>的。当我们对 embstr 编码的字符串对象执行任何修改命令时，程序会先将对象的编码从 embstr 转换成 raw ，然后再执行修改命令； 因为这个原因，embstr编码的字符串对象在执行修改命令之后，会变成一个raw编码的字符串对象。</p>
<h4 id="2-2-列表对象"><a href="#2-2-列表对象" class="headerlink" title="2.2  列表对象"></a>2.2  列表对象</h4><p>列表对象的编码可以是 ziplist 或者 linkedlist 。</p>
<p>ziplist 编码的列表对象使用压缩列表作为底层实现， 每个压缩列表节点（entry）保存了一个列表元素。当执行命令：RPUSH numbers 1 “three” 5时，如下图所示：</p>
<p>​<br><img src="/2022/02/14/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%933-%E5%AF%B9%E8%B1%A1/4.png" alt="img"><center><em>ziplist编码的numbers列表对象</em></center></p>
<p>当使用双向链表作为底层实现，每个双向链表节点（node）都保存了一个字符串对象，而每个字符串对象都保存了一个列表元素。</p>
<p>​<br><img src="/2022/02/14/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%933-%E5%AF%B9%E8%B1%A1/5.png" alt="img"><center><em>linkedlist编码的numbers列表对象</em></center></p>
<p>注意：</p>
<p><strong>1.</strong>   linkedlist 编码的列表对象在底层的双端链表结构中包含了多个字符串对象， 这种嵌套字符串对象的行为在稍后介绍的哈希对象、集合对象和有序集合对象中都会出现， 字符串对象是 Redis 五种类型的对象中唯一一种会被其他四种类型对象嵌套的对象。</p>
<p><strong>2.</strong>   图中所示StringObject结构，其实是一种简化，真实情况下的结构应该是如下图：</p>
<p><img src="/2022/02/14/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%933-%E5%AF%B9%E8%B1%A1/5.1.png" alt="img"><center><em>StringObject真实结构</em></center></p>
<p>当列表对象可以同时满足以下两个条件时， 列表对象使用 ziplist 编码：</p>
<p><strong>1.</strong>   列表对象保存的所有字符串元素的长度都小于 64 字节；</p>
<p><strong>2.</strong>   列表对象保存的元素数量小于 512 个；</p>
<p>不能满足这两个条件的列表对象需要使用 linkedlist 编码。</p>
<p>对于使用ziplist编码的列表对象来说，当使用ziplist编码所需的两个条件的任意一个不能被满足时，对象的编码转换操作就会被执行：原本保存在压缩列表里的所有列表元素都会被转移并保存到双端链表里面，对象的编码也会从 ziplist 变为 linkedlist 。</p>
<h4 id="2-3-哈希对象"><a href="#2-3-哈希对象" class="headerlink" title="2.3  哈希对象"></a>2.3  哈希对象</h4><p>哈希对象的编码可以是 ziplist 或者 hashtable 。</p>
<p>ziplist 编码的哈希对象使用压缩列表作为底层实现， 每当有新的键值对要加入到哈希对象时， 程序会先将保存了键的压缩列表节点推入到压缩列表表尾， 然后再将保存了值的压缩列表节点推入到压缩列表表尾。</p>
<p>当依次执行命令：</p>
<p>HSET testH name “Tom” </p>
<p>HSET testH age 25 </p>
<p>HSET testH career “Programmer”</p>
<p>结构如下图所示。</p>
<p>​<br><img src="/2022/02/14/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%933-%E5%AF%B9%E8%B1%A1/6.png" alt="img"><center><em>ziplist编码的testH对象</em></center></p>
<p>其中上图中的压缩列表结构如下表所示：</p>
<p>​<br><img src="/2022/02/14/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%933-%E5%AF%B9%E8%B1%A1/7.png" alt="img"><center><em>压缩列表结构</em></center></p>
<p>当使用hashtable 编码时，哈希对象使用字典作为底层实现，哈希对象中的每个键值对都使用一个字典键值对来保存：</p>
<p><strong>1.</strong>   字典的每个键都是一个字符串对象，对象中保存了键值对的键；</p>
<p><strong>2.</strong>   字典的每个值都是一个字符串对象，对象中保存了键值对的值。</p>
<p>上述testH对象的结构如下：</p>
<p>​<br><img src="/2022/02/14/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%933-%E5%AF%B9%E8%B1%A1/8.png" alt="img"><center><em>hashtable编码的testH哈希对象结构</em></center></p>
<p>dict结构也进行了简化，详细图如下：</p>
<p><img src="/2022/02/14/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%933-%E5%AF%B9%E8%B1%A1/9.png" alt="img"><center><em>dict结构</em></center></p>
<p>当哈希对象可以同时满足以下两个条件时， 哈希对象使用 ziplist 编码：</p>
<p><strong>1.</strong>   哈希对象保存的所有键值对的键和值的字符串长度都小于 64 字节；</p>
<p><strong>2.</strong>   哈希对象保存的键值对数量小于 512 个；</p>
<p>不能满足这两个条件的哈希对象需要使用 hashtable 编码。</p>
<p>对于使用 ziplist 编码的列表对象来说， 当使用 ziplist 编码所需的两个条件的任意一个不能被满足时，对象的编码转换操作就会被执行：原本保存在压缩列表里的所有键值对都会被转移并保存到字典里面，对象的编码也会从 ziplist 变为hashtable。</p>
<h4 id="2-4-集合对象"><a href="#2-4-集合对象" class="headerlink" title="2.4  集合对象"></a>2.4  集合对象</h4><p>集合对象的编码可以是 intset 或者 hashtable 。</p>
<p>intset 编码的集合对象使用整数集合作为底层实现， 集合对象包含的所有元素都被保存在整数集合里面。</p>
<p>当执行命令:SADD numbers 1 3 5后，结构如下图：</p>
<p>​<br><img src="/2022/02/14/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%933-%E5%AF%B9%E8%B1%A1/10.png" alt="img"><center><em>intset编码的numbers集合对象</em></center></p>
<p>如果使用hashtable 编码，集合对象使用字典作为底层实现，字典的每个键都是一个字符串对象，每个字符串对象包含了一个集合元素，而字典的值则全部被设置为NULL。</p>
<p>如果执行命令：SDD fruits “apple” “banana” “cherry”后，如下图：</p>
<p>​<br><img src="/2022/02/14/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%933-%E5%AF%B9%E8%B1%A1/11.png" alt="img"><center><em>hashtable编码的fruits集合对象</em></center></p>
<p>当集合对象可以同时满足以下两个条件时， 对象使用intset编码：</p>
<p><strong>1.</strong>   集合对象保存的所有元素都是整数值；</p>
<p><strong>2.</strong>   集合对象保存的元素数量不超过512个；</p>
<p>不能满足这两个条件的集合对象需要使用hashtable编码。</p>
<h4 id="2-5-有序集合对象"><a href="#2-5-有序集合对象" class="headerlink" title="2.5  有序集合对象"></a>2.5  有序集合对象</h4><p>有序集合的编码可以是 ziplist 或者 skiplist 。</p>
<p>ziplist 编码的有序集合对象使用压缩列表作为底层实现，每个集合元素使用两个紧挨在一起的压缩列表节点来保存， 第一个节点保存元素的成员（member）， 而第二个元素则保存元素的分值（score）。</p>
<p>压缩列表内的集合元素按分值从小到大进行排序，分值较小的元素被放置在靠近表头的方向， 而分值较大的元素则被放置在靠近表尾的方向。</p>
<p>如果执行命令：ZADD price 8.5 apple 5.0 banana 6.0 cherry，那么ziplist结构如下图：</p>
<p>​<br><img src="/2022/02/14/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%933-%E5%AF%B9%E8%B1%A1/12.png" alt="img"><center><em>ziplist编码的有序集合对象</em></center></p>
<p>压缩列表结构如下：</p>
<p>​<br><img src="/2022/02/14/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%933-%E5%AF%B9%E8%B1%A1/13.png" alt="img"><center><em>压缩列表结构</em></center></p>
<p>如果使用skiplist 编码，那么有序集合对象使用 zset 结构作为底层实现， 一个 zset 结构同时包含一个字典和一个跳跃表，代码结构如下：</p>
<p>​<br><img src="/2022/02/14/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%933-%E5%AF%B9%E8%B1%A1/14.png" alt="img"><center><em>zset代码结构</em></center></p>
<p>假设price对象使用skiplist编码，那么结构如下：</p>
<p>​<br><img src="/2022/02/14/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%933-%E5%AF%B9%E8%B1%A1/15.png" alt="img"><center><em>skiplist编码的有序集合对象</em></center></p>
<p>其中zset结构如下：</p>
<p>​<br><img src="/2022/02/14/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%933-%E5%AF%B9%E8%B1%A1/16.png" alt="img"><center><em>zset结构（包括字典与跳跃表）</em></center></p>
<p><strong>1.</strong>   zset结构中的zsl跳跃表按分值从小到大保存了所有集合元素。通过这个跳跃表，程序可以对有序集合进行范围型操作，比如ZRANK（查找排名）、ZRANGE（返回给定索引范围内的元素）等命令就是基于跳跃表API来实现的。</p>
<p><strong>2.</strong>   zset 结构中的 dict 字典为有序集合创建了一个从成员到分值的映射。 通过这个字典，程序可以用 O(1) 复杂度查找给定成员的分值，ZSCORE（查询分值）命令就是根据这一特性实现的，而很多其他有序集合命令都在实现的内部用到了这一特性。</p>
<p><strong>3.</strong>   有序集合每个元素的成员都是一个字符串对象， 而每个元素的分值都是一个 double 类型的浮点数。 </p>
<p><strong>4.</strong>   虽然 zset 结构同时使用跳跃表和字典来保存有序集合元素， 但这两种数据结构都会通过指针来共享相同元素的成员和分值， 所以同时使用跳跃表和字典来保存集合元素不会产生任何重复成员或者分值， 也不会因此而浪费额外的内存。</p>
<p>疑问：为什么要同时使用跳跃表和字典?</p>
<p>回答：效率。</p>
<p>如果我们只使用字典来实现有序集合，那么可以以 O(1) 复杂度查找成员。但是，因为字典的无序特性，所以每次在执行范围型操作（ZRANK、ZRANGE等），程序都需要对字典保存的所有元素进行排序，完成这种排序需要至少 O(Nlog N) 时间复杂度，以及额外的 O(N) 内存空间（因为要创建一个数组来保存排序后的元素）。</p>
<p>另一方面，如果我们只使用跳跃表来实现有序集合，那么跳跃表执行范围型操作的所有优点都会被保留，但因为没有了字典，所以根据成员查找分值这一操作的复杂度将从O(1)上升为O(log N)。</p>
<p>当有序集合对象可以同时满足以下两个条件时， 对象使用 ziplist 编码：</p>
<p><strong>1.</strong>   有序集合保存的元素数量小于 128 个；</p>
<p><strong>2.</strong>   有序集合保存的所有元素成员的长度都小于 64 字节；</p>
<p>不能满足以上两个条件的有序集合对象将使用 skiplist 编码。</p>
<p>对于使用ziplist编码的有序集合对象来说，当使用ziplist编码所需的两个条件中的任意一个不能被满足时，程序就会执行编码转换操作，将原本储存在压缩列表里面的所有集合元素转移到zset结构里面，并将对象的编码从ziplist改为 skiplist。</p>
<h3 id="3-对象处理"><a href="#3-对象处理" class="headerlink" title="3  对象处理"></a>3  对象处理</h3><h4 id="3-1-类型检查与命令多态"><a href="#3-1-类型检查与命令多态" class="headerlink" title="3.1 类型检查与命令多态"></a>3.1 类型检查与命令多态</h4><p>Redis 中用于操作键的命令基本上可以分为两种类型。</p>
<p><strong>1)</strong>    可以对任何类型的键执行，比如说DEL、EXPIRE、RENAME、TYPE等等。</p>
<p><strong>2)</strong>    只能对特定键执行，例如：SET、HSET、RPUSH、SADD、ZADD等等。</p>
<p><strong>1.</strong>   类型检查的实现：</p>
<p>在执行一个类型特定的命令之前，Redis会先检查输入键的类型是否正确， 然后再决定是否执行给定的命令。类型特定命令所进行的类型检查是通过 redisObject结构的type属性来实现的，过程如下：</p>
<p><strong>1)</strong>    在执行一个类型特定命令之前，服务器会先检查输入数据库键的值对象是否为执行命令所需的类型，如果是的话，服务器就对键执行指定的命令；</p>
<p><strong>2)</strong>    否则，服务器将拒绝执行命令，并向客户端返回一个类型错误。</p>
<p><strong>2.</strong>   多态命令的实现</p>
<p>Redis除了会根据值对象的类型来判断键是否能够执行指定命令之外，还会根据值对象的编码方式，选择正确的命令实现代码来执行命令。</p>
<p>例如，列表对象有ziplist和linkedlist两种编码可用，如果我们对一个键执行LLEN命令，那么服务器除了要确保执行命令的是列表键之外，还需要根据键的值对象所使用的编码来选择正确的 LLEN 命令实现：</p>
<p><strong>1)</strong>    如果列表对象的编码为ziplist ，那么说明列表对象的实现为压缩列表， 程序将使用ziplistLen函数来返回列表的长度；</p>
<p><strong>2)</strong>    如果列表对象的编码为linkedlist，那么说明列表对象的实现为双端链表，程序将使用 listLength 函数来返回双端链表的长度；</p>
<p>所以，借用面向对象方面的术语来说，我们可以认为LLEN命令是多态的： 只要执行LLEN命令的是列表键，那么无论值对象使用的是ziplist编码还是linkedlist编码，命令都可以正常执行。</p>
<p>实际上，我们可以将DEL、EXPIRE、TYPE等命令也称为多态命令，因为无论输入的键是什么类型，这些命令都可以正确地执行。这些命令和LLEN命令的区别在于，前者是基于类型的多态：一个命令可以同时用于处理多种不同类型的键，而后者是基于编码的多态：一个命令可以同时用于处理多种不同编码。</p>
<h4 id="3-2-内存回收"><a href="#3-2-内存回收" class="headerlink" title="3.2  内存回收"></a>3.2  内存回收</h4><p>因为C语言并不具备自动的内存回收功能， 所以Redis在自己的对象系统中构建了一个引用计数技术实现的内存回收机制，通过这一机制，程序可以通过跟踪对象的引用计数信息，在适当的时候自动释放对象并进行内存回收。</p>
<p>在redisObject结构中，除了type，encoding，ptr三者外，还是用了引用计数器，如下图：</p>
<p>​<br><img src="/2022/02/14/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%933-%E5%AF%B9%E8%B1%A1/17.png" alt="img"><center><em>redisObject代码示意图</em></center></p>
<p>对象的引用计数信息会随着对象的使用状态而不断变化：</p>
<p><strong>1)</strong>    在创建一个新对象时，引用计数的值会被初始化为1；</p>
<p><strong>2)</strong>    当对象被一个新程序使用时，它的引用计数值会被增1；</p>
<p><strong>3)</strong>    当对象不再被一个程序使用时，它的引用计数值会被减1；</p>
<p><strong>4)</strong>    当对象的引用计数值变为 0 时，对象所占用的内存会被释放。</p>
<h4 id="3-3-对象共享"><a href="#3-3-对象共享" class="headerlink" title="3.3  对象共享"></a>3.3  对象共享</h4><p>对象的引用计数属性，还带有对象共享的作用。假设键A创建了一个包含整数值 100 的字符串对象作为值对象，如果要创建一个B，同时也包含整数值100的字符串对象作为值。那么相比于为键B新创建一个字符串对象的做法来说，<strong>让键A和键B共享一个值对象更节约内存</strong>，步骤如下：</p>
<p><strong>1)</strong>    将数据库键的值指针指向一个现有的值对象；</p>
<p><strong>2)</strong>    将被共享的值对象的引用计数增1。</p>
<p>可以使用OBJECT REFCOUNT命令查看对象的引用次数。</p>
<p>比如说， 假设数据库中保存了整数值 100 的键不只有键 A 和键 B 两个， 而是有一百个，那么服务器只需要用一个字符串对象的内存就可以保存原本需要使用一百个字符串对象的内存才能保存的数据。</p>
<p>目前来说，Redis会在初始化服务器时，创建10000（可配置）个字符串对象，这些对象包含了从0到9999的所有整数值，当服务器需要用到值为0到9999的字符串对象时，服务器就会使用这些共享对象，而不是新创建对象。</p>
<p>受到复杂度的限制，Redis只对保存<strong>整数值</strong>的字符串对象进行共享。</p>
<h4 id="3-4-空转时长"><a href="#3-4-空转时长" class="headerlink" title="3.4 空转时长"></a>3.4 空转时长</h4><p>redisObject结构包含的最后一个属性为lru属性，该属性记录了对象最后一次被命令程序访问的时间：</p>
<p>​<br><img src="/2022/02/14/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%933-%E5%AF%B9%E8%B1%A1/18.png" alt="img"><center><em>redisObject代码示意</em></center></p>
<p>用OBJECT IDLETIME命令可以显示出键的空转时长（通过计算当前时间和对象的lru时间计算得出）。值得注意的是：OBJECT IDLETIME命令访问键的时候，不会更新lru时间。</p>
<p>空转时长的主要作用是： 如果服务器打开了maxmemory选项， 并且服务器用于回收内存的算法为volatile-lru或者allkeys-lru，那么当服务器占用的内存数超过了maxmemory选项所设置的上限值时，空转时长较高的那部分键会优先被服务器释放，从而回收内存。</p>
<p>备注：</p>
<p>volatile-lru:根据LRU算法删除设置了超时属性（expire）的键，直到腾出足够空间为止。</p>
<p>allkeys-lru:根据LRU算法删除键，不管数据有没有设置超时属性，直到腾出足够空间为止。</p>
<p>其他淘汰策略：</p>
<p><strong>1.</strong>   noeviction：当内存使用超过配置的时候会返回错误，不会删除任何键 </p>
<p><strong>2.</strong>   allkeys-random：加入键的时候如果过限，从所有key随机删除</p>
<p><strong>3.</strong>   volatile-random：加入键的时候如果过限，从过期键的集合中随机驱逐 </p>
<p><strong>4.</strong>   volatile-ttl：从配置了过期时间的键中删除最早要过期的键 </p>
<p><strong>5.</strong>   volatile-lfu：从所有配置了过期时间的键中删除使用频率最少的键 </p>
<p><strong>6.</strong>   allkeys-lfu：从所有键中删除使用频率最少的键</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://basonson.github.io/2022/02/14/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%932-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="郭超">
      <meta itemprop="description" content="学习,分享,进步">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大牙技术">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/02/14/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%932-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="post-title-link" itemprop="url">Redis技术总结2-数据结构</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-02-14 14:15:56 / Modified: 15:59:52" itemprop="dateCreated datePublished" datetime="2022-02-14T14:15:56+08:00">2022-02-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/NoSQL/" itemprop="url" rel="index"><span itemprop="name">NoSQL</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/NoSQL/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="1-简单动态字符串"><a href="#1-简单动态字符串" class="headerlink" title="1.  简单动态字符串"></a>1.  简单动态字符串</h3><p>Redis虽然是基于C语言，但并没有使用C语言中的字符串。而是构建了一个名为简单动态字符串（Simple Dynamic String, SDS）的类型，并将SDS作为Redis默认的字符串表示。</p>
<p>在Redis中，有一种情况会使用C语言的字符串，就是常量字符串。除此之外，都会使用SDS来表示字符串值。同时，SDS还会被用作缓冲区：AOF中的缓冲区，以及客户端状态中的输入缓冲区都是用SDS实现的。</p>
<p>例如：Redis 所有的数据结构都是以唯一的 key 字符串作为名称，然后通过这个唯一 key 值来获取相应的 value 数据。不同类型的数据结构的差异就在于 value 的结构不一样。但是这个key使用的结构，都是字符串类型。</p>
<h4 id="1-1-SDS的定义"><a href="#1-1-SDS的定义" class="headerlink" title="1.1  SDS的定义"></a>1.1  SDS的定义</h4><p>每个sdshdr结构表示一个SDS：</p>
<p><img src="/2022/02/14/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%932-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1.png" alt="img"><center><em>SDS代码示意</em></center></p>
<p><img src="/2022/02/14/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%932-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/2.png" alt="img"><center><em>SDS结构示意</em></center></p>
<p>SDS遵循了C语言以’\0’结尾的惯例，保存空字符的一个长度空间不计算在len值里，并且为’\0’分配额外的空间，以及其他各种操作，都是有SDS函数完成，对使用者是透明的。</p>
<h4 id="1-2-SDS与C字符串的区别"><a href="#1-2-SDS与C字符串的区别" class="headerlink" title="1.2  SDS与C字符串的区别"></a>1.2  SDS与C字符串的区别</h4><p><strong>a.</strong>   <strong>O(1)复杂度获取字符串长度</strong></p>
<p>在C语言中，如果需要获取一个字符串长度，必须对字符串进行遍历，那么时间复杂度为O(N)。</p>
<p>但是在SDS中，因为有len的存在，所以获取长度的复杂度为O(1)。</p>
<p><strong>注意：在Redis中到处充斥着看似冗余，其实大大提高效率的方法。</strong></p>
<p><strong>b.</strong>   <strong>避免缓冲区溢出</strong></p>
<p>在C语言中，执行字符串深度融合操作strcat(s1,s2)时，默认s1的空间足够长来容纳s2。如果曾经写过java的程序员（产品经理）忘记了为s1分配足够的空间，那么会导致修改之后s1的数据，会占据原先跟他相邻的空间，导致将其他程序的数据覆盖。</p>
<p>在SDS中，需要对值进行修改时，API会检查SDS的空间是否满足修改所需要求，如果不满足，API会自动将SDS空间进行扩展，之后执行实际的修改操作。所以用户不需进行手动修改，也不会发生缓冲区溢出问题。</p>
<p><strong>c.</strong>   <strong>减少内存重分配次数</strong></p>
<p>在C语言中，字符串的底层实现是一个N+1个字符长度的数组（额外的一个字符空间保存’\0’）。所以每次增长或缩短C字符串，程序都会对保存这个字符串的数组进行一次内存重分配的操作（拼接前首先扩展空间，截断后需要释放空间）。内存重分配涉及复杂的算法，而且可能需要执行系统调用，所以通常是个比较耗时的操作。在极度追求速度、数据修改频繁的Redis中，会对性能造成影响。</p>
<p>在SDS中，实现了<strong>空间预分配</strong>和<strong>惰性空间释放</strong>两种优化策略。</p>
<p><strong>1)    空间预分配</strong></p>
<p>当需要对SDS进行空间扩展的时候，程序不仅为SDS分配所需必要空间，同时也会分配额外的使用空间。</p>
<p>规则1：如果对SDS进行修改之后，SDS的长度（len值）小于1M，那么程序分配和len值同样大小的未使用空间。此时SDS的len值和free值相同。</p>
<p>规则2：如果对SDS修改之后，SDS长度将大于1M，那么程序会分配1M的未使用空间。</p>
<p><strong>2)    惰性空间释放</strong></p>
<p>当SDS的API需要缩短字符串时，程序并不立即使用内存重分配来回收缩短后多出来的字节，而是使用free属性将这些字节的数量记录起来，等待将来使用。</p>
<p>同时，在我们有需要时，也可以真正的释放SDS的未使用空间，所以不用担心惰性空间释放策略会造成内存浪费。</p>
<p><strong>d.</strong>   <strong>二进制安全</strong></p>
<p>因为传统C字符串符合ASCII编码，这种编码的操作的特点就是：遇零则止。即，当读一个字符串时，只要遇到’\0’结尾，就认为到达末尾，就忽略’\0’结尾以后的所有字符。因此，如果传统字符串保存图片，视频等二进制文件，操作文件时就被截断了。</p>
<p>SDS的buf被定义为字节数组，因为判断是否到达字符串结尾的依据则是len成员，这意味着它可以存放任何二进制的数据和文本数据，包括’\0’。</p>
<p>同时SDS的API都会以处理二进制的方式处理SDS存放在buf数组里的数据。</p>
<p><strong>e.</strong>   <strong>兼容部分C字符串函数</strong></p>
<p>因为SDS同样遵循C语言字符串以’\0’结尾的管理，所以SDS可以重用类似strcasecmp(忽略大小写的比较)和strcat(字符串拼接)等C语言字符串的函数。</p>
<h3 id="2-链表"><a href="#2-链表" class="headerlink" title="2.  链表"></a>2.  链表</h3><p>当list类型包含了超过??个元素，或者元素长度超过??字节时，链表会作为列表的底层实现。同时，发布与订阅，慢查询、监视器等功能也使用到了链表。Redis服务器本身还使用链表来保存多个客户端的状态信息，以及使用链表来构建客户端输出缓冲区。</p>
<p>节点使用listNode结构来表示：</p>
<p>​     </p>
<p><img src="/2022/02/14/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%932-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.png" alt="img"><center><em>listNode代码示意</em></center></p>
<p>如果使用多个listNode，其实可以组成链表。但为了效率和操作方便，Redis使用list结构来表示链表：</p>
<p>​     </p>
<p><img src="/2022/02/14/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%932-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/4.png" alt="img"><center><em>list代码示意</em></center></p>
<p>一个包含3个节点的链表结构如下图所示：</p>
<p><img src="/2022/02/14/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%932-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5.png" alt="img"><center><em>链表结构示意</em></center></p>
<p>Redis链表的特性有以下几点：</p>
<p><strong>1)    双端</strong></p>
<p>通过prev和next指针，获取某个节点的前置节点和后置节点的复杂度都是O(1)。</p>
<p><strong>2)    非环</strong></p>
<p>头节点的prev指针和尾结点的next指针都指向NULL,对链表的访问以NULL为终点。</p>
<p><strong>3)    头尾</strong></p>
<p>通过head指针和tail指针，程序获取链表头结点和尾结点的复杂度为O(1)。</p>
<p><strong>4)    长度</strong></p>
<p>通过len值，程序获取链表中节点数量的复杂度为O(1)。</p>
<p><strong>5)    多态</strong></p>
<p>链表节点使用void*指针来保存节点值，可以通过list结构中的dup、free、match三个属性为节点值设置类型特定函数，所以链表可以用于保存各种不同类型的值。</p>
<h3 id="3-字典"><a href="#3-字典" class="headerlink" title="3.  字典"></a>3.  字典</h3><p>字典在Redis中的应用非常广泛，比如Redis数据库就是用字典来作为底层实现的，对数据库的增删改查操作也是构建在对字典的操作之上的。除了标识数据库之外，字典也是哈希键的底层实现之一。当哈希键包含的键值对数量多，或者键值对中的元素是较长的字符串时，Redis会使用字典作为哈希键的底层实现。</p>
<p>Redis中的字典包含了哈希表节点、哈希表和字典三个结构</p>
<h4 id="3-1-哈希表节点"><a href="#3-1-哈希表节点" class="headerlink" title="3.1  哈希表节点"></a>3.1  哈希表节点</h4><p>哈希表节点使用dicEntry结构表示，如下图：</p>
<p>​     </p>
<p><img src="/2022/02/14/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%932-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/6.png" alt="img"><center><em>dictEntry代码示意</em></center></p>
<p><strong>1)</strong>    key中保存键。</p>
<p><strong>2)</strong>    val中保存值。val可以是一个指针，也可以是一个uint64_t的整数或者int64_t的整数。</p>
<p><strong>3)</strong>    next是指向另一个节点的指针，这个指针可以将多个哈希值相同的键值对连接在一起，解决哈希冲突问题。</p>
<h4 id="3-2-哈希表"><a href="#3-2-哈希表" class="headerlink" title="3.2  哈希表"></a>3.2  哈希表</h4><p>哈希表使用dictht结构定义，如下图：</p>
<p>​     </p>
<p><img src="/2022/02/14/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%932-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/7.png" alt="img"><center><em>dictht代码示意</em></center></p>
<p><strong>1)</strong>    table是一个数组，table中的每一个元素都是只想dictEntry结构的指针，每个dictEntry结构保存着一个键值对。</p>
<p><strong>2)</strong>    size属性记录了哈希表大小。</p>
<p><strong>3)</strong>    sizemask始终等于size-1，用于与哈希值一起计算index。</p>
<p><strong>4)</strong>    used属性记录已有节点的数量。</p>
<p>一个哈希表如下图所示：</p>
<p><img src="/2022/02/14/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%932-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/8.png" alt="img"><center><em>hashht结构示意</em></center></p>
<h4 id="3-3-字典"><a href="#3-3-字典" class="headerlink" title="3.3  字典"></a>3.3  字典</h4><p>Redis中的字典使用dict结构表示，如下图：</p>
<p>​     </p>
<p><img src="/2022/02/14/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%932-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/9.png" alt="img"><center><em>dict代码示意</em></center></p>
<p><strong>1)</strong>    type属性是一个指向dictType结构的指针，每个dictType结构保存了一簇用于操作特定类型键值对的函数，Redis会为用途不同的字典设置不同的类型特定函数。</p>
<p><strong>2)</strong>    privdata属性保存了需要传给那些类型特定函数的可选参数。</p>
<p><strong>3)</strong>    ht属性是一个包含2个元素的数组，其中每个项都是一个dictht哈希表。一般情况下，字典只使用ht[0]，而ht[1]只有在对ht[0]进行rehash时使用。</p>
<p><strong>4)</strong>    rehashidx属性记录了rehash目前的进度，如果没有在进行rehash，那么值为-1。</p>
<p>dict结构如下图所示：</p>
<p>​<br><img src="/2022/02/14/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%932-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/10.png" alt="img"><center><em>dict结构示意图</em></center></p>
<h4 id="3-4-哈希算法"><a href="#3-4-哈希算法" class="headerlink" title="3.4  哈希算法"></a>3.4  哈希算法</h4><p>当要将一个新的键值对添加到字典中时，程序要先根据键计算出哈希值和索引值，然后根据索引值，将包含新键值对的哈希表节点放到哈希表数组的指定索引上面。</p>
<p>Redis计算哈希值和索引值的方法如下：</p>
<p><strong>1.</strong> 使用字典设定的特定类型的哈希函数，计算键key的哈希值</p>
<p><strong>hash &#x3D; dict-&gt;type-&gt;hashFunction(key);</strong></p>
<p><strong>2.</strong> 根据哈希表的sizemask和哈希值，计算出索引值。</p>
<p>&#x2F;&#x2F;根据情况不同，ht[x]可以是ht[0]或ht[1]</p>
<p><strong>index&#x3D;hash &amp; dict-&gt;ht[x].sizemask;</strong></p>
<p>Redis使用MurmurHash2算法（目前最新版本是MurmurHash3）来计算键的哈希值。<strong>这个算法的优点在于，即使输入的键是有规律的，算法依然能够给出一个很好的随机分布性</strong>。</p>
<h4 id="3-5-哈希冲突"><a href="#3-5-哈希冲突" class="headerlink" title="3.5  哈希冲突"></a>3.5  哈希冲突</h4><p>当有2个或2个以上数量的键被分配到哈希表数组的同一个索引上面时，我们称这些键发生了冲突。</p>
<p>Redis的哈希表使用链地址法来解决哈希冲突：即next指针。通过每个哈希表节点的next指针，可以构成一个单向链表，这样被分配到同一个索引上的多个节点可以通过这个链表连接起来，解决了冲突问题。</p>
<p>因为dictEntry节点组成的链表没有指向尾部的指针，所以每次都会将新节点添加到链表的表头位置（复杂度O(1)）。排在其他已有节点的前面。</p>
<h4 id="3-6-rehash"><a href="#3-6-rehash" class="headerlink" title="3.6  rehash"></a>3.6  rehash</h4><p>随着操作的不断进行，哈希表保存的键值会不断地增多，为了让负载因子维持在一个合理的范围内，程序需要对哈希表的大小进行相应的扩展和收缩。</p>
<p>扩展和收缩哈希表通过rehash操作来完成，步骤如下：</p>
<p><strong>1)</strong>    为ht[1]分配空间，大小取决于要执行的操作以及ht[0]当前键的数量（ht[0].used的值）：</p>
<p>如果要执行扩展操作，那么ht[1]大小为 第一个大于等于ht[0].used*2的2n。</p>
<p>如果要执行收缩操作，那么ht[1]大小为 第一个大于等于ht[0].used的2n。</p>
<p><strong>2)</strong>    将保存在ht[0]中的所有键值对rehash到ht[1]上面，即重新计算哈希值和索引值，然后将键值对放置到ht[1]指定的位置上。</p>
<p><strong>3)</strong>    当ht[0]包含的键值对都迁移到ht[1]时，释放ht[0]，将ht[1]置为ht[0]，并在ht[1]创建一个空白的哈希表，为下一次rehash做准备。</p>
<h4 id="3-7-rehash的条件"><a href="#3-7-rehash的条件" class="headerlink" title="3.7  rehash的条件"></a>3.7  rehash的条件</h4><p>负载因子&#x3D;哈希表已存节点数量&#x2F;哈希表大小</p>
<p><strong>1)</strong>    当哈希表的负载因子小于0.1时，程序自动开始对哈希表执行收缩操作。</p>
<p><strong>2)</strong>    当服务器没有执行BGSAVE或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于1，程序开始对哈希表执行扩展操作。</p>
<p><strong>3)</strong>    当服务器正在执行BGSAVE或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于5，程序开始对哈希表执行扩展操作。</p>
<p>为什么正在执行命令时负载因子被扩大到5？</p>
<p>因为在执行BGSAVE和BGREWRITEAOF命令时，Redis需要创建当前服务器进程的子进程，而大多数操作系统都采用<strong>写时复制技术</strong>来优化子进程的使用效率，所以在子进程存在期间，服务器会提高负载因子，尽量避免在此期间对哈希表进行扩展操作，也就避免写入操作，最大限度节约内存。</p>
<h4 id="3-8-渐进式rehash"><a href="#3-8-渐进式rehash" class="headerlink" title="3.8  渐进式rehash"></a>3.8  渐进式rehash</h4><p>将ht[0]中的键值rehash到ht[1]中这个过程并不是一次性完成的，而是一个多次的、渐进的完成过程。因为ht[0]中存储的键值数量有可能很多，如果一次性完成，可能会导致服务暂时停止响应。</p>
<p>渐进式rehash的步骤：</p>
<p><strong>1)</strong>    为ht[1]分配空间。</p>
<p><strong>2)</strong>    将rehashidx置为0，表示rehash开始。</p>
<p><strong>3)</strong>    在rehash期间，每次对字典执行添加、删除、查找、更新操作时，程序除了执行指定的操作以外，还会顺带将ht[0]哈希表在rehashidx索引上的所有键值对rehash到ht[1]，当rehash工作完成后，程序将rehashidx属性的值增加1。</p>
<p><strong>4)</strong>    随着字典操作的不断进行，最终在某个时间点，ht[0]上面的所有键值对都会被移动至ht[1]上面，这是将rehashidx的值设置为-1，标识rehash操作已经完成。</p>
<p>渐进式rehash的要注意的点：</p>
<p><strong>1)</strong>    渐进式rehash避免了集中rehash带来的庞大计算量和宕机风险。</p>
<p><strong>2)</strong>    在渐进式rehash过程中，字典的删除、查找、更新操作，会同时在两个ht上进行。例如如果查找一个键，程序会先在ht[0]中进行查找，如果没找到，那么在ht[1]中进行查找。</p>
<p><strong>3)</strong>    在渐进式rehash过程中，字典的新增操作，一律会被保存到ht[1]中，保证ht[0]只减不增。</p>
<h3 id="4-跳跃表"><a href="#4-跳跃表" class="headerlink" title="4.  跳跃表"></a>4.  跳跃表</h3><p>跳跃表（skiplist）是一种有序的数据结构，通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。</p>
<p>Redis只在2个地方使用到了跳跃表：一是有序集合键；二是在集群节点中用作内部数据结构。</p>
<p>Redis 的跳跃表由 zskiplistNode 和 zskiplist 两个结构定义， 其中 zskiplistNode 结构用于表示跳跃表节点， 而 zskiplist 结构则用于保存跳跃表节点的相关信息。如下图：</p>
<p>​     </p>
<p><img src="/2022/02/14/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%932-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/11.png" alt="img"><center><em>跳跃表结构示意图</em></center></p>
<p>zskiplistNode结构如下图：</p>
<p>​     </p>
<p><img src="/2022/02/14/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%932-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/12.png" alt="img"><center><em>zskiplistNode代码示意图</em></center></p>
<p><strong>1)    层（L1,L2,L3,L4…）</strong></p>
<p>L1表示第一层，L2表示第二层，等等。每个层都带有两个属性：前进指针和跨度。前进指针用于访问位于表尾方向的其他节点，指向其他节点的相同层。而跨度则记录了前进指针所指向节点和当前节点的距离。</p>
<p>跳跃表节点的 level 数组可以包含多个元素，每个元素都包含一个指向其他节点的指针，<strong>程序可以通过这些层来加快访问其他节点的速度</strong>，一般来说，层的数量越多，访问其他节点的速度就越快。</p>
<p>每次创建一个新跳跃表节点的时候， 程序都根据幂次定律 （power law，越大的数出现的概率越小） 随机生成一个介于 1 和 32 之间的值作为 level 数组的大小，这个大小就是层的“高度”。包含层数越高的节点数越少。</p>
<p>层的跨度不是用于遍历，遍历只用前进指针即可完成。跨度用于计算排位：在查找某个节点的过程中，将沿途访问过的所有层的跨度累计起来，得到的结果就是目标节点在跳跃表中的排位。</p>
<p><strong>2)    后退（BW）指针</strong></p>
<p>节点中用 BW 字样标记节点的后退指针，它指向位于当前节点的前一个节点。后退指针在程序从表尾向表头遍历时使用。每个节点只有一个后退指针，所以每次智能后退至前一个节点。</p>
<p><strong>3)    分值（1.0,2.0,3.0…）</strong></p>
<p>在跳跃表中，节点按各自所保存的分值从小到大排列。分值是一个double类型浮点数。</p>
<p><strong>4)    成员对象（o1,o2,o3…）</strong></p>
<p>各个节点中的 o1 、 o2 和 o3 是节点所保存的成员对象。它是一个指针，指向一个字符串对象，字符串对象存着一个SDS值。分值相同的节点会按照成员对象在字典序中的大小进行排序。</p>
<p>虽然仅凭跳跃节点就可以组成一个跳跃表，但是通过zskiplist结构可以更方便的对整个跳跃表进行处理，比如快速访问表头节点、表尾结点、节点数量等。zskiplist结构定义如下：</p>
<p>​     </p>
<p><img src="/2022/02/14/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%932-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/13.png" alt="img"><center><em>zskiplist代码示意图</em></center></p>
<p><strong>1)    header</strong></p>
<p>指向跳跃表的表头节点</p>
<p><strong>2)    tail</strong> </p>
<p>指向跳跃表的表尾节点。</p>
<p><strong>3)    length</strong> </p>
<p>记录跳跃表的长度，也即是，跳跃表目前包含节点的数量（表头节点不计算在内）。</p>
<p><strong>4)    level</strong> </p>
<p>记录目前跳跃表内，层数最大的那个节点的层数（表头节点的层数不计算在内）。</p>
<p>通过4个属性，程序可以在O(1)复杂度内实现表头节点、表尾结点、节点数量、最大高度等。</p>
<p>关于跳跃表：</p>
<p>跳跃表的关键在于：关键节点。</p>
<p>当只有一层时，跳表其实是一个链表。如果想要插入数据或者寻找数据，只能逐个遍历比较。但当出现第二层时，第二层的值可以作为关键节点。程序可以在第二层关键节点中进行比较，确定大概位置后，返回第一层确定准确位置。同样，可以建立第三层，作为第二层关键节点的关键节点。</p>
<p>最高层是多少层？当一层中只有2个节点时，就无须再往上创建层级。</p>
<p>哪些节点往上升级？基于大数据人工智能区块链的科学严谨的算法：抛硬币。</p>
<p>复杂度？O(logN)。可以和平衡树相媲美。</p>
<h3 id="5-整数集合"><a href="#5-整数集合" class="headerlink" title="5.  整数集合"></a>5.  整数集合</h3><p>整数集合（intset）是集合键的底层实现之一： 当一个集合只包含整数值元素， 并且这个集合的元素数量不多（??）时， Redis 就会使用整数集合作为集合键的底层实现。</p>
<p>整数集合intset结构代码如下：</p>
<p>​     </p>
<p><img src="/2022/02/14/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%932-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/14.png" alt="img"><center><em>intset代码示意图</em></center></p>
<ol>
<li><p>contents 数组是整数集合的底层实现，保存着每个元素。各个项在数组中按值的大小从小到大有序地排列， 并且数组中不包含任何重复项。</p>
</li>
<li><p>length 属性记录了 contents 数组的长度。</p>
</li>
<li><p>encoding 属性的值决定而contents数组的真正类型（而不是int8_t）。随着encoding的类型（INTSET_ENC_INT16，INTSET_ENC_INT32，INTSET_ENC_INT64），contents数组类型分别是int16_t（-215-215-1），int32_t（-231-231-1），int64_t（-263-263-1）。</p>
</li>
</ol>
<p>结构示意图如下：</p>
<p>​     </p>
<p><img src="/2022/02/14/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%932-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/15.png" alt="img"><center><em>intset结构示意图</em></center></p>
<p>虽然contents数组保存的四个整数值中，只有-2675256175807981027是真正需要用int64_t类型来保存的，而其他的1、3、5三个值都可以用int16_t类型来保存，不过根据<strong>整数集合的升级规则</strong>，当向一个底层为int16_t数组的整数集合添加一个int64_t类型的整数值时，整数集合已有的所有元素都会被转换成int64_t类型，所以contents数组保存的四个整数值都是int64_t类型的，不仅仅是-2675256175807981027。</p>
<h4 id="5-1-升级"><a href="#5-1-升级" class="headerlink" title="5.1  升级"></a>5.1  升级</h4><p>每当我们要将一个新元素添加到整数集合里面，并且新元素的类型比整数集合现有所有元素的类型都要长时，整数集合需要先进行升级（upgrade）， 然后才能将新元素添加到整数集合里面。</p>
<p>升级整数集合并添加新元素共分为三步进行：</p>
<p><strong>1.</strong>   扩展原有空间。</p>
<p><strong>2.</strong>   旧元素类型转换，安放位置，按照顺序。</p>
<p><strong>3.</strong>   新元素添加。</p>
<p>假设现在有一个INTSET_ENC_INT16编码的整数集合，里面存着1，2，3。存储位置如下：</p>
<table>
<thead>
<tr>
<th>位</th>
<th>0-15</th>
<th>16-31</th>
<th>32-47</th>
</tr>
</thead>
<tbody><tr>
<td>元素</td>
<td>1</td>
<td>2</td>
<td>3</td>
</tr>
</tbody></table>
<p>当我们要存储一个32768的数字进入数组时，因为超过了int16_t的范围，所以要对数组进行升级。</p>
<p><strong>1.</strong>   根据新类型的长度， 以及集合元素的数量（包括要添加的新元素在内）， 对底层数组进行空间重分配（4个int32_t元素长度是128），分配后如下图所示：</p>
<table>
<thead>
<tr>
<th>位</th>
<th>0-15</th>
<th>16-31</th>
<th>32-47</th>
<th>48-127</th>
</tr>
</thead>
<tbody><tr>
<td>元素</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>空</td>
</tr>
</tbody></table>
<p><strong>2.</strong>   从后往前（3-&gt;2-&gt;1），依次将原有的元素放到新的位置上。</p>
<table>
<thead>
<tr>
<th>位</th>
<th>0-15</th>
<th>16-31</th>
<th>32-47</th>
<th>48-63</th>
<th>64-95</th>
<th>96-127</th>
</tr>
</thead>
<tbody><tr>
<td>元素</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>空</td>
<td>3（新）</td>
<td>空</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>位</th>
<th>0-15</th>
<th>16-31</th>
<th>32-63</th>
<th>64-95</th>
<th>96-127</th>
</tr>
</thead>
<tbody><tr>
<td>元素</td>
<td>1</td>
<td>2</td>
<td>2（新）</td>
<td>3</td>
<td>空</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>位</th>
<th>0-31</th>
<th>32-63</th>
<th>64-95</th>
<th>96-127</th>
</tr>
</thead>
<tbody><tr>
<td>元素</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>空</td>
</tr>
</tbody></table>
<p><strong>3.</strong>   添加新元素。</p>
<table>
<thead>
<tr>
<th>位</th>
<th>0-31</th>
<th>32-63</th>
<th>64-95</th>
<th>96-127</th>
</tr>
</thead>
<tbody><tr>
<td>元素</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>32768</td>
</tr>
</tbody></table>
<p><strong>4.</strong>   修改encoding 为INTSET_ENC_INT64，修改length为4。</p>
<p>注意：升级后新元素位置在哪？</p>
<p>升级后新元素位置要么在数组最开头，要么在数组最末尾。</p>
<h4 id="5-2-升级的好处"><a href="#5-2-升级的好处" class="headerlink" title="5.2  升级的好处"></a>5.2  升级的好处</h4><p><strong>1)    提高灵活性</strong></p>
<p>虽然不像某语言可以在同一数组中存入不同类型的各种元素，但是整数集合可以通过自动升级完成 int16_t、int32_t或者int64_t类型整数的兼容，而不用担心类型错误。</p>
<p><strong>2)    节约内存</strong></p>
<p>虽然可以直接用int64_t类型来存储数组，但是在整数值较小时，会造成内存浪费。整数集合可以保证升级操作仅在有必要时进行，尽量节约内存。</p>
<h4 id="5-3-降级"><a href="#5-3-降级" class="headerlink" title="5.3  降级"></a>5.3  降级</h4><p>整数集合不支持降级操作， 一旦对数组进行了升级， 编码就会一直保持升级后的状态。</p>
<h3 id="6-压缩列表"><a href="#6-压缩列表" class="headerlink" title="6.  压缩列表"></a>6.  压缩列表</h3><p>压缩列表（ziplist）是列表键和哈希键的底层实现之一。</p>
<h4 id="6-1-压缩列表的构成"><a href="#6-1-压缩列表的构成" class="headerlink" title="6.1  压缩列表的构成"></a>6.1  压缩列表的构成</h4><p>压缩列表的组成部分如下：</p>
<table>
<thead>
<tr>
<th>zlbytes</th>
<th>zltail</th>
<th>zllen</th>
<th>entry1</th>
<th>entry2</th>
<th>…</th>
<th>entryN</th>
<th>zlend</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>压缩列表各组成部分说明：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>类型</th>
<th>长度</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>zlbytes</td>
<td>uint32_t</td>
<td>4</td>
<td>记录整个压缩列表所占用内存字节数</td>
</tr>
<tr>
<td>zltail</td>
<td>uint32_t</td>
<td>4</td>
<td>记录表尾结点距离起始地址有多少字节</td>
</tr>
<tr>
<td>zllen</td>
<td>uint16_t</td>
<td>2</td>
<td>记录压缩列表节点数量</td>
</tr>
<tr>
<td>entryX</td>
<td>列表结点</td>
<td>不定</td>
<td>压缩列表各个节点</td>
</tr>
<tr>
<td>zlend</td>
<td>uint8_t</td>
<td>1</td>
<td>固定值0xFF(十进制255)，标记压缩列表末端</td>
</tr>
</tbody></table>
<p>示例如下：</p>
<table>
<thead>
<tr>
<th>zlbytes</th>
<th>zltail</th>
<th>zllen</th>
<th>entry1</th>
<th>entry2</th>
<th>entry3</th>
<th>entry4</th>
<th>entry5</th>
<th>zlend</th>
</tr>
</thead>
<tbody><tr>
<td>0xd2</td>
<td>0xb3</td>
<td>0x5</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>0xFF</td>
</tr>
<tr>
<td>P</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>P+179</td>
<td></td>
</tr>
</tbody></table>
<p><strong>1)</strong>    zlbytes属性的值为0xd2（十进制210），表示压缩列表的总长为210字节。</p>
<p><strong>2)</strong>    zltail属性的值为0xb3（十进制179），这表示如果我们有一个指向压缩列表起始地址的指针p，那么只要用指针p加上偏移量179，就可以计算出表尾节点entry5 的地址。</p>
<p><strong>3)</strong>    zllen属性的值为0x5（十进制5），表示压缩列表包含五个节点。</p>
<p><strong>4)</strong>    zllend属性的值为 0xFF（十进制255），固定值。</p>
<h4 id="6-2-压缩列表节点"><a href="#6-2-压缩列表节点" class="headerlink" title="6.2  压缩列表节点"></a>6.2  压缩列表节点</h4><p>压缩列表节点可以保存一个字节数组或一个整数值。组成部分如下：</p>
<table>
<thead>
<tr>
<th>previous_entry_length</th>
<th>encoding</th>
<th>content</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><strong>1)</strong>    previous_entry_length</p>
<p>previous_entry_length以字节为单位，记录了压缩列表中<strong>前一个节点的长度</strong>。</p>
<p>程序可以通过指针运算，根据当前节点的起始地址来计算前一个节点的起始地址。压缩列表的表尾向表头的遍历操作就是通过这一原理实现的。</p>
<p><strong>2)</strong>    encoding</p>
<p>encoding记录了节点的content属性所保存的类型及长度。</p>
<p><strong>3)</strong>    content属性</p>
<p>content属性负责保存节点的值，节点值可以是一个字节数组或者整数， 值的类型和长度由节点的encoding属性决定。</p>
<p>举例如下：</p>
<table>
<thead>
<tr>
<th>previous_entry_length</th>
<th>encoding</th>
<th>content</th>
</tr>
</thead>
<tbody><tr>
<td>…</td>
<td>00001011</td>
<td>“hello  world”</td>
</tr>
</tbody></table>
<p><strong>a)</strong>    编码的最高两位 00 表示节点保存的是一个字节数组；</p>
<p><strong>b)</strong>   编码的后六位 001011 记录了字节数组的长度 11 ；</p>
<p><strong>c)</strong>    content 属性保存着节点的值 “hello world” 。</p>
<table>
<thead>
<tr>
<th>previous_entry_length</th>
<th>encoding</th>
<th>content</th>
</tr>
</thead>
<tbody><tr>
<td>…</td>
<td>11000000</td>
<td>10086</td>
</tr>
</tbody></table>
<p><strong>a)</strong>    编码 11000000 表示节点保存的是一个 int16_t 类型的整数值；</p>
<p><strong>b)</strong>   content 属性保存着节点的值 10086 。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://basonson.github.io/2022/02/14/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%931-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="郭超">
      <meta itemprop="description" content="学习,分享,进步">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大牙技术">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/02/14/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%931-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" class="post-title-link" itemprop="url">Redis技术总结1-数据类型</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-02-14 09:57:31 / Modified: 12:34:53" itemprop="dateCreated datePublished" datetime="2022-02-14T09:57:31+08:00">2022-02-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/NoSQL/" itemprop="url" rel="index"><span itemprop="name">NoSQL</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/NoSQL/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="一．-Redis常用知识"><a href="#一．-Redis常用知识" class="headerlink" title="一． Redis常用知识"></a>一． Redis常用知识</h3><h4 id="1-常用命令"><a href="#1-常用命令" class="headerlink" title="1.  常用命令"></a>1.  常用命令</h4><p><strong>1)    keys *</strong></p>
<p>查看所有键，只看键，不看值。</p>
<p><strong>2)    dbsize</strong></p>
<p>返回当前数据库中键的数量。</p>
<p>dbsize命令在返回结果时，不会遍历所有的键，而是直接获取Redis内置的键总数变量。所以时间复杂度是O(1)。而keys会遍历所有键，所以时间复杂度是O(n)。</p>
<p><strong>通常生产环境禁止使用keys *命令。</strong></p>
<p><strong>3)    exists [key]</strong></p>
<p>返回键是否存在，存在则返回1，不存在返回0。</p>
<p><strong>4)    del [key]</strong></p>
<p>删除键。返回成功删除键的个数。如果尝试删除一个不存在的键，那么返回0。可以同时删除多个键（多个键之间用空格分隔）。</p>
<p><strong>5)    expire [key] [seconds]</strong></p>
<p>对键添加过期时间。</p>
<p><strong>6)    ttl [key]</strong></p>
<p>显示离键过期的剩余时间。三种返回值：</p>
<p>a.   -2：key不存在。</p>
<p>b.   -1：key存在但已经过期。</p>
<p>c.   n：剩余时间(秒)。</p>
<p><strong>7)    type [key]</strong></p>
<p>返回键的类型（5种）。如果键不存在返回none。</p>
<h4 id="2-数据类型及内部编码"><a href="#2-数据类型及内部编码" class="headerlink" title="2.  数据类型及内部编码"></a>2.  数据类型及内部编码</h4><p>Redis有5种数据类型（type命令返回的值）分别是：</p>
<p><strong>string（字符串）</strong></p>
<p><strong>hash（哈希）</strong></p>
<p><strong>list（列表）</strong></p>
<p><strong>set（集合）</strong></p>
<p><strong>zset（有序集合）</strong></p>
<p>每种数据类型都有2种及以上的内部编码，如下图所示：</p>
<p><img src="/2022/02/14/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%931-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/1.png" alt="img"><center><em>Redis数据类型的不同编码</em></center></p>
<p>用object encoding [key] 命令查询编码。</p>
<p>优点：</p>
<p><strong>1.</strong>   Redis可以在不改变对外接口的情况下，对内进行编码改进，提高性能，不影响用户正常使用。</p>
<p><strong>2.</strong>   多种内部编码可以在不同情形下发挥各自的优势。</p>
<p><strong>3.</strong>  单线程架构</p>
<p>Redis使用了单线程架构和I&#x2F;O多路复用模型来实现高性能的内存数据库服务。</p>
<p><img src="/2022/02/14/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%931-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/2.png" alt="img"><center><em>Redis客户端与服务器交互过程</em></center></p>
<p><img src="/2022/02/14/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%931-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/3.png" alt="img"><center><em>命令在队列中等待执行</em></center></p>
<p>Redis单线程但是依然很快的原因：</p>
<p><strong>1.</strong>   <strong>纯内存访问。</strong></p>
<p>Redis所有数据在内存中，内存访问速度可以到达100纳秒。这是Redis达到每秒万级访问的重要基础。</p>
<p><strong>2.</strong>   <strong>非阻塞I&#x2F;O。</strong></p>
<p>Redis使用epoll作为I&#x2F;O多路复用技术的实现，再加上Redis自身的事件处理模型将epoll中的连接、读写、关闭都转换为事件，不在网络I&#x2F;O上浪费过多的时间。</p>
<p>什么是epoll？</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/songchuwang1868/article/details/89877739">https://blog.csdn.net/songchuwang1868/article/details/89877739</a></p>
<p><strong>3.</strong>   <strong>单线程避免了线程切换造成的消耗。</strong></p>
<p>关于线程切换？</p>
<h3 id="二．-数据类型"><a href="#二．-数据类型" class="headerlink" title="二． 数据类型"></a>二． 数据类型</h3><h4 id="1-string-字符串"><a href="#1-string-字符串" class="headerlink" title="1.  string(字符串)"></a>1.  string(字符串)</h4><p>Redis字符串类型的值可以为简单的字符串、复杂的字符串（JSON，XML）、数字（整型，浮点型），甚至二进制（图片，音频，视频），但是最大不能超过512M</p>
<p><strong>1.1  常用命令</strong></p>
<p>除了get，set外，还有setnx，setxx，mset，mget，incr。</p>
<p><strong>1)    setnx&#x2F;setxx</strong></p>
<p>setnx是键必须不存在，才能设置成功，常用于新增。</p>
<p>setxx是键必须存在，才能设置成功，常用于更新。</p>
<p><strong>关键应用场景：</strong></p>
<p>setnx可以作为分布式锁的一种实现方案：如果多个客户端同时执行setnx [key] [value]，根据setnx的特性，只有一个客户端能设置成功。</p>
<p><strong>2)    mset&#x2F;mget</strong></p>
<p>批量执行。</p>
<p><strong>原因：</strong></p>
<p>Redis可以支撑每秒11w次的读操作&#x2F;8w次的写操作，这指的是Redis服务端的处理能力，对于客户端来说，一次命令除了执行时间还有网络时间。</p>
<p>用get命令：n次get时间&#x3D;n次网络时间+n次命令时间</p>
<p>用mget命令：n次get时间&#x3D;1次网络时间+n次命令时间</p>
<p>假如1次网络时间为1ms，1次执行时间为0.1ms。那么1000个get命令时间为1.1s，1个包含1000个key的mget命令为0.101s。</p>
<p><strong>3)    incr</strong></p>
<p>incr命令用于对值做自增操作。返回结果分为三种：</p>
<p>a.   error：值不是整数，返回错误信息。</p>
<p>b.   值是整数，返回自增之后的结果。</p>
<p>c.   键不存在，按照值为0自增，返回1.</p>
<p><strong>1.2  内部编码</strong></p>
<p>字符串类型的内部编码有3种：</p>
<p><strong>1)    int</strong></p>
<p>8个字节的长整型</p>
<p><strong>2)    embstr</strong></p>
<p>小于等于39个字节的字符串</p>
<p><strong>3)    raw</strong></p>
<p>大于39个字节的字符串</p>
<p><strong>1.3  典型场景</strong></p>
<p><strong>1)    最常用的缓存功能</strong></p>
<p><strong>2)    计数器</strong></p>
<p>播放数、点赞数。</p>
<p><strong>3)    共享session</strong></p>
<p>使用Redis对session进行集中管理。</p>
<p><strong>4)    限制操作次数</strong></p>
<p>一个操作之后在Redis中给相应操作增加一个key和一个n秒过期时间，再次操作时判断key是否存在，如果存在那么直接返回失败。</p>
<h4 id="2-hash-哈希"><a href="#2-hash-哈希" class="headerlink" title="2.  hash(哈希)"></a>2.  hash(哈希)</h4><p>哈希类型指的是键的值，本身是一个键值对类型。如下图所示：</p>
<p><img src="/2022/02/14/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%931-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/4.png" alt="img"><center><em>string与hash对比</em></center></p>
<p><strong>2.1  常用命令</strong></p>
<p>命令几乎都是h开头，比如hset，hget，h代表hash。</p>
<p><strong>2.2  内部编码</strong></p>
<p>哈希类型的内部编码有2种：</p>
<p><strong>1)    ziplist</strong></p>
<p>当哈希类型元素个数小于512个、同时所有值都小于64个字节时（512与64均为可配置项），Redis会使用ziplist作为哈希的内部实现。ziplist使用更紧凑的结构实现多个元素的连续存储，在节省内存方面更优秀。</p>
<p><strong>2)    hashtable</strong></p>
<p>当不满足ziplist的条件时，Redis会使用hashtable作为哈希的内部实现。因为此时ziplist的读写效率会下降，但是hashtable的读写时间复杂度是O(1)。</p>
<p><strong>2.3  使用场景</strong></p>
<p>用于缓存关系型数据库表中的每行信息（例如对比图中的用户信息）。但是哈希类型的每个键可以有不同的值，不局限于关系型数据库中的字段。同时，他也不能像关系型数据库那样进行复杂查询。</p>
<p>关于缓存关系型数据库中每行信息（用户信息），有3种方式可以实现：</p>
<p><strong>1)    string字符串类型</strong></p>
<p>每个属性一个键，例如</p>
<p>set user:1:name guoc12</p>
<p>set user:1:age 34</p>
<p>set user:1:city Tianjin</p>
<p>优点：简单直观。</p>
<p>缺点：占用过多的键，内存占用量较大。用户信息内聚性差（在不了解键命名规则的基础上很难查询所有值的信息）</p>
<p><strong>2)    序列化字符串类型</strong></p>
<p>将用户信息序列化后用一个键保存，例如：</p>
<p>set user:1 serialize(userInfo)</p>
<p>优点：简化编程。</p>
<p>缺点：序列化和反序列化需要一定的开销。每次更新某个属性或者获取某个属性都需要将全部属性都取出。</p>
<p><strong>3)    hash哈希类型</strong></p>
<p>每个用户属性使用一个键值对，但都是用一个键保存。</p>
<p>hset user:1 name guoc12 age 34 city Tianjin</p>
<p>优点：简单直观。</p>
<p>缺点：当使用hashtable编码会消耗更多内存。</p>
<h4 id="3-list（列表）"><a href="#3-list（列表）" class="headerlink" title="3.  list（列表）"></a>3.  list（列表）</h4><p>list（列表）用于存储多个有序的字符串，每个字符串称为element（元素），一个list最多存储232-1个元素。</p>
<p>列表有2个特点：</p>
<p><strong>1.   有序</strong></p>
<p><strong>2.   可以重复</strong></p>
<p><strong>3.1  常用命令</strong></p>
<p>列表的命令有很多，可以从列表的两端（r和l）对列表进行push（插入）和pop（弹出）操作。还可以获得指定范围内的元素列表，获取指定索引下标的元素等。</p>
<p>列表命令通常以l，r开头。例如lpush，rpush，ltrim，lrange等等。</p>
<p><strong>1)    ltrim</strong></p>
<p>ltrim [key] [start] [end]</p>
<p>例如一个列表是 testlist中包含 a,s,d,f ，在执行完ltrim testlist 1,3 之后，会剩余s,d,f。</p>
<p><strong>2)    blpop&#x2F;brpop</strong></p>
<p>他们是lpop&#x2F;rpop（左右侧弹出）的阻塞版本。命令如下：</p>
<p>blpop [key…] [seconds]</p>
<p>意思是：</p>
<p>a.    如果可以弹出，那么立即弹出。如果不可以弹出，那么等待seconds秒。期间可以弹出时立即弹出，否则等待时间到后返回nil。当seconds为0时，持续等待。</p>
<p>b.    当key为多个时，比如blpop list1 list2 list3 0，会按照从左至右的顺序，一旦有一个可以弹出，客户端立刻返回。</p>
<p>c.    当多个客户端对同一个键执行blpop命令时，最先执行（命令最先到达Redis服务器）的客户端会获取到弹出的值。剩下的客户端依次弹出或继续阻塞。</p>
<p><strong>3.2  内部编码</strong></p>
<p>list列表类型的内部编码有2种：</p>
<p><strong>1)    ziplist</strong></p>
<p>当列表元素个数小于512个、同时列表中每个元素的值都小于64字节（512与64同样是可配，但与hash类型的配置项不同）。</p>
<p><strong>2)    linkedlist</strong></p>
<p>不满足ziplist条件时，使用linkedlist进行内部实现。</p>
<p><strong>3.3  使用场景</strong></p>
<p><strong>1)    消息队列</strong></p>
<p>lpush+brpop</p>
<p><strong>2)    普通队列</strong></p>
<p>lpush+rpop</p>
<p><strong>3)    栈</strong></p>
<p>lpush+lpop</p>
<p><strong>4)    有限集合</strong></p>
<p>lpush+ltrim</p>
<h4 id="4-set（集合）"><a href="#4-set（集合）" class="headerlink" title="4.  set（集合）"></a>4.  set（集合）</h4><p>set集合也是用来保存多个字符串元素，但是与列表不同：集合中的元素是无序的，并且是不能重复的。一个集合同样能够存储232-1个元素。</p>
<p><strong>4.1  常用命令</strong></p>
<p>集合除了支持增删改查操作外，还支持多个集合取并集、交集、差集等等。</p>
<p>集合命令通常以s开头。</p>
<p><strong>1)    spop&#x2F;srandmember</strong></p>
<p>spop [key] 从集合内随机弹出一个元素</p>
<p>srandmember [key] [count] 从集合内随机返回指定个元素</p>
<p>两者都是随机弹，但是spop命令执行后，元素会从集合中删除，而srandmember不会。</p>
<p><strong>2)    sinter&#x2F;sunion&#x2F;sdiff</strong></p>
<p>sinter [key1] [key2] 返回key1和key2的交集</p>
<p>sunion [key1] [key2] 返回key1和key2的并集</p>
<p>sdiff [key1] [key2] 返回key1和key2的差集（key1里有但是key2里没有的）</p>
<p><strong>4.2  内部编码</strong></p>
<p><strong>1)    intset</strong></p>
<p>当集合中的元素都是整数，且元素个数小于512（可配）个时，Redis会选用intset作为集合的内部实现。</p>
<p><strong>2)    hashtable</strong></p>
<p>当集合类型无法满足intset条件时，Redis会使用hashtable作为内部实现。</p>
<p><strong>4.3  使用场景</strong></p>
<p><strong>1)    标签</strong></p>
<p>sadd</p>
<p><strong>2)    抽奖，随机数</strong></p>
<p>spop&#x2F;srandmember</p>
<p><strong>3)    社交（共同好友，共同关注）</strong></p>
<p>sadd + sinter</p>
<h4 id="5-zset（有序集合）"><a href="#5-zset（有序集合）" class="headerlink" title="5.  zset（有序集合）"></a>5.  zset（有序集合）</h4><p>有序集合跟集合类似，不能有重复成员。不同的是他可以排序。但是他与列表使用下标索引进行排序不同，他给每个元素设置一个score（分数）作为排序的依据。元素不能重复，但是score可以重复。</p>
<p><strong>5.1  常用命令</strong></p>
<p>有序集合的命令通常以z开头。常用命令除增删改查外，还包括计算排名、增加分数、返回排名，返回分数范围内的成员。也支持交集和并集操作但比较复杂。</p>
<p><strong>5.2  内部编码</strong></p>
<p><strong>1)    ziplist</strong></p>
<p>当有序集合的元素个数小于128个，同时每个元素的值都小于64字节时，Redis会使用ziplist作为有序集合的内部实现。</p>
<p><strong>2)    skiplist</strong></p>
<p>当ziplist条件不满足时，使用skiplist作为内部实现。</p>
<p><strong>5.3  使用场景</strong></p>
<p>排行榜系统（按照score查询或排序）</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://basonson.github.io/2022/02/09/MySQL%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="郭超">
      <meta itemprop="description" content="学习,分享,进步">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大牙技术">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/02/09/MySQL%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93-3/" class="post-title-link" itemprop="url">MySQL技术总结-3</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-02-09 11:37:42 / Modified: 14:39:23" itemprop="dateCreated datePublished" datetime="2022-02-09T11:37:42+08:00">2022-02-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="1-架构图"><a href="#1-架构图" class="headerlink" title="1.  架构图"></a>1.  架构图</h3><p><img src="/2022/02/09/MySQL%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93-3/1.png" alt="img"></p>
<p>存储引擎是数据的不同的存储的方式。</p>
<p><strong>1)</strong>    存储方式</p>
<p>存储位置，存储形式等等</p>
<p>例如：</p>
<p>InnoDB中索引文件和数据文件是存储在一个文件中的。（frm存储表结构，idb存储索引和数据）</p>
<p>MyISAM引擎中索引文件和数据文件是分开存放的。（frm存储表结构，MYD存储数据，MYI存储索引）</p>
<p>Memory引擎的数据是存储在内存中的。</p>
<p><strong>2)</strong>    事务</p>
<p>事务型引擎InnoDB和非事务型引擎MyISAM。</p>
<p><strong>3)</strong>    锁。</p>
<p>InnoDB支持表锁行锁，MyISAM支持表锁。。</p>
<p><strong>4)</strong>    索引</p>
<p>InnoDB的索引叶子节点存储数据，而MyISAM存储地址。</p>
<p><strong>5)</strong>    外键</p>
<p>InnoDB支持外键，MyISAM不支持。</p>
<h3 id="2-索引"><a href="#2-索引" class="headerlink" title="2.  索引"></a>2.  索引</h3><p>索引（在MySQL中也叫做键-key），是存储引擎用于快速找到记录的一种数据结构。索引优化是查询性能优化的最有效的手段。</p>
<h4 id="2-1-为什么要设计索引"><a href="#2-1-为什么要设计索引" class="headerlink" title="2.1.   为什么要设计索引"></a>2.1.   为什么要设计索引</h4><p><strong>加快数据访问速度。</strong></p>
<p>数据是存储在文件中，如果我们顺序访问文件，那么速度很慢。如果我们在查询前，能够迅速的知道，应该访问文件的第几行，就会大大提升速度。</p>
<h4 id="2-2-如何设计索引"><a href="#2-2-如何设计索引" class="headerlink" title="2.2.   如何设计索引"></a>2.2.   如何设计索引</h4><p>数据顺序存储在文件中，索引顺序存储在索引文件中。</p>
<p>要确定的信息：</p>
<p><strong>1.</strong>    索引值；</p>
<p><strong>2.</strong>    文件（索引文件与数据文件）的地址；</p>
<p><strong>3.</strong>    偏移量。</p>
<p>但这种设计还是会慢。因为当数据量大的时候，读取索引文件同样会很慢。</p>
<h4 id="2-3-索引的数据结构"><a href="#2-3-索引的数据结构" class="headerlink" title="2.3.   索引的数据结构"></a>2.3.   索引的数据结构</h4><p>数组，哈希，二叉树、红黑树、b树，b+树</p>
<p>官网写的是b树但其实是b+树。</p>
<p>索引是在存储引擎层而不是服务器层实现，所以提到索引是跟引擎相关联的。索引的类型包括：B-Tree索引，哈希索引，空间数据索引，全文索引等等。</p>
<h4 id="2-4-索引实现-哈希"><a href="#2-4-索引实现-哈希" class="headerlink" title="2.4.   索引实现-哈希"></a>2.4.   索引实现-哈希</h4><p>哈希索引基于哈希表实现，是Memory引擎的默认索引类型，也只有Memory显示的支持哈希索引。（Memory引擎也支持B-Tree索引）</p>
<p>假设有一个表：</p>
<table>
<thead>
<tr>
<th>oa</th>
<th>name</th>
</tr>
</thead>
<tbody><tr>
<td>guoc12</td>
<td>郭超</td>
</tr>
<tr>
<td>cuizg1</td>
<td>崔志广</td>
</tr>
<tr>
<td>wanghg6</td>
<td>王怀刚</td>
</tr>
<tr>
<td>zhaijl1</td>
<td>翟静林</td>
</tr>
<tr>
<td>liuzc24</td>
<td>刘作成</td>
</tr>
</tbody></table>
<p>哈希函数f()返回如下值：</p>
<p>f(‘guoc12’)&#x3D;1234;</p>
<p>f(‘cuizg1)&#x3D;5678;</p>
<p>f(‘wanghg6)&#x3D;2345;</p>
<p>f(‘zhaijl1)&#x3D;8765;</p>
<p>f(‘liuzc24)&#x3D;5612;</p>
<p>索引存储的形式如下(不一定是表，最终形式应该是哈希+链表)：</p>
<table>
<thead>
<tr>
<th>槽(slot)</th>
<th>值(value)</th>
</tr>
</thead>
<tbody><tr>
<td>1234</td>
<td>指向第1行的指针</td>
</tr>
<tr>
<td>2345</td>
<td>指向第3行的指针</td>
</tr>
<tr>
<td>5612</td>
<td>指向第5行的指针</td>
</tr>
<tr>
<td>5678</td>
<td>指向第2行的指针</td>
</tr>
<tr>
<td>8765</td>
<td>指向第4行的指针</td>
</tr>
</tbody></table>
<p>索引存储时按照槽值的顺序存储，但是数据行不是。如果查询：select * from table where oa &#x3D; ‘zhaijl1’。MySQL先计算‘zhaijl1’的哈希值，f(‘zhaijl1’)&#x3D;8765，所以MySQL在索引中找到8765，根据值找到指向第4行的指针，最后一步是比较第4行的oa是否为zhaijl1，以确保该行就是要查找的行。</p>
<p>哈希索引的限制是：</p>
<p><strong>1.</strong>    哈希索引只包含哈希值和行指针，而不是存储字段值，所以不能使用索引中的值来避免读取行。</p>
<p><strong>2.</strong>    哈希索引数值并不是按照索引值顺序存储的，所以无法用于排序。</p>
<p><strong>3.</strong>    哈希索引也不支持部分索引列匹配查找，因为哈希索引是用索引列的全部内容计算哈希值。</p>
<p><strong>4.</strong>    哈希索引只支持等值比较查询，包括&#x3D;，IN，&lt;&#x3D;&gt;（比较操作符&lt;&#x3D;&gt;表示NULL安全的等价比较。这个比较操作符执行等价比较，和&#x3D;操作符类似，但是如果两个操作数都是NULL，会返回1，而不是返回NULL；如果其中一个操作数是NULL,会返回0，而不是返回NULL）。不支持任何形式的范围查询。</p>
<p><strong>5.</strong>    当出现哈希冲突时，访问哈希索引上的数据时，存储引擎必须遍历链表中所有行指针，逐行比较，直到找到所有符合条件的行。</p>
<p><strong>6.</strong>    如果哈希冲突很高，一些索引维护操作的代价也会很高。</p>
<p>注意：</p>
<p><strong>1.</strong>    <strong>自适应哈希索引</strong></p>
<p>InnoDB引擎有一个功能叫自适应哈希索引（adaptive hash index），当InnoDB注意到某些索引值被使用的特别频繁时，他会在内存中基于B-Tree索引之上再创建一个哈希索引。这样就会让B-Tree索引也具有哈希索引的优点，比如快速查找。这是一个完全自动的内部的行为，用户无法控制或者配置，不过如果有必要可以关闭该功能。</p>
<p><strong>2.</strong>    <strong>创建自定义哈希索引</strong></p>
<p>思路：创建一个新列，保存哈希索引值。但与真正的哈希索引不同，因为还是用B-Tree进行查找，它使用的是哈希值而不是键本身进行索引查找。</p>
<p>例如存储url时，如果用B-Tree建立索引，会造成索引内容很大，例如：</p>
<p>select id from table where url &#x3D; ‘<a target="_blank" rel="noopener" href="http://www.baidu.com/%E2%80%99">http://www.baidu.com/’</a></p>
<p>这时可以删除原先url列上的索引，新增一个被索引的url_crc列，使用CRC32函数做哈希，如下：</p>
<p>select id from table where url_crc &#x3D; CRC32(‘<a target="_blank" rel="noopener" href="http://www.baidu.com/%E2%80%99">http://www.baidu.com/’</a>) and url &#x3D; ‘<a target="_blank" rel="noopener" href="http://www.baidu.com/%E2%80%99">http://www.baidu.com/’</a></p>
<p>MySQL优化器会使用这个选择性很高而体积很小的基于url_crc列的索引来完成查找。（相对于用完整的url字符串查询，速度提升非常大）</p>
<p>如果采用这种方式，不能使用SHA1()或者MD5()做哈希函数因为这两个函数产生的哈希值，虽然能够避免哈希冲突，但是是非常长的字符串，如果作为索引会类似uuid，浪费大量空间，也会比较慢。</p>
<p>为什么要包含and url &#x3D; ‘<a target="_blank" rel="noopener" href="http://www.baidu.com/%E2%80%99%E8%BF%99%E4%B8%AA%E6%9F%A5%E8%AF%A2%E6%9D%A1%E4%BB%B6%EF%BC%8C%E5%9B%A0%E4%B8%BA%E8%A6%81%E8%A7%A3%E5%86%B3%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%E3%80%82%E5%A6%82%E6%9E%9C%E4%B8%8D%E5%8C%85%E5%90%AB%E8%BF%99%E4%B8%AA%E6%9D%A1%E4%BB%B6%EF%BC%8C%E5%8F%AA%E7%94%A8url_crc%E6%9F%A5%E8%AF%A2%EF%BC%8C%E4%B8%80%E6%97%A6%E5%87%BA%E7%8E%B0%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%EF%BC%8C%E4%BC%9A%E9%80%A0%E6%88%90%E6%9F%A5%E8%AF%A2%E8%BF%94%E5%9B%9E%E5%A4%9A%E6%9D%A1%E8%AE%B0%E5%BD%95%E3%80%82">http://www.baidu.com/’这个查询条件，因为要解决哈希冲突。如果不包含这个条件，只用url_crc查询，一旦出现哈希冲突，会造成查询返回多条记录。</a></p>
<p>除了CRC32()之外，还可以使用FNV64()作为哈希函数（哈希值为64位，速度快，冲突要比CRC32少很多）。</p>
<h4 id="2-5-索引实现-二叉树与红黑树"><a href="#2-5-索引实现-二叉树与红黑树" class="headerlink" title="2.5.   索引实现-二叉树与红黑树"></a>2.5.   索引实现-二叉树与红黑树</h4><p>树形结构是最常见的数据结构之一。</p>
<p>树(Tree)：每个子节点有多棵子树。</p>
<p>二叉树（Binary Tree）：每个节点最多只有左右两棵子树。</p>
<p>二叉搜索树(Binary Search Tree)：每个节点左子树均小于根节点值，右子树均大于根节点值。</p>
<p>二叉平衡搜索树(AVL，发明者名字缩写)：自平衡，二叉搜索树，并且每个节点左右子树高度差不超过1。（查询速度很快，但是增删速度很慢）</p>
<p>红黑树(Red Black Tree)：自平衡，最高不超过最低高度的2倍即可。（对查找和增删的性能做了平衡）</p>
<p><strong>无论二叉树还是红黑树，都因为树的深度过高而搞成io变多，影响数据的读取的效率。</strong></p>
<p>B树(Balance Tree)：任何节点子树的高度差都小于1。多个分支的排序树，降低深度。</p>
<p><img src="/2022/02/09/MySQL%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93-3/2.png" alt="img"></p>
<p>提高速度的关键：减小I&#x2F;O次数；减少I&#x2F;O量。</p>
<h4 id="2-6-索引实现-B树"><a href="#2-6-索引实现-B树" class="headerlink" title="2.6.   索引实现-B树"></a>2.6.   索引实现-B树</h4><p>每个节点放置degree-1个数据，可以在每个节点保存一页的数据。</p>
<p>如下图所示：</p>
<p><img src="/2022/02/09/MySQL%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93-3/3.png" alt="img"></p>
<p>说明：</p>
<p>每个节点占用一个磁盘块，一个节点上有2个升序排序的关键字和3个指向子树根节点的指针，指针存储的是子节点所在磁盘块的地址。2个关键字划分成的三个范围域对应3个指针指向的子树的数据的范围域。以根节点为例，关键字为16和34，P1指针指向的子树的数据范围小于16。P2指针指向的子树的数据范围为16-34。P3指针指向的子树的数据范围大于34。</p>
<p>查找关键字的过程：</p>
<p>根据根节点找到磁盘块1。读入内存（磁盘I&#x2F;O操作1次）</p>
<p>比较关键字28在区间16-34，找到磁盘块1的指针P2。</p>
<p>根据P2指针找到磁盘块3，读入内存（磁盘I&#x2F;O操作2次）</p>
<p>一个磁盘块就是一个页。一个数据块是16k。</p>
<p>3层的B树可以存储多少数据？</p>
<p>假设一个data是1kb，那么一个磁盘块里可以放16个data也就是16条数据（假设剩余不占空间）。那3层就是16<em>16</em>16也就是4096条数据。</p>
<p>为什么3层B树只能存4000条数据？空间浪费在哪了—浪费在data了。</p>
<h4 id="2-7-索引实现-B-树"><a href="#2-7-索引实现-B-树" class="headerlink" title="2.7.   索引实现-B+树"></a>2.7.   索引实现-B+树</h4><p>非叶节点不存data。如下图所示：</p>
<p><img src="/2022/02/09/MySQL%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93-3/4.png" alt="img"></p>
<p>说明：在B+树上有2个头指针，一个指向根节点，另一个指向关键字最小的叶子节点。而且所有的叶子节点（即数据节点）之间是有一种链式的环结构。因此可以对B+树进行2种查找运算：一种是对于主键的范围查找和分页查找；另一种是从根节点开始，进行随机查找。</p>
<p>优化器自己决定是从根节点查找还是从叶子节点头查找。</p>
<p>数据在插入时就做好了排序。</p>
<p>假设一个指针+一个键值是10字节，那么一个数据库16k可以存储1600条数据。第二层也是1600。第三层是16。那么三层的数据量是1600<em>1600</em>16 &#x3D; 40960000条数据。</p>
<p>问题：MySQL里的B+树是几层（深度）。</p>
<p>3层或者4层取决于当前的数据量。</p>
<p>尽可能让16k存储更多的key值。用当前数据块的总大小（16k）除以key值的大小。得出每个块所存数据的多少。然后根据表里的数据量决定是3层还是4层。所以索引越小越好。</p>
<p>前缀索引：不拿字段的所有值当索引，而只拿前n个字符当做索引（left(column_name,3), column_name(3)）。</p>
<p>3层B+树可以支撑千万级别的数据量。具体数字需要看索引大小-&gt;阶。</p>
<h4 id="2-8-索引的优点"><a href="#2-8-索引的优点" class="headerlink" title="2.8.   索引的优点"></a>2.8.   索引的优点</h4><p>索引按照顺序存储数据，所以MySQL可以直接用索引进行ORDER BY和GROUP BY操作。同时因为索引是有序的， 所以该行相关的列值都会存储在一起。最后，因为索引中存储了实际的列值，查询只是用索引就能完成全部查询返回全部结果。</p>
<p>索引的三个优点：</p>
<p><strong>1.</strong>    索引大大减少了服务器需要扫描的数据量。</p>
<p><strong>2.</strong>    索引可以帮助服务器避免排序和临时表。</p>
<p><strong>3.</strong>    索引可以将随机I&#x2F;O变为顺序I&#x2F;O。</p>
<p>索引并不总是最好的解决方案。当索引帮助存储引擎快速查找到记录带来的好处大于其带来的额外工作时，索引才是有效的。对于非常小的表，大部分情况下简单地全表扫描更高效。对于中到大型表，索引就非常有效。对于特大型的表，建立和使用索引的代价会随之增长。</p>
<h3 id="3-高性能索引策略"><a href="#3-高性能索引策略" class="headerlink" title="3.  高性能索引策略"></a>3.  高性能索引策略</h3><p>对B-Tree索引来说，只有如下类型的匹配方式是有效的：</p>
<p>索引匹配方式：</p>
<p><strong>1.</strong>    全值匹配</p>
<p>和索引中的所有列进行匹配。</p>
<p>select * from table where name &#x3D; ? and age &#x3D; ? and pos &#x3D; ? </p>
<p><strong>2.</strong>    匹配最左前缀</p>
<p>只使用索引的前N列。</p>
<p>select * from table where name &#x3D; ?</p>
<p>select * from table where name &#x3D; ? and age &#x3D; ?</p>
<p><strong>3.</strong>    匹配列前缀</p>
<p>只使用某一列值的开头部分。</p>
<p>select * from table where name like ‘J%’</p>
<p><strong>4.</strong>    匹配范围值</p>
<p>索引第一列在某个范围之间。</p>
<p>select * from table where name &gt; ‘Mary’</p>
<p><strong>5.</strong>    精确匹配某一列并范围匹配另一列</p>
<p>第一列全匹配，第二列范围匹配。</p>
<p>select * from table where name &#x3D; ? and age &gt; ?</p>
<p>select * from table where name &#x3D; ? and age &gt; ? and pos &#x3D; ?</p>
<p><strong>6.</strong>    只访问索引的查询</p>
<p>索引覆盖。只用索引值就可以返回查询结果。</p>
<p>select name,age,pos from table where name &#x3D; ? and age &#x3D; ? and pos &#x3D; ?</p>
<p>注意：</p>
<p><strong>1.</strong>    如果不是按照索引的最左列开始查找，那么无法使用索引。</p>
<p>select * from table where pos &#x3D; ?</p>
<p>select * from table where age&#x3D; ?</p>
<p>select * from table where name like ‘%J’</p>
<p><strong>2.</strong>    不能跳过索引中的列。</p>
<p>select * from table where name &#x3D; ? and pos &#x3D; ?</p>
<p>只能使用name作为索引进行查询。</p>
<p><strong>3.</strong>    如果查询中使用了某个列的范围查询，则其右面的所有列都无法使用索引优化查找。</p>
<p>select * from table where name &#x3D; ? and age &gt; ? and pos &#x3D; ?</p>
<p>只能使用name和age做索引进行查询。</p>
<h4 id="3-1-独立的列"><a href="#3-1-独立的列" class="headerlink" title="3.1.   独立的列"></a>3.1.   独立的列</h4><p>独立的列指的是索引列不能是表达式的一部分，也不能是函数的参数。如果查询中的列不是独立的，MySQL不会使用索引。</p>
<p>select * from table where name + 1 &#x3D; 30</p>
<p>select * from table where TO_DAYS(CURRENT_DATE) – TO_DAYS(date_col) &gt; 10</p>
<h4 id="3-2-索引选择性和前缀索引"><a href="#3-2-索引选择性和前缀索引" class="headerlink" title="3.2.   索引选择性和前缀索引"></a>3.2.   索引选择性和前缀索引</h4><p>索引选择性是指：不重复的索引值（也称为基数）和数据表的记录总数（#T）的比值，范围从1&#x2F;#T到1之间。索引的选择性越高则查询效率越高，因为选择性高的索引可以让MySQL在查找时过滤掉更多的行。唯一索引的选择性是1，性能是最好的。</p>
<p>前缀索引指的是当索引列字符数很多时，会让索引变得大而且慢，所以可以只将开始的部分字符作为索引，这样可以节约索引空间，提高索引效率。但是会降低索引选择性。</p>
<p>关键在于选择足够长的前缀保证较高的选择性，同时又不能太长（以便节约空间）。前缀的基数应该接近于完整列的基数。</p>
<p>前缀索引是一种能使索引更小、更快的有效办法，但另一方面也有缺点：MySQL无法使用前缀索引做ORDER BY和GROUP BY， 也无法使用前缀索引做覆盖扫描。</p>
<p>有时候后缀索引也有用途，例如找到某个域名的所有电子邮件地址。MySQL原生并不支持反向索引，但是可以将字符串翻转后存储，并基于此建立前缀索引。</p>
<h4 id="3-3-多列索引"><a href="#3-3-多列索引" class="headerlink" title="3.3.   多列索引"></a>3.3.   多列索引</h4><p>关于多列索引常见的错误是：为每个列创建独立的索引，或者按照错误的顺序创建多列索引。</p>
<p>在多个列上建立独立的单列索引大部分情况下并不能提高MySQL的查询性能。</p>
<p>在5.0版本之后的MySQL，如果同时有2个列查询（在此两列上各有一个索引），查询能够同时使用这两个单列索引进行扫描，并将结果进行合并，叫做索引合并策略。</p>
<p>索引合并策略是一种优化的结果，但实际上说明了这个表上的索引建立的比较糟糕。</p>
<p><strong>1.</strong>    当出现服务器对多个索引做相交操作时（通常有多个and条件），通常意味着需要一个包含所有相关列的多列索引，而不是多个独立的单列索引。</p>
<p><strong>2.</strong>    当服务器需要对多个索引做联合操作时（通常有多个or条件），通常需要耗费大量CPU和内存资源在算法的缓存、排序和合并操作上，特别是当其中有些索引的选择性不高，需要合并扫描返回的大量数据的时候。</p>
<p><strong>3.</strong>    优化器不会把这些计算到查询成本中，优化器只关心随机页面读取。这会使得查询的成本被“低估”，导致该执行计划还不如直接走全表扫描。</p>
<h4 id="3-4-选择合适的索引列顺序"><a href="#3-4-选择合适的索引列顺序" class="headerlink" title="3.4.   选择合适的索引列顺序"></a>3.4.   选择合适的索引列顺序</h4><p>最常用的经验：将选择性最高的列放到索引的最前列。</p>
<p>如果有具体的多条件查询，可以用不同条件分别进行查询，将对应条件的结果数量最小的列放在最前。</p>
<p>如果查询语句性能很慢，而不同条件查询出的数量都很多，那么应该从程序角度来尝试修改或取消这种业务的查询。</p>
<h4 id="3-5-聚簇索引"><a href="#3-5-聚簇索引" class="headerlink" title="3.5.   聚簇索引"></a>3.5.   聚簇索引</h4><p>聚簇索引并不是单独的一种索引类型，而是一种数据存储方式。也就是说数据跟索引是不是放在一起。 对InnoDB的主键索引来说，是聚簇索引。对MyISAM来说，是非聚簇索引。</p>
<p>MyISAM和InnoDB都是采用的B+树，但是有区别：</p>
<p><strong>1.</strong>    MyISAM中，叶子节点存储该行数据的存储地址。</p>
<p><strong>2.</strong>    InnoDB中，叶子节点直接放该行全部数据</p>
<p><strong>1)</strong>   InnoDB通过B+树结构对主键创建索引，在叶子节点中存储记录。如果没有主键，那么选择唯一键。如果没有唯一键，那么会生成一个6字节的row_id作为主键。</p>
<p><strong>2)</strong>   如果创建索引的键是其他字段，那么叶子节点中存储的是该记录的主键，然后再通过主键索引找到对应的记录，这叫做回表。</p>
<p>聚簇索引的优点：</p>
<p><strong>1.</strong>    可以把相关的数据保存到一起。</p>
<p><strong>2.</strong>    数据访问更快。</p>
<p>缺点：</p>
<p><strong>1.</strong>    最大限度的提高了I&#x2F;O密集型应用的性能，但如果全部数据都在内存中，那么访问顺序就不重要了，聚簇索引也就没什么优势了。</p>
<p><strong>2.</strong>    插入速度严重依赖于插入顺序。按照逐渐顺序插入时加载数据到InnoDB表中速度最快的方式。</p>
<p><strong>3.</strong>    更新聚簇索引列的代价很高，因为会强制InnoDB将每个被更新的行移动到新的位置。</p>
<p><strong>4.</strong>    基于聚簇索引的表在插入新行，或者主键被更新导致需要移动行的时候，可能面临页分裂的问题。</p>
<p><strong>5.</strong>    聚簇索引可能导致全表扫描变慢，尤其是行比较稀疏或者由于页分裂导致数据存储不连续的时候。</p>
<p><strong>6.</strong>    二级索引（非聚簇索引）会比想象中大，因为在二级索引的叶子节点包含了引用行的主键列。</p>
<p><strong>7.</strong>    二级索引访问需要两次索引查找，而不是一次。</p>
<p>每增加一个索引就是一棵树。InnoDB主键索引树中叶子节点存的是该行全部数据，二级索引树中叶子节点存储的是主键值。这意味着如果通过二级索引查找行，存储引擎需要找到二级索引的叶子节点获得对应的主键值，然后根据这个值去聚簇索引中查找到对应的行。即：两次B-Tree查找，也即回表。</p>
<p>对自增主键来说，插入时要做的操作会少很多（页分裂，页合并），查询也会简单。</p>
<p>例如一个表（col1是主键，col2列上有B-Tree索引）：</p>
<table>
<thead>
<tr>
<th>行号</th>
<th>col1</th>
<th>col2</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>99</td>
<td>8</td>
</tr>
<tr>
<td>1</td>
<td>12</td>
<td>56</td>
</tr>
<tr>
<td>2</td>
<td>3000</td>
<td>62</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>9997</td>
<td>18</td>
<td>8</td>
</tr>
<tr>
<td>9998</td>
<td>4700</td>
<td>13</td>
</tr>
<tr>
<td>9999</td>
<td>3</td>
<td>93</td>
</tr>
</tbody></table>
<p><strong>MyISAM****的数据分布</strong>：MyISAM按照数据插入的顺序存储在磁盘上。主键索引如下图所示：</p>
<p><img src="/2022/02/09/MySQL%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93-3/5.png" alt="img"></p>
<p>col2列索引如下图所示：</p>
<p><img src="/2022/02/09/MySQL%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93-3/6.png" alt="img"></p>
<p>可以看出，MyISAM引擎主键索引和其他索引在结构上并没有区别。主键索引就是一个名为PRIMARY的唯一非空索引。</p>
<p><strong>InnoDB****的数据分布</strong>：InnoDB的主键索引（聚簇索引）如下图所示：</p>
<p><img src="/2022/02/09/MySQL%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93-3/7.png" alt="img"></p>
<p>二级索引col2列索引如下图所示：</p>
<p><img src="/2022/02/09/MySQL%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93-3/8.png" alt="img"></p>
<p><strong>在InnoDB表中按照主键顺序插入行</strong></p>
<p>在InnoDB的表中的主键，最好与应用无关(代理主键而非自然主键)，例如自增列，保证数据行是按顺序写入，同时做关联操作的性能会更好。最坏的情况是I&#x2F;O密集型应用中的UUID主键，他会使得聚簇索引的插入完全变得随机。</p>
<table>
<thead>
<tr>
<th>表名</th>
<th>行数</th>
<th>时间（秒）</th>
<th>索引大小（MB）</th>
</tr>
</thead>
<tbody><tr>
<td>userinfo</td>
<td>100w</td>
<td>137</td>
<td>342</td>
</tr>
<tr>
<td>userinfo_uuid</td>
<td>100w</td>
<td>180</td>
<td>544</td>
</tr>
<tr>
<td>userinfo</td>
<td>300w</td>
<td>1233</td>
<td>1036</td>
</tr>
<tr>
<td>userinfo_uuid</td>
<td>300w</td>
<td>4525</td>
<td>1707</td>
</tr>
</tbody></table>
<p>在300w数据量时，uuid主键表的插入顺序变为自增id主键表插入顺序的3倍，索引大小变为1.5倍。</p>
<p>一方面是因为主键字段更长，另一方面是因为页分裂和碎片导致的。</p>
<p><img src="/2022/02/09/MySQL%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93-3/9.png" alt="img"></p>
<p>因为主键值是顺序的，所以InnoDB把每一条记录存储在上一条记录的后面。当达到页的最大填充因子（InnoDB默认最大填充因子是页大小的15&#x2F;16，留出部分空间用于以后修改），下一条记录会写入新的页中。一旦数据按照这种顺序方式加载，主键页就会近似于被顺序的记录填满。这也正是预期的结果。</p>
<p><img src="/2022/02/09/MySQL%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93-3/10.png" alt="img"></p>
<p>因为新行的键值不一定比之前键值大，所以InnoDB会为他寻找合适的位置，通常是已有数据的中间位置，并且为他分配空间。这会增加很多额外的工作，并且导致分布不够优化。如下：</p>
<p><strong>1.</strong>   写入目标页可能已经刷新到硬盘并且从缓存中移除，或是还没被加载到缓存中。InnoDB在插入之前不得不先从磁盘读取目标页加载到内存中，这会导致大量的随机I&#x2F;O。</p>
<p><strong>2.</strong>   因为写入是乱序的，InnoDB不得不做频繁的页分裂操作，以便为新行分配空间。页分裂会导致移动大量数据，一次插入最少需要修改三个页而不是一个页。</p>
<p><strong>3.</strong>   由于频繁的页分裂，页会变的稀疏并被不规则的填充，所以最终数据会有碎片。</p>
<p><strong>4.</strong>   在将随机值插入到聚簇索引之后，也许需要做一次OPTIMIZE TABLE来优化页的填充。</p>
<p>所以，使用InnoDB应尽可能地按照主键顺序插入数据，并尽可能的使用单调增加的主键值插入新行。</p>
<h4 id="3-6-覆盖索引"><a href="#3-6-覆盖索引" class="headerlink" title="3.6.   覆盖索引"></a>3.6.   覆盖索引</h4><p>如果一个索引包含（或者说覆盖）所有需要查询的字段的值，那么称为覆盖索引。</p>
<p>索引覆盖可以极大地提升性能：</p>
<p><strong>1.</strong>    索引条目通常远小于数据行大小，所以如果只读取索引，会极大地减少访问量。将花在数据拷贝上的时间大大减少，同时数据也会更容易的放入内存中。</p>
<p><strong>2.</strong>    因为索引时按照列值顺序存储，所有对于I&#x2F;O密集型的范围查询会比随机从磁盘读取每一行数据的I&#x2F;O要少得多。</p>
<p><strong>3.</strong>    一些存储引擎例如MyISAM在内存中只缓存索引，数据依赖于操作系统缓存，所以每次访问数据都需要一次系统调用，这可能导致严重的性能问题。</p>
<p><strong>4.</strong>    由于InnoDB的聚簇索引，如果二级索引能够覆盖查询，可以避免对主键索引的二次查询。</p>
<p>但并不是说所有的索引都能实现覆盖索引，例如哈希索引、空间索引、全文索引等等，因为都不存储索引列的值，所以在MySQL当中，只能使用B-Tree索引做覆盖索引。</p>
<p>EXPLAIN解析结果可以看出Extra的值为Using index，表示已经使用了索引覆盖。</p>
<h4 id="3-7-索引下推"><a href="#3-7-索引下推" class="headerlink" title="3.7.   索引下推"></a>3.7.   索引下推</h4><p>索引下推（index condition pushdown ）又叫索引条件推送，简称ICP，在MySQL5.6的版本上推出，用于优化查询。</p>
<p>在不使用ICP的情况下，在使用非主键索引进行查询时，存储引擎通过索引检索到数据，然后返回给MySQL服务器，服务器然后判断数据是否符合条件 。</p>
<p>在使用ICP的情况下，如果存在某些被索引的列的判断条件时，MySQL服务器将这一部分判断条件传递给存储引擎，然后由存储引擎通过判断索引是否符合MySQL服务器传递的条件，只有当索引符合条件时才会将数据检索出来返回给MySQL服务器 。</p>
<p>假如查询中有3个条件，当查询的时候，先将符合条件1的结果取出，放到MySQL服务器，再进行条件2和条件3的筛选。这是未进行索引下推。</p>
<p>假如在查询的时候，一次性将符合条件123的结果全部取出，放到MySQL服务层。这就叫索引下推。</p>
<p>索引条件下推优化可以减少回表次数，也可以减少MySQL服务器从存储引擎接收数据的次数。</p>
<p>假设一张用户表(user)，其中主要几个字段有：id、name、age、pos。有联合索引（name，age）。</p>
<p><strong>第一种情况：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;陈%&#x27;</span></span><br></pre></td></tr></table></figure>

<p>根据 “最佳左前缀” 的原则，这里使用了联合索引（name，age）进行了查询，性能要比全表扫描肯定要高。</p>
<p><strong>第二种情况：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;陈xx&#x27;</span> <span class="keyword">and</span> age<span class="operator">=</span><span class="number">20</span></span><br></pre></td></tr></table></figure>

<p><strong>1.</strong>    在MySQL 5.6之前版本，会忽略age这个字段，直接通过name进行查询，在(name,age)这课树上查找到了两个结果，id分别为2,1，然后拿着取到的id值一次次的回表查询，因此这个过程需要回表两次。</p>
<p><strong>2.</strong>    在MySQL 5.6之后版本，InnoDB并没有忽略age这个字段，而是在索引内部就判断了age是否等于20，对于不等于20的记录直接跳过，因此在(name,age)这棵索引树中只匹配到了一个记录，此时拿着这个id去主键索引树中回表查询全部数据，这个过程只需要回表一次。</p>
<p>EXPLAIN解析结果可以看出Extra的值为Using index condition，表示已经使用了索引下推。</p>
<p>索引下推唯一的缺点是需要在磁盘上多做数据筛选，原先的筛选是放在内存中的，现在放在了磁盘中进行查找数据的环节，这样做看起来成本高了，但是数据是排序的，所有的数据是聚集存放，所以性能不会有影响，而且整体的I&#x2F;O量大大减少了，性能反而提升了</p>
<h4 id="3-8-使用索引扫描排序"><a href="#3-8-使用索引扫描排序" class="headerlink" title="3.8.   使用索引扫描排序"></a>3.8.   使用索引扫描排序</h4><p>MySQL有两种方式生成有序的结果：通过排序操作；按照索引顺序扫描。如果EXPLAIN的结果type列为index（Extra没有出现Using filesort），标识MySQL使用了索引扫描进行排序。</p>
<p>扫描索引本身很快，如果MySQL可以使用同一个索引既满足排序，又用于查找查找行，这样是最好的。</p>
<p>只有当索引的列顺序和ORDER BY子句的顺序完全一致，并且所有列的排序方向（正序或倒序）都一样时，MySQL才可以使用索引对结果进行排序。如果查询需要关联多张表，则只有当ORDER BY子句引用的字段全部为第一个表时，才能使用索引做排序。ORDER BY子句需要满足索引的最左前缀要求，否则MySQL无法用索引排序。</p>
<p>有一种特殊情况ORDER BY子句可以不满足索引的最左前缀要求，就是前导列为常量的时候。</p>
<p>例如：</p>
<p>假设一张用户表(user)，其中主要几个字段有：id、name、age、pos、remark。有联合索引（age,name,pos）。</p>
<p><strong>1.</strong>    SELECT id FROM user where age &#x3D; 20 ORDER BY name, pos</p>
<p>即使ORDER BY子句并不满足索引的最左前缀要求，也可以用于查询排序，这是因为索引的第一列被指定为一个常数。</p>
<p><strong>2.</strong>    SELECT id FROM user where age &#x3D; 20 ORDER BY name</p>
<p>第一列是常量，用第二列排序，相当于索引的最左前缀。</p>
<p><strong>3.</strong>    SELECT id FROM user where age &gt; 20 ORDER BY age,name</p>
<p>使用的ORDER BY两列就是索引的最左前缀。</p>
<p>下面几种情况是不能用索引做排序的查询：</p>
<p><strong>1.</strong>    … WHERE age &#x3D; 20 ORDER BY name DESC, pos ASC</p>
<p>两种不同的排序方向。</p>
<p><strong>2.</strong>    … WHERE age &#x3D; 20 ORDER BY name, remark</p>
<p>引用了不在索引中的列。</p>
<p><strong>3.</strong>    … WHERE age &#x3D; 20 ORDER BY pos</p>
<p>WHERE和ORDER BY中的子句无法组成索引的最左前缀</p>
<p><strong>4.</strong>    … WHERE age &gt; 20 ORDER BY name, pos</p>
<p>索引上的第一列是范围条件。</p>
<p><strong>5.</strong>    … WHERE age &#x3D; 20 AND name IN (‘A’,’B’) ORDER BY pos</p>
<p>name列上有多个等于条件，也是一种范围查询。</p>
<h4 id="3-9-压缩索引（前缀压缩）"><a href="#3-9-压缩索引（前缀压缩）" class="headerlink" title="3.9.   压缩索引（前缀压缩）"></a>3.9.   压缩索引（前缀压缩）</h4><p>MyISAM使用前缀压缩来减少索引的大小，从而让更多的索引可以放到内存中，这在某些情况下可以极大地提升性能。</p>
<p>MyISM压缩每个索引块的方法是：先完全保存索引块中的第一个值，然后将其他值和第一个值进行比较得到相同的前缀字节数和不同的后缀部分，存储即可。例如，所以块的第一个值是config,第二个值是configuration,那么第二个值压缩之后存储的值类似6,uration。</p>
<p>压缩块节省了空间，代价是某些操作可能会慢。因为每个值的压缩前缀都依赖于前面的值，所以MyISAM查找时无法在索引块使用二分查找只能从头开始扫描。在块中查找某一行的操作平均都需要扫描半个索引块。</p>
<h4 id="3-10-冗余和重复索引"><a href="#3-10-冗余和重复索引" class="headerlink" title="3.10.  冗余和重复索引"></a>3.10.  冗余和重复索引</h4><p>重复索引指的是在相同的列上按照相同的顺序创建相同类型的索引。应当避免这样创建重复索引，发现后也应该立即移除。</p>
<p>冗余索引与重复索引有所不同，例如：</p>
<p><strong>1.</strong>    如果创建了索引（A,B），再创建索引(A)就是冗余索引，因为这是索引(A,B)的前缀索引，索引（A,B）也可以当做索引（A）使用。</p>
<p><strong>2.</strong>    创建索引（A,ID），ID是主键。对于InnoDB来说主键列已经包含在二级索引中了，所以这也是冗余的。</p>
<h3 id="4-EXPLAIN"><a href="#4-EXPLAIN" class="headerlink" title="4.  EXPLAIN"></a>4.  EXPLAIN</h3><p>基于表的设计、列、索引、还有查询语句中的where条件，MySQL优化器会使用很多技术来更好地执行查询。查询最终会变成一堆操作的集合，这个集合是MySQL优化器选择的最有效的执行这个查询的操作集合，也就是执行计划（query execution plan， 也叫作EXPLAIN plan）。</p>
<p>EXPLAIN返回的结果是MySQL执行语句的信息，EXPLAIN可以应用于SELECT, UPDATE, DELETE, INSERT, REPLACE。</p>
<p>EXPLAIN给每一个SELECT语句中的表，按照MySQL执行语句时的顺序，都返回了一行信息，用以表示执行计划的信息。（多表join时，mysql的查询方式）</p>
<p>EXPLAIN的输出格式</p>
<p><img src="/2022/02/09/MySQL%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93-3/11.png" alt="img"></p>
<p>关于各字段含义：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>主键</td>
</tr>
<tr>
<td>select_type</td>
<td>查询类型</td>
</tr>
<tr>
<td>table</td>
<td>表名，每个表一条数据</td>
</tr>
<tr>
<td>partitions</td>
<td>匹配的分区</td>
</tr>
<tr>
<td><strong>type</strong></td>
<td><strong>关键字段：查询类型</strong></td>
</tr>
<tr>
<td>possible_keys</td>
<td>可能选择的索引</td>
</tr>
<tr>
<td><strong>key</strong></td>
<td><strong>关键字段：实际选择的索引</strong></td>
</tr>
<tr>
<td>key_len</td>
<td>选择索引的长度</td>
</tr>
<tr>
<td>ref</td>
<td>索引对应的列</td>
</tr>
<tr>
<td>rows</td>
<td>预估的行数</td>
</tr>
<tr>
<td>filtered</td>
<td>查询扫描行数的百分比</td>
</tr>
<tr>
<td><strong>Extra</strong></td>
<td><strong>关键字段：额外信息</strong></td>
</tr>
</tbody></table>
<h4 id="4-1-type"><a href="#4-1-type" class="headerlink" title="4.1.    type"></a>4.1.    type</h4><p>type列标识查询的类型，效果从最好到最坏依次是：</p>
<p><strong>1)</strong>   <strong>system</strong></p>
<p>表只有一行（系统表）。一个const类型的特例。</p>
<p><strong>2)</strong>   <strong>const</strong></p>
<p>表只有一行匹配，这一行会在查询开始的时候就被读取。非常快。</p>
<p>在用主键索引或唯一索引查询时，type列为const。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>3)</strong>   <strong>eq_ref</strong></p>
<p>只返回一行。使用主键或唯一索引时，才会有eq_ref。</p>
<p><strong>4)</strong>   <strong>ref</strong></p>
<p>索引访问，返回所有匹配某个单个值的行。</p>
<p><strong>5)</strong>   <strong>fulltext</strong></p>
<p>全文索引。</p>
<p><strong>6)</strong>   <strong>ref or null</strong></p>
<p>跟ref类似，但是包含NULL值判断。</p>
<p><strong>7)</strong>   <strong>index merge</strong></p>
<p>索引合并。索引合并优化策略启用时出现，此时key列中会显示使用的索引列表。</p>
<p><strong>8)</strong>   <strong>unique subquery</strong></p>
<p>在一些in子查询中替代eq_ref。</p>
<p><strong>9)</strong>   <strong>index subquery</strong></p>
<p>与unique subquery类似，在in子查询中，使用非唯一索引时出现。</p>
<p><strong>10)</strong>  <strong>range</strong></p>
<p>在索引确定的范围内返回行。key列标识用到哪个索引，ref列为NULL。</p>
<p>当使用比较符&#x3D;, &lt;&gt;, &gt;, &gt;&#x3D;, &lt;, &lt;&#x3D;, IS NULL, &lt;&#x3D;&gt;, BETWEEN, LIKE, 或者 IN() 函数时，会出现range。</p>
<p><strong>11)</strong>  <strong>index</strong></p>
<p>跟ALL形式一样，全表扫描。但是会按照索引次序。有两种情况：</p>
<p>a.   覆盖索引。此时Extra列会显示Using index</p>
<p>b.   通过查询索引列进行全表扫描。</p>
<p><strong>12)</strong>  <strong>ALL</strong></p>
<p>全表扫描。</p>
<h4 id="4-2-Extra"><a href="#4-2-Extra" class="headerlink" title="4.2.    Extra"></a>4.2.    Extra</h4><p>一些额外信息，但很重要。</p>
<p><strong>1)</strong>   <strong>Using index</strong></p>
<p>索引覆盖。</p>
<p><strong>2)</strong>   <strong>Using index condition</strong></p>
<p>索引下推。</p>
<p><strong>3)</strong>   <strong>Using filesort</strong></p>
<p>排序时没有使用到索引，而是使用内存排序或磁盘排序（统称为文件排序，filesort）。</p>
<p><strong>4)</strong>   <strong>Using temporary</strong> </p>
<p>查询中使用了中间表存储临时结果。</p>
<p><strong>5)</strong>   <strong>Using where</strong></p>
<p>存储引擎检索过行之后，服务器层进行过滤。如果type是index或者All，Extra没有Using where，通常会有问题。</p>
<p><strong>6)</strong>   <strong>Using MRR</strong></p>
<p>MRR（Multi Range Read），将随机I&#x2F;O变为顺序I&#x2F;O。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> name <span class="operator">=</span> ?</span><br></pre></td></tr></table></figure>

<p>结果是1000行，在二级索引树取出1000个id后，在主键树中一个一个的进行查找，速度会比较慢。</p>
<p>MRR:取出1000个id后，在内存中进行排序，然后在主键树中做顺序查找。</p>
<h3 id="5-实验"><a href="#5-实验" class="headerlink" title="5.  实验"></a>5.  实验</h3><p>建立组合索引abc，不同sql语句使用索引情况</p>
<table>
<thead>
<tr>
<th>语句</th>
<th>是否使用索引</th>
<th>索引使用情况</th>
</tr>
</thead>
<tbody><tr>
<td>where a &#x3D; 3</td>
<td>是</td>
<td>只使用a</td>
</tr>
<tr>
<td>where a &#x3D; 3 and b &#x3D; 5</td>
<td>是</td>
<td>使用a,b</td>
</tr>
<tr>
<td>where b &#x3D; 3 and a &#x3D; 5</td>
<td>是</td>
<td>使用a,b</td>
</tr>
<tr>
<td>where a &#x3D; 3 and b &#x3D; 5 and c &#x3D; 4</td>
<td>是</td>
<td>使用a,b,c</td>
</tr>
<tr>
<td>where b &#x3D; 3 or c &#x3D; 4</td>
<td>？</td>
<td>-</td>
</tr>
<tr>
<td>where a &#x3D; 3 and c &#x3D; 4</td>
<td>是</td>
<td>只使用a</td>
</tr>
<tr>
<td>where a &#x3D; 3 and b &gt; 10 and c  &#x3D; 7</td>
<td>？</td>
<td>使用a,b</td>
</tr>
<tr>
<td>where a &#x3D; 3 and b like ‘%xx%’  and c &#x3D; 4</td>
<td>是</td>
<td>只使用a</td>
</tr>
</tbody></table>
<p>疑问：</p>
<p><strong>1.</strong>   where b&#x3D;3 or c&#x3D;4时 是否使用索引。</p>
<p><strong>2.</strong>   where a &#x3D; 3 and b &gt; 10 and c &#x3D; 7 使用索引中的几列。</p>
<p>回答：具体情况具体分析。</p>
<p>如果一个表的所有列都做了组合索引，那么不管怎么查数据，都会用到组合索引。</p>
<p>如果加了多余的一列之后，那么就不会用到索引了。</p>
<p>一些意见：</p>
<p><strong>1.</strong>   当使用索引列进行查询时尽量不要使用表达式，把计算放到业务层也不是数据库层。</p>
<p><strong>2.</strong>   尽量使用主键查询，而不是其他索引，因为主键查询不会触发回表。</p>
<p><strong>3.</strong>   使用前缀索引</p>
<p><strong>4.</strong>   使用索引扫描来排序</p>
<p><strong>5.</strong>   union all，in，or都会使用索引，但是推荐使用in</p>
<p><strong>6.</strong>   范围列可以使用索引（&gt;,&gt;&#x3D;,&lt;,&lt;&#x3D;,between）但范围列后面的列无法用到索引，索引最多用于一个范围列</p>
<p><strong>7.</strong>   强制类型转换会全表扫描</p>
<p>phone是varchar型</p>
<p>隐式类型转换也会使得索引无效</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> phone <span class="operator">=</span> <span class="number">13000000000</span>; <span class="comment">-- 不会触发索引</span></span><br><span class="line"></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> phone <span class="operator">=</span> <span class="string">&#x27;13000000000&#x27;</span> <span class="comment">-- 会触发索引</span></span><br></pre></td></tr></table></figure>

<p><strong>8.</strong>   更新频繁的，数据区分度不高的字段上不宜建立索引</p>
<p>a.   更新会变更b+树，更新频繁的字段建立索引会大大降低数据库性能。</p>
<p>b.   类似于性别之类的字段，建立索引没有意义。</p>
<p>c.   一般区分度在80%以上的时候可以建立索引，区分度用count(distinct(column_name))&#x2F;count(*)计算。   </p>
<p><strong>9.</strong>   创建索引的列，不允许为null，因为可能会得到不符合预期的结果。</p>
<p><strong>10.</strong>  当需要进行表连接的时候，最好不要超过3张表，因为需要join的字段，数据类型必须一致。</p>
<p><strong>11.</strong>  能使用limit的时候尽量使用limit。</p>
<p><strong>12.</strong>  单表索引尽可能控制在5个以内。（但是现在没有太多的限制了）</p>
<p><strong>13.</strong>  单索引字段数不允许超过5个（组合索引）</p>
<p><strong>14.</strong>  创建索引的时候应该避免以下概念：索引越多越好；过早优化或者在不了解系统时进行优化。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">郭超</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
