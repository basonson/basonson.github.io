<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.0.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://unpkg.com/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://unpkg.com/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"basonson.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.10.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="https://unpkg.com/hexo-theme-next@8.10.0/source/js/config.js"></script>

  <meta name="description" content="1.  简单动态字符串Redis虽然是基于C语言，但并没有使用C语言中的字符串。而是构建了一个名为简单动态字符串（Simple Dynamic String, SDS）的类型，并将SDS作为Redis默认的字符串表示。 在Redis中，有一种情况会使用C语言的字符串，就是常量字符串。除此之外，都会使用SDS来表示字符串值。同时，SDS还会被用作缓冲区：AOF中的缓冲区，以及客户端状态中的输入缓冲区">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis技术总结2-数据结构">
<meta property="og:url" content="https://basonson.github.io/2022/02/14/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%932-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/index.html">
<meta property="og:site_name" content="大牙技术">
<meta property="og:description" content="1.  简单动态字符串Redis虽然是基于C语言，但并没有使用C语言中的字符串。而是构建了一个名为简单动态字符串（Simple Dynamic String, SDS）的类型，并将SDS作为Redis默认的字符串表示。 在Redis中，有一种情况会使用C语言的字符串，就是常量字符串。除此之外，都会使用SDS来表示字符串值。同时，SDS还会被用作缓冲区：AOF中的缓冲区，以及客户端状态中的输入缓冲区">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://basonson.github.io/2022/02/14/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%932-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1.png">
<meta property="og:image" content="https://basonson.github.io/2022/02/14/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%932-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/2.png">
<meta property="og:image" content="https://basonson.github.io/2022/02/14/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%932-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.png">
<meta property="og:image" content="https://basonson.github.io/2022/02/14/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%932-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/4.png">
<meta property="og:image" content="https://basonson.github.io/2022/02/14/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%932-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5.png">
<meta property="og:image" content="https://basonson.github.io/2022/02/14/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%932-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/6.png">
<meta property="og:image" content="https://basonson.github.io/2022/02/14/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%932-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/7.png">
<meta property="og:image" content="https://basonson.github.io/2022/02/14/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%932-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/8.png">
<meta property="og:image" content="https://basonson.github.io/2022/02/14/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%932-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/9.png">
<meta property="og:image" content="https://basonson.github.io/2022/02/14/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%932-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/10.png">
<meta property="og:image" content="https://basonson.github.io/2022/02/14/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%932-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/11.png">
<meta property="og:image" content="https://basonson.github.io/2022/02/14/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%932-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/12.png">
<meta property="og:image" content="https://basonson.github.io/2022/02/14/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%932-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/13.png">
<meta property="og:image" content="https://basonson.github.io/2022/02/14/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%932-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/14.png">
<meta property="og:image" content="https://basonson.github.io/2022/02/14/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%932-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/15.png">
<meta property="article:published_time" content="2022-02-14T06:15:56.000Z">
<meta property="article:modified_time" content="2022-02-14T07:59:52.176Z">
<meta property="article:author" content="郭超">
<meta property="article:tag" content="数据结构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://basonson.github.io/2022/02/14/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%932-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1.png">


<link rel="canonical" href="https://basonson.github.io/2022/02/14/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%932-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://basonson.github.io/2022/02/14/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%932-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","path":"2022/02/14/Redis技术总结2-数据结构/","title":"Redis技术总结2-数据结构"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Redis技术总结2-数据结构 | 大牙技术</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">大牙技术</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Chaos Guo's Personal WebSite</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">1.</span> <span class="nav-text">1.  简单动态字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-SDS%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">1.1.</span> <span class="nav-text">1.1  SDS的定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-SDS%E4%B8%8EC%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.2.</span> <span class="nav-text">1.2  SDS与C字符串的区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E9%93%BE%E8%A1%A8"><span class="nav-number">2.</span> <span class="nav-text">2.  链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%AD%97%E5%85%B8"><span class="nav-number">3.</span> <span class="nav-text">3.  字典</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-%E5%93%88%E5%B8%8C%E8%A1%A8%E8%8A%82%E7%82%B9"><span class="nav-number">3.1.</span> <span class="nav-text">3.1  哈希表节点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="nav-number">3.2.</span> <span class="nav-text">3.2  哈希表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-%E5%AD%97%E5%85%B8"><span class="nav-number">3.3.</span> <span class="nav-text">3.3  字典</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95"><span class="nav-number">3.4.</span> <span class="nav-text">3.4  哈希算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81"><span class="nav-number">3.5.</span> <span class="nav-text">3.5  哈希冲突</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-6-rehash"><span class="nav-number">3.6.</span> <span class="nav-text">3.6  rehash</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-7-rehash%E7%9A%84%E6%9D%A1%E4%BB%B6"><span class="nav-number">3.7.</span> <span class="nav-text">3.7  rehash的条件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-8-%E6%B8%90%E8%BF%9B%E5%BC%8Frehash"><span class="nav-number">3.8.</span> <span class="nav-text">3.8  渐进式rehash</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E8%B7%B3%E8%B7%83%E8%A1%A8"><span class="nav-number">4.</span> <span class="nav-text">4.  跳跃表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88"><span class="nav-number">5.</span> <span class="nav-text">5.  整数集合</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-%E5%8D%87%E7%BA%A7"><span class="nav-number">5.1.</span> <span class="nav-text">5.1  升级</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-%E5%8D%87%E7%BA%A7%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="nav-number">5.2.</span> <span class="nav-text">5.2  升级的好处</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-%E9%99%8D%E7%BA%A7"><span class="nav-number">5.3.</span> <span class="nav-text">5.3  降级</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8"><span class="nav-number">6.</span> <span class="nav-text">6.  压缩列表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1-%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E7%9A%84%E6%9E%84%E6%88%90"><span class="nav-number">6.1.</span> <span class="nav-text">6.1  压缩列表的构成</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E8%8A%82%E7%82%B9"><span class="nav-number">6.2.</span> <span class="nav-text">6.2  压缩列表节点</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="郭超"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">郭超</p>
  <div class="site-description" itemprop="description">学习,分享,进步</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">13</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">27</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://basonson.github.io/2022/02/14/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%932-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="郭超">
      <meta itemprop="description" content="学习,分享,进步">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大牙技术">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Redis技术总结2-数据结构
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-02-14 14:15:56 / Modified: 15:59:52" itemprop="dateCreated datePublished" datetime="2022-02-14T14:15:56+08:00">2022-02-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/NoSQL/" itemprop="url" rel="index"><span itemprop="name">NoSQL</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/NoSQL/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h3 id="1-简单动态字符串"><a href="#1-简单动态字符串" class="headerlink" title="1.  简单动态字符串"></a>1.  简单动态字符串</h3><p>Redis虽然是基于C语言，但并没有使用C语言中的字符串。而是构建了一个名为简单动态字符串（Simple Dynamic String, SDS）的类型，并将SDS作为Redis默认的字符串表示。</p>
<p>在Redis中，有一种情况会使用C语言的字符串，就是常量字符串。除此之外，都会使用SDS来表示字符串值。同时，SDS还会被用作缓冲区：AOF中的缓冲区，以及客户端状态中的输入缓冲区都是用SDS实现的。</p>
<p>例如：Redis 所有的数据结构都是以唯一的 key 字符串作为名称，然后通过这个唯一 key 值来获取相应的 value 数据。不同类型的数据结构的差异就在于 value 的结构不一样。但是这个key使用的结构，都是字符串类型。</p>
<h4 id="1-1-SDS的定义"><a href="#1-1-SDS的定义" class="headerlink" title="1.1  SDS的定义"></a>1.1  SDS的定义</h4><p>每个sdshdr结构表示一个SDS：</p>
<p><img src="/2022/02/14/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%932-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1.png" alt="img"><center><em>SDS代码示意</em></center></p>
<p><img src="/2022/02/14/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%932-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/2.png" alt="img"><center><em>SDS结构示意</em></center></p>
<p>SDS遵循了C语言以’\0’结尾的惯例，保存空字符的一个长度空间不计算在len值里，并且为’\0’分配额外的空间，以及其他各种操作，都是有SDS函数完成，对使用者是透明的。</p>
<h4 id="1-2-SDS与C字符串的区别"><a href="#1-2-SDS与C字符串的区别" class="headerlink" title="1.2  SDS与C字符串的区别"></a>1.2  SDS与C字符串的区别</h4><p><strong>a.</strong>   <strong>O(1)复杂度获取字符串长度</strong></p>
<p>在C语言中，如果需要获取一个字符串长度，必须对字符串进行遍历，那么时间复杂度为O(N)。</p>
<p>但是在SDS中，因为有len的存在，所以获取长度的复杂度为O(1)。</p>
<p><strong>注意：在Redis中到处充斥着看似冗余，其实大大提高效率的方法。</strong></p>
<p><strong>b.</strong>   <strong>避免缓冲区溢出</strong></p>
<p>在C语言中，执行字符串深度融合操作strcat(s1,s2)时，默认s1的空间足够长来容纳s2。如果曾经写过java的程序员（产品经理）忘记了为s1分配足够的空间，那么会导致修改之后s1的数据，会占据原先跟他相邻的空间，导致将其他程序的数据覆盖。</p>
<p>在SDS中，需要对值进行修改时，API会检查SDS的空间是否满足修改所需要求，如果不满足，API会自动将SDS空间进行扩展，之后执行实际的修改操作。所以用户不需进行手动修改，也不会发生缓冲区溢出问题。</p>
<p><strong>c.</strong>   <strong>减少内存重分配次数</strong></p>
<p>在C语言中，字符串的底层实现是一个N+1个字符长度的数组（额外的一个字符空间保存’\0’）。所以每次增长或缩短C字符串，程序都会对保存这个字符串的数组进行一次内存重分配的操作（拼接前首先扩展空间，截断后需要释放空间）。内存重分配涉及复杂的算法，而且可能需要执行系统调用，所以通常是个比较耗时的操作。在极度追求速度、数据修改频繁的Redis中，会对性能造成影响。</p>
<p>在SDS中，实现了<strong>空间预分配</strong>和<strong>惰性空间释放</strong>两种优化策略。</p>
<p><strong>1)    空间预分配</strong></p>
<p>当需要对SDS进行空间扩展的时候，程序不仅为SDS分配所需必要空间，同时也会分配额外的使用空间。</p>
<p>规则1：如果对SDS进行修改之后，SDS的长度（len值）小于1M，那么程序分配和len值同样大小的未使用空间。此时SDS的len值和free值相同。</p>
<p>规则2：如果对SDS修改之后，SDS长度将大于1M，那么程序会分配1M的未使用空间。</p>
<p><strong>2)    惰性空间释放</strong></p>
<p>当SDS的API需要缩短字符串时，程序并不立即使用内存重分配来回收缩短后多出来的字节，而是使用free属性将这些字节的数量记录起来，等待将来使用。</p>
<p>同时，在我们有需要时，也可以真正的释放SDS的未使用空间，所以不用担心惰性空间释放策略会造成内存浪费。</p>
<p><strong>d.</strong>   <strong>二进制安全</strong></p>
<p>因为传统C字符串符合ASCII编码，这种编码的操作的特点就是：遇零则止。即，当读一个字符串时，只要遇到’\0’结尾，就认为到达末尾，就忽略’\0’结尾以后的所有字符。因此，如果传统字符串保存图片，视频等二进制文件，操作文件时就被截断了。</p>
<p>SDS的buf被定义为字节数组，因为判断是否到达字符串结尾的依据则是len成员，这意味着它可以存放任何二进制的数据和文本数据，包括’\0’。</p>
<p>同时SDS的API都会以处理二进制的方式处理SDS存放在buf数组里的数据。</p>
<p><strong>e.</strong>   <strong>兼容部分C字符串函数</strong></p>
<p>因为SDS同样遵循C语言字符串以’\0’结尾的管理，所以SDS可以重用类似strcasecmp(忽略大小写的比较)和strcat(字符串拼接)等C语言字符串的函数。</p>
<h3 id="2-链表"><a href="#2-链表" class="headerlink" title="2.  链表"></a>2.  链表</h3><p>当list类型包含了超过??个元素，或者元素长度超过??字节时，链表会作为列表的底层实现。同时，发布与订阅，慢查询、监视器等功能也使用到了链表。Redis服务器本身还使用链表来保存多个客户端的状态信息，以及使用链表来构建客户端输出缓冲区。</p>
<p>节点使用listNode结构来表示：</p>
<p>​     </p>
<p><img src="/2022/02/14/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%932-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.png" alt="img"><center><em>listNode代码示意</em></center></p>
<p>如果使用多个listNode，其实可以组成链表。但为了效率和操作方便，Redis使用list结构来表示链表：</p>
<p>​     </p>
<p><img src="/2022/02/14/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%932-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/4.png" alt="img"><center><em>list代码示意</em></center></p>
<p>一个包含3个节点的链表结构如下图所示：</p>
<p><img src="/2022/02/14/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%932-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5.png" alt="img"><center><em>链表结构示意</em></center></p>
<p>Redis链表的特性有以下几点：</p>
<p><strong>1)    双端</strong></p>
<p>通过prev和next指针，获取某个节点的前置节点和后置节点的复杂度都是O(1)。</p>
<p><strong>2)    非环</strong></p>
<p>头节点的prev指针和尾结点的next指针都指向NULL,对链表的访问以NULL为终点。</p>
<p><strong>3)    头尾</strong></p>
<p>通过head指针和tail指针，程序获取链表头结点和尾结点的复杂度为O(1)。</p>
<p><strong>4)    长度</strong></p>
<p>通过len值，程序获取链表中节点数量的复杂度为O(1)。</p>
<p><strong>5)    多态</strong></p>
<p>链表节点使用void*指针来保存节点值，可以通过list结构中的dup、free、match三个属性为节点值设置类型特定函数，所以链表可以用于保存各种不同类型的值。</p>
<h3 id="3-字典"><a href="#3-字典" class="headerlink" title="3.  字典"></a>3.  字典</h3><p>字典在Redis中的应用非常广泛，比如Redis数据库就是用字典来作为底层实现的，对数据库的增删改查操作也是构建在对字典的操作之上的。除了标识数据库之外，字典也是哈希键的底层实现之一。当哈希键包含的键值对数量多，或者键值对中的元素是较长的字符串时，Redis会使用字典作为哈希键的底层实现。</p>
<p>Redis中的字典包含了哈希表节点、哈希表和字典三个结构</p>
<h4 id="3-1-哈希表节点"><a href="#3-1-哈希表节点" class="headerlink" title="3.1  哈希表节点"></a>3.1  哈希表节点</h4><p>哈希表节点使用dicEntry结构表示，如下图：</p>
<p>​     </p>
<p><img src="/2022/02/14/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%932-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/6.png" alt="img"><center><em>dictEntry代码示意</em></center></p>
<p><strong>1)</strong>    key中保存键。</p>
<p><strong>2)</strong>    val中保存值。val可以是一个指针，也可以是一个uint64_t的整数或者int64_t的整数。</p>
<p><strong>3)</strong>    next是指向另一个节点的指针，这个指针可以将多个哈希值相同的键值对连接在一起，解决哈希冲突问题。</p>
<h4 id="3-2-哈希表"><a href="#3-2-哈希表" class="headerlink" title="3.2  哈希表"></a>3.2  哈希表</h4><p>哈希表使用dictht结构定义，如下图：</p>
<p>​     </p>
<p><img src="/2022/02/14/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%932-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/7.png" alt="img"><center><em>dictht代码示意</em></center></p>
<p><strong>1)</strong>    table是一个数组，table中的每一个元素都是只想dictEntry结构的指针，每个dictEntry结构保存着一个键值对。</p>
<p><strong>2)</strong>    size属性记录了哈希表大小。</p>
<p><strong>3)</strong>    sizemask始终等于size-1，用于与哈希值一起计算index。</p>
<p><strong>4)</strong>    used属性记录已有节点的数量。</p>
<p>一个哈希表如下图所示：</p>
<p><img src="/2022/02/14/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%932-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/8.png" alt="img"><center><em>hashht结构示意</em></center></p>
<h4 id="3-3-字典"><a href="#3-3-字典" class="headerlink" title="3.3  字典"></a>3.3  字典</h4><p>Redis中的字典使用dict结构表示，如下图：</p>
<p>​     </p>
<p><img src="/2022/02/14/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%932-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/9.png" alt="img"><center><em>dict代码示意</em></center></p>
<p><strong>1)</strong>    type属性是一个指向dictType结构的指针，每个dictType结构保存了一簇用于操作特定类型键值对的函数，Redis会为用途不同的字典设置不同的类型特定函数。</p>
<p><strong>2)</strong>    privdata属性保存了需要传给那些类型特定函数的可选参数。</p>
<p><strong>3)</strong>    ht属性是一个包含2个元素的数组，其中每个项都是一个dictht哈希表。一般情况下，字典只使用ht[0]，而ht[1]只有在对ht[0]进行rehash时使用。</p>
<p><strong>4)</strong>    rehashidx属性记录了rehash目前的进度，如果没有在进行rehash，那么值为-1。</p>
<p>dict结构如下图所示：</p>
<p>​<br><img src="/2022/02/14/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%932-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/10.png" alt="img"><center><em>dict结构示意图</em></center></p>
<h4 id="3-4-哈希算法"><a href="#3-4-哈希算法" class="headerlink" title="3.4  哈希算法"></a>3.4  哈希算法</h4><p>当要将一个新的键值对添加到字典中时，程序要先根据键计算出哈希值和索引值，然后根据索引值，将包含新键值对的哈希表节点放到哈希表数组的指定索引上面。</p>
<p>Redis计算哈希值和索引值的方法如下：</p>
<p><strong>1.</strong> 使用字典设定的特定类型的哈希函数，计算键key的哈希值</p>
<p><strong>hash &#x3D; dict-&gt;type-&gt;hashFunction(key);</strong></p>
<p><strong>2.</strong> 根据哈希表的sizemask和哈希值，计算出索引值。</p>
<p>&#x2F;&#x2F;根据情况不同，ht[x]可以是ht[0]或ht[1]</p>
<p><strong>index&#x3D;hash &amp; dict-&gt;ht[x].sizemask;</strong></p>
<p>Redis使用MurmurHash2算法（目前最新版本是MurmurHash3）来计算键的哈希值。<strong>这个算法的优点在于，即使输入的键是有规律的，算法依然能够给出一个很好的随机分布性</strong>。</p>
<h4 id="3-5-哈希冲突"><a href="#3-5-哈希冲突" class="headerlink" title="3.5  哈希冲突"></a>3.5  哈希冲突</h4><p>当有2个或2个以上数量的键被分配到哈希表数组的同一个索引上面时，我们称这些键发生了冲突。</p>
<p>Redis的哈希表使用链地址法来解决哈希冲突：即next指针。通过每个哈希表节点的next指针，可以构成一个单向链表，这样被分配到同一个索引上的多个节点可以通过这个链表连接起来，解决了冲突问题。</p>
<p>因为dictEntry节点组成的链表没有指向尾部的指针，所以每次都会将新节点添加到链表的表头位置（复杂度O(1)）。排在其他已有节点的前面。</p>
<h4 id="3-6-rehash"><a href="#3-6-rehash" class="headerlink" title="3.6  rehash"></a>3.6  rehash</h4><p>随着操作的不断进行，哈希表保存的键值会不断地增多，为了让负载因子维持在一个合理的范围内，程序需要对哈希表的大小进行相应的扩展和收缩。</p>
<p>扩展和收缩哈希表通过rehash操作来完成，步骤如下：</p>
<p><strong>1)</strong>    为ht[1]分配空间，大小取决于要执行的操作以及ht[0]当前键的数量（ht[0].used的值）：</p>
<p>如果要执行扩展操作，那么ht[1]大小为 第一个大于等于ht[0].used*2的2n。</p>
<p>如果要执行收缩操作，那么ht[1]大小为 第一个大于等于ht[0].used的2n。</p>
<p><strong>2)</strong>    将保存在ht[0]中的所有键值对rehash到ht[1]上面，即重新计算哈希值和索引值，然后将键值对放置到ht[1]指定的位置上。</p>
<p><strong>3)</strong>    当ht[0]包含的键值对都迁移到ht[1]时，释放ht[0]，将ht[1]置为ht[0]，并在ht[1]创建一个空白的哈希表，为下一次rehash做准备。</p>
<h4 id="3-7-rehash的条件"><a href="#3-7-rehash的条件" class="headerlink" title="3.7  rehash的条件"></a>3.7  rehash的条件</h4><p>负载因子&#x3D;哈希表已存节点数量&#x2F;哈希表大小</p>
<p><strong>1)</strong>    当哈希表的负载因子小于0.1时，程序自动开始对哈希表执行收缩操作。</p>
<p><strong>2)</strong>    当服务器没有执行BGSAVE或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于1，程序开始对哈希表执行扩展操作。</p>
<p><strong>3)</strong>    当服务器正在执行BGSAVE或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于5，程序开始对哈希表执行扩展操作。</p>
<p>为什么正在执行命令时负载因子被扩大到5？</p>
<p>因为在执行BGSAVE和BGREWRITEAOF命令时，Redis需要创建当前服务器进程的子进程，而大多数操作系统都采用<strong>写时复制技术</strong>来优化子进程的使用效率，所以在子进程存在期间，服务器会提高负载因子，尽量避免在此期间对哈希表进行扩展操作，也就避免写入操作，最大限度节约内存。</p>
<h4 id="3-8-渐进式rehash"><a href="#3-8-渐进式rehash" class="headerlink" title="3.8  渐进式rehash"></a>3.8  渐进式rehash</h4><p>将ht[0]中的键值rehash到ht[1]中这个过程并不是一次性完成的，而是一个多次的、渐进的完成过程。因为ht[0]中存储的键值数量有可能很多，如果一次性完成，可能会导致服务暂时停止响应。</p>
<p>渐进式rehash的步骤：</p>
<p><strong>1)</strong>    为ht[1]分配空间。</p>
<p><strong>2)</strong>    将rehashidx置为0，表示rehash开始。</p>
<p><strong>3)</strong>    在rehash期间，每次对字典执行添加、删除、查找、更新操作时，程序除了执行指定的操作以外，还会顺带将ht[0]哈希表在rehashidx索引上的所有键值对rehash到ht[1]，当rehash工作完成后，程序将rehashidx属性的值增加1。</p>
<p><strong>4)</strong>    随着字典操作的不断进行，最终在某个时间点，ht[0]上面的所有键值对都会被移动至ht[1]上面，这是将rehashidx的值设置为-1，标识rehash操作已经完成。</p>
<p>渐进式rehash的要注意的点：</p>
<p><strong>1)</strong>    渐进式rehash避免了集中rehash带来的庞大计算量和宕机风险。</p>
<p><strong>2)</strong>    在渐进式rehash过程中，字典的删除、查找、更新操作，会同时在两个ht上进行。例如如果查找一个键，程序会先在ht[0]中进行查找，如果没找到，那么在ht[1]中进行查找。</p>
<p><strong>3)</strong>    在渐进式rehash过程中，字典的新增操作，一律会被保存到ht[1]中，保证ht[0]只减不增。</p>
<h3 id="4-跳跃表"><a href="#4-跳跃表" class="headerlink" title="4.  跳跃表"></a>4.  跳跃表</h3><p>跳跃表（skiplist）是一种有序的数据结构，通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。</p>
<p>Redis只在2个地方使用到了跳跃表：一是有序集合键；二是在集群节点中用作内部数据结构。</p>
<p>Redis 的跳跃表由 zskiplistNode 和 zskiplist 两个结构定义， 其中 zskiplistNode 结构用于表示跳跃表节点， 而 zskiplist 结构则用于保存跳跃表节点的相关信息。如下图：</p>
<p>​     </p>
<p><img src="/2022/02/14/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%932-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/11.png" alt="img"><center><em>跳跃表结构示意图</em></center></p>
<p>zskiplistNode结构如下图：</p>
<p>​     </p>
<p><img src="/2022/02/14/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%932-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/12.png" alt="img"><center><em>zskiplistNode代码示意图</em></center></p>
<p><strong>1)    层（L1,L2,L3,L4…）</strong></p>
<p>L1表示第一层，L2表示第二层，等等。每个层都带有两个属性：前进指针和跨度。前进指针用于访问位于表尾方向的其他节点，指向其他节点的相同层。而跨度则记录了前进指针所指向节点和当前节点的距离。</p>
<p>跳跃表节点的 level 数组可以包含多个元素，每个元素都包含一个指向其他节点的指针，<strong>程序可以通过这些层来加快访问其他节点的速度</strong>，一般来说，层的数量越多，访问其他节点的速度就越快。</p>
<p>每次创建一个新跳跃表节点的时候， 程序都根据幂次定律 （power law，越大的数出现的概率越小） 随机生成一个介于 1 和 32 之间的值作为 level 数组的大小，这个大小就是层的“高度”。包含层数越高的节点数越少。</p>
<p>层的跨度不是用于遍历，遍历只用前进指针即可完成。跨度用于计算排位：在查找某个节点的过程中，将沿途访问过的所有层的跨度累计起来，得到的结果就是目标节点在跳跃表中的排位。</p>
<p><strong>2)    后退（BW）指针</strong></p>
<p>节点中用 BW 字样标记节点的后退指针，它指向位于当前节点的前一个节点。后退指针在程序从表尾向表头遍历时使用。每个节点只有一个后退指针，所以每次智能后退至前一个节点。</p>
<p><strong>3)    分值（1.0,2.0,3.0…）</strong></p>
<p>在跳跃表中，节点按各自所保存的分值从小到大排列。分值是一个double类型浮点数。</p>
<p><strong>4)    成员对象（o1,o2,o3…）</strong></p>
<p>各个节点中的 o1 、 o2 和 o3 是节点所保存的成员对象。它是一个指针，指向一个字符串对象，字符串对象存着一个SDS值。分值相同的节点会按照成员对象在字典序中的大小进行排序。</p>
<p>虽然仅凭跳跃节点就可以组成一个跳跃表，但是通过zskiplist结构可以更方便的对整个跳跃表进行处理，比如快速访问表头节点、表尾结点、节点数量等。zskiplist结构定义如下：</p>
<p>​     </p>
<p><img src="/2022/02/14/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%932-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/13.png" alt="img"><center><em>zskiplist代码示意图</em></center></p>
<p><strong>1)    header</strong></p>
<p>指向跳跃表的表头节点</p>
<p><strong>2)    tail</strong> </p>
<p>指向跳跃表的表尾节点。</p>
<p><strong>3)    length</strong> </p>
<p>记录跳跃表的长度，也即是，跳跃表目前包含节点的数量（表头节点不计算在内）。</p>
<p><strong>4)    level</strong> </p>
<p>记录目前跳跃表内，层数最大的那个节点的层数（表头节点的层数不计算在内）。</p>
<p>通过4个属性，程序可以在O(1)复杂度内实现表头节点、表尾结点、节点数量、最大高度等。</p>
<p>关于跳跃表：</p>
<p>跳跃表的关键在于：关键节点。</p>
<p>当只有一层时，跳表其实是一个链表。如果想要插入数据或者寻找数据，只能逐个遍历比较。但当出现第二层时，第二层的值可以作为关键节点。程序可以在第二层关键节点中进行比较，确定大概位置后，返回第一层确定准确位置。同样，可以建立第三层，作为第二层关键节点的关键节点。</p>
<p>最高层是多少层？当一层中只有2个节点时，就无须再往上创建层级。</p>
<p>哪些节点往上升级？基于大数据人工智能区块链的科学严谨的算法：抛硬币。</p>
<p>复杂度？O(logN)。可以和平衡树相媲美。</p>
<h3 id="5-整数集合"><a href="#5-整数集合" class="headerlink" title="5.  整数集合"></a>5.  整数集合</h3><p>整数集合（intset）是集合键的底层实现之一： 当一个集合只包含整数值元素， 并且这个集合的元素数量不多（??）时， Redis 就会使用整数集合作为集合键的底层实现。</p>
<p>整数集合intset结构代码如下：</p>
<p>​     </p>
<p><img src="/2022/02/14/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%932-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/14.png" alt="img"><center><em>intset代码示意图</em></center></p>
<ol>
<li><p>contents 数组是整数集合的底层实现，保存着每个元素。各个项在数组中按值的大小从小到大有序地排列， 并且数组中不包含任何重复项。</p>
</li>
<li><p>length 属性记录了 contents 数组的长度。</p>
</li>
<li><p>encoding 属性的值决定而contents数组的真正类型（而不是int8_t）。随着encoding的类型（INTSET_ENC_INT16，INTSET_ENC_INT32，INTSET_ENC_INT64），contents数组类型分别是int16_t（-215-215-1），int32_t（-231-231-1），int64_t（-263-263-1）。</p>
</li>
</ol>
<p>结构示意图如下：</p>
<p>​     </p>
<p><img src="/2022/02/14/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%932-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/15.png" alt="img"><center><em>intset结构示意图</em></center></p>
<p>虽然contents数组保存的四个整数值中，只有-2675256175807981027是真正需要用int64_t类型来保存的，而其他的1、3、5三个值都可以用int16_t类型来保存，不过根据<strong>整数集合的升级规则</strong>，当向一个底层为int16_t数组的整数集合添加一个int64_t类型的整数值时，整数集合已有的所有元素都会被转换成int64_t类型，所以contents数组保存的四个整数值都是int64_t类型的，不仅仅是-2675256175807981027。</p>
<h4 id="5-1-升级"><a href="#5-1-升级" class="headerlink" title="5.1  升级"></a>5.1  升级</h4><p>每当我们要将一个新元素添加到整数集合里面，并且新元素的类型比整数集合现有所有元素的类型都要长时，整数集合需要先进行升级（upgrade）， 然后才能将新元素添加到整数集合里面。</p>
<p>升级整数集合并添加新元素共分为三步进行：</p>
<p><strong>1.</strong>   扩展原有空间。</p>
<p><strong>2.</strong>   旧元素类型转换，安放位置，按照顺序。</p>
<p><strong>3.</strong>   新元素添加。</p>
<p>假设现在有一个INTSET_ENC_INT16编码的整数集合，里面存着1，2，3。存储位置如下：</p>
<table>
<thead>
<tr>
<th>位</th>
<th>0-15</th>
<th>16-31</th>
<th>32-47</th>
</tr>
</thead>
<tbody><tr>
<td>元素</td>
<td>1</td>
<td>2</td>
<td>3</td>
</tr>
</tbody></table>
<p>当我们要存储一个32768的数字进入数组时，因为超过了int16_t的范围，所以要对数组进行升级。</p>
<p><strong>1.</strong>   根据新类型的长度， 以及集合元素的数量（包括要添加的新元素在内）， 对底层数组进行空间重分配（4个int32_t元素长度是128），分配后如下图所示：</p>
<table>
<thead>
<tr>
<th>位</th>
<th>0-15</th>
<th>16-31</th>
<th>32-47</th>
<th>48-127</th>
</tr>
</thead>
<tbody><tr>
<td>元素</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>空</td>
</tr>
</tbody></table>
<p><strong>2.</strong>   从后往前（3-&gt;2-&gt;1），依次将原有的元素放到新的位置上。</p>
<table>
<thead>
<tr>
<th>位</th>
<th>0-15</th>
<th>16-31</th>
<th>32-47</th>
<th>48-63</th>
<th>64-95</th>
<th>96-127</th>
</tr>
</thead>
<tbody><tr>
<td>元素</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>空</td>
<td>3（新）</td>
<td>空</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>位</th>
<th>0-15</th>
<th>16-31</th>
<th>32-63</th>
<th>64-95</th>
<th>96-127</th>
</tr>
</thead>
<tbody><tr>
<td>元素</td>
<td>1</td>
<td>2</td>
<td>2（新）</td>
<td>3</td>
<td>空</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>位</th>
<th>0-31</th>
<th>32-63</th>
<th>64-95</th>
<th>96-127</th>
</tr>
</thead>
<tbody><tr>
<td>元素</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>空</td>
</tr>
</tbody></table>
<p><strong>3.</strong>   添加新元素。</p>
<table>
<thead>
<tr>
<th>位</th>
<th>0-31</th>
<th>32-63</th>
<th>64-95</th>
<th>96-127</th>
</tr>
</thead>
<tbody><tr>
<td>元素</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>32768</td>
</tr>
</tbody></table>
<p><strong>4.</strong>   修改encoding 为INTSET_ENC_INT64，修改length为4。</p>
<p>注意：升级后新元素位置在哪？</p>
<p>升级后新元素位置要么在数组最开头，要么在数组最末尾。</p>
<h4 id="5-2-升级的好处"><a href="#5-2-升级的好处" class="headerlink" title="5.2  升级的好处"></a>5.2  升级的好处</h4><p><strong>1)    提高灵活性</strong></p>
<p>虽然不像某语言可以在同一数组中存入不同类型的各种元素，但是整数集合可以通过自动升级完成 int16_t、int32_t或者int64_t类型整数的兼容，而不用担心类型错误。</p>
<p><strong>2)    节约内存</strong></p>
<p>虽然可以直接用int64_t类型来存储数组，但是在整数值较小时，会造成内存浪费。整数集合可以保证升级操作仅在有必要时进行，尽量节约内存。</p>
<h4 id="5-3-降级"><a href="#5-3-降级" class="headerlink" title="5.3  降级"></a>5.3  降级</h4><p>整数集合不支持降级操作， 一旦对数组进行了升级， 编码就会一直保持升级后的状态。</p>
<h3 id="6-压缩列表"><a href="#6-压缩列表" class="headerlink" title="6.  压缩列表"></a>6.  压缩列表</h3><p>压缩列表（ziplist）是列表键和哈希键的底层实现之一。</p>
<h4 id="6-1-压缩列表的构成"><a href="#6-1-压缩列表的构成" class="headerlink" title="6.1  压缩列表的构成"></a>6.1  压缩列表的构成</h4><p>压缩列表的组成部分如下：</p>
<table>
<thead>
<tr>
<th>zlbytes</th>
<th>zltail</th>
<th>zllen</th>
<th>entry1</th>
<th>entry2</th>
<th>…</th>
<th>entryN</th>
<th>zlend</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>压缩列表各组成部分说明：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>类型</th>
<th>长度</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>zlbytes</td>
<td>uint32_t</td>
<td>4</td>
<td>记录整个压缩列表所占用内存字节数</td>
</tr>
<tr>
<td>zltail</td>
<td>uint32_t</td>
<td>4</td>
<td>记录表尾结点距离起始地址有多少字节</td>
</tr>
<tr>
<td>zllen</td>
<td>uint16_t</td>
<td>2</td>
<td>记录压缩列表节点数量</td>
</tr>
<tr>
<td>entryX</td>
<td>列表结点</td>
<td>不定</td>
<td>压缩列表各个节点</td>
</tr>
<tr>
<td>zlend</td>
<td>uint8_t</td>
<td>1</td>
<td>固定值0xFF(十进制255)，标记压缩列表末端</td>
</tr>
</tbody></table>
<p>示例如下：</p>
<table>
<thead>
<tr>
<th>zlbytes</th>
<th>zltail</th>
<th>zllen</th>
<th>entry1</th>
<th>entry2</th>
<th>entry3</th>
<th>entry4</th>
<th>entry5</th>
<th>zlend</th>
</tr>
</thead>
<tbody><tr>
<td>0xd2</td>
<td>0xb3</td>
<td>0x5</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>0xFF</td>
</tr>
<tr>
<td>P</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>P+179</td>
<td></td>
</tr>
</tbody></table>
<p><strong>1)</strong>    zlbytes属性的值为0xd2（十进制210），表示压缩列表的总长为210字节。</p>
<p><strong>2)</strong>    zltail属性的值为0xb3（十进制179），这表示如果我们有一个指向压缩列表起始地址的指针p，那么只要用指针p加上偏移量179，就可以计算出表尾节点entry5 的地址。</p>
<p><strong>3)</strong>    zllen属性的值为0x5（十进制5），表示压缩列表包含五个节点。</p>
<p><strong>4)</strong>    zllend属性的值为 0xFF（十进制255），固定值。</p>
<h4 id="6-2-压缩列表节点"><a href="#6-2-压缩列表节点" class="headerlink" title="6.2  压缩列表节点"></a>6.2  压缩列表节点</h4><p>压缩列表节点可以保存一个字节数组或一个整数值。组成部分如下：</p>
<table>
<thead>
<tr>
<th>previous_entry_length</th>
<th>encoding</th>
<th>content</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><strong>1)</strong>    previous_entry_length</p>
<p>previous_entry_length以字节为单位，记录了压缩列表中<strong>前一个节点的长度</strong>。</p>
<p>程序可以通过指针运算，根据当前节点的起始地址来计算前一个节点的起始地址。压缩列表的表尾向表头的遍历操作就是通过这一原理实现的。</p>
<p><strong>2)</strong>    encoding</p>
<p>encoding记录了节点的content属性所保存的类型及长度。</p>
<p><strong>3)</strong>    content属性</p>
<p>content属性负责保存节点的值，节点值可以是一个字节数组或者整数， 值的类型和长度由节点的encoding属性决定。</p>
<p>举例如下：</p>
<table>
<thead>
<tr>
<th>previous_entry_length</th>
<th>encoding</th>
<th>content</th>
</tr>
</thead>
<tbody><tr>
<td>…</td>
<td>00001011</td>
<td>“hello  world”</td>
</tr>
</tbody></table>
<p><strong>a)</strong>    编码的最高两位 00 表示节点保存的是一个字节数组；</p>
<p><strong>b)</strong>   编码的后六位 001011 记录了字节数组的长度 11 ；</p>
<p><strong>c)</strong>    content 属性保存着节点的值 “hello world” 。</p>
<table>
<thead>
<tr>
<th>previous_entry_length</th>
<th>encoding</th>
<th>content</th>
</tr>
</thead>
<tbody><tr>
<td>…</td>
<td>11000000</td>
<td>10086</td>
</tr>
</tbody></table>
<p><strong>a)</strong>    编码 11000000 表示节点保存的是一个 int16_t 类型的整数值；</p>
<p><strong>b)</strong>   content 属性保存着节点的值 10086 。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag"># 数据结构</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/02/14/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%931-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" rel="prev" title="Redis技术总结1-数据类型">
                  <i class="fa fa-chevron-left"></i> Redis技术总结1-数据类型
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/02/14/Redis%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%933-%E5%AF%B9%E8%B1%A1/" rel="next" title="Redis技术总结3-对象">
                  Redis技术总结3-对象 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">郭超</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="https://unpkg.com/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="https://unpkg.com/hexo-theme-next@8.10.0/source/js/comments.js"></script><script src="https://unpkg.com/hexo-theme-next@8.10.0/source/js/utils.js"></script><script src="https://unpkg.com/hexo-theme-next@8.10.0/source/js/motion.js"></script><script src="https://unpkg.com/hexo-theme-next@8.10.0/source/js/schemes/muse.js"></script><script src="https://unpkg.com/hexo-theme-next@8.10.0/source/js/next-boot.js"></script>

  





  





</body>
</html>
