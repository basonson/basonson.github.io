---
title: Redis技术总结1-数据类型
date: 2022-02-14 09:57:31
tags:
    - 常用命令
    - 数据类型
categories:
    - 数据库
    - NoSQL
    - Redis
---

### 一． Redis常用知识

#### 1.  常用命令

**1)    keys \***

查看所有键，只看键，不看值。

 

**2)    dbsize**

返回当前数据库中键的数量。

dbsize命令在返回结果时，不会遍历所有的键，而是直接获取Redis内置的键总数变量。所以时间复杂度是O(1)。而keys会遍历所有键，所以时间复杂度是O(n)。

**通常生产环境禁止使用keys \*命令。**

 

**3)    exists [key]**

返回键是否存在，存在则返回1，不存在返回0。

 

**4)    del [key]**

删除键。返回成功删除键的个数。如果尝试删除一个不存在的键，那么返回0。可以同时删除多个键（多个键之间用空格分隔）。

 

**5)    expire [key] [seconds]**

对键添加过期时间。

 

**6)    ttl [key]**

显示离键过期的剩余时间。三种返回值：

a.   -2：key不存在。

b.   -1：key存在但已经过期。

c.   n：剩余时间(秒)。

 

**7)    type [key]**

返回键的类型（5种）。如果键不存在返回none。

 

 

#### 2.  数据类型及内部编码

Redis有5种数据类型（type命令返回的值）分别是：

**string（字符串）**

**hash（哈希）**

**list（列表）**

**set（集合）**

**zset（有序集合）**

 

每种数据类型都有2种及以上的内部编码，如下图所示：

![img](1.png)<center>*Redis数据类型的不同编码*</center>

 

用object encoding [key] 命令查询编码。

优点：

**1.**   Redis可以在不改变对外接口的情况下，对内进行编码改进，提高性能，不影响用户正常使用。

**2.**   多种内部编码可以在不同情形下发挥各自的优势。

 

**3.**  单线程架构

Redis使用了单线程架构和I/O多路复用模型来实现高性能的内存数据库服务。

![img](2.png)<center>*Redis客户端与服务器交互过程*</center>

 

![img](3.png)<center>*命令在队列中等待执行*</center>

 

Redis单线程但是依然很快的原因：

**1.**   **纯内存访问。**

Redis所有数据在内存中，内存访问速度可以到达100纳秒。这是Redis达到每秒万级访问的重要基础。

**2.**   **非阻塞I/O。**

Redis使用epoll作为I/O多路复用技术的实现，再加上Redis自身的事件处理模型将epoll中的连接、读写、关闭都转换为事件，不在网络I/O上浪费过多的时间。

什么是epoll？

https://blog.csdn.net/songchuwang1868/article/details/89877739

**3.**   **单线程避免了线程切换造成的消耗。**

关于线程切换？

 

### 二． 数据类型

#### 1.  string(字符串)

Redis字符串类型的值可以为简单的字符串、复杂的字符串（JSON，XML）、数字（整型，浮点型），甚至二进制（图片，音频，视频），但是最大不能超过512M

**1.1  常用命令**

除了get，set外，还有setnx，setxx，mset，mget，incr。

**1)    setnx/setxx**

setnx是键必须不存在，才能设置成功，常用于新增。

setxx是键必须存在，才能设置成功，常用于更新。

**关键应用场景：**

setnx可以作为分布式锁的一种实现方案：如果多个客户端同时执行setnx [key] [value]，根据setnx的特性，只有一个客户端能设置成功。

**2)    mset/mget**

批量执行。

**原因：**

Redis可以支撑每秒11w次的读操作/8w次的写操作，这指的是Redis服务端的处理能力，对于客户端来说，一次命令除了执行时间还有网络时间。

用get命令：n次get时间=n次网络时间+n次命令时间

用mget命令：n次get时间=1次网络时间+n次命令时间

假如1次网络时间为1ms，1次执行时间为0.1ms。那么1000个get命令时间为1.1s，1个包含1000个key的mget命令为0.101s。

**3)    incr**

incr命令用于对值做自增操作。返回结果分为三种：

a.   error：值不是整数，返回错误信息。

b.   值是整数，返回自增之后的结果。

c.   键不存在，按照值为0自增，返回1.

 

**1.2  内部编码**

字符串类型的内部编码有3种：

**1)    int**

8个字节的长整型

**2)    embstr**

小于等于39个字节的字符串

**3)    raw**

大于39个字节的字符串

 

**1.3  典型场景**

**1)    最常用的缓存功能**

**2)    计数器**

播放数、点赞数。

**3)    共享session**

使用Redis对session进行集中管理。

**4)    限制操作次数**

一个操作之后在Redis中给相应操作增加一个key和一个n秒过期时间，再次操作时判断key是否存在，如果存在那么直接返回失败。

 

#### 2.  hash(哈希)

哈希类型指的是键的值，本身是一个键值对类型。如下图所示：

![img](4.png)<center>*string与hash对比*</center>

 

**2.1  常用命令**

命令几乎都是h开头，比如hset，hget，h代表hash。

 

**2.2  内部编码**

哈希类型的内部编码有2种：

**1)    ziplist**

当哈希类型元素个数小于512个、同时所有值都小于64个字节时（512与64均为可配置项），Redis会使用ziplist作为哈希的内部实现。ziplist使用更紧凑的结构实现多个元素的连续存储，在节省内存方面更优秀。

**2)    hashtable**

当不满足ziplist的条件时，Redis会使用hashtable作为哈希的内部实现。因为此时ziplist的读写效率会下降，但是hashtable的读写时间复杂度是O(1)。

 

**2.3  使用场景**

用于缓存关系型数据库表中的每行信息（例如对比图中的用户信息）。但是哈希类型的每个键可以有不同的值，不局限于关系型数据库中的字段。同时，他也不能像关系型数据库那样进行复杂查询。

关于缓存关系型数据库中每行信息（用户信息），有3种方式可以实现：

**1)    string字符串类型**

每个属性一个键，例如

set user:1:name guoc12

set user:1:age 34

set user:1:city Tianjin

优点：简单直观。

缺点：占用过多的键，内存占用量较大。用户信息内聚性差（在不了解键命名规则的基础上很难查询所有值的信息）

**2)    序列化字符串类型**

将用户信息序列化后用一个键保存，例如：

set user:1 serialize(userInfo)

优点：简化编程。

缺点：序列化和反序列化需要一定的开销。每次更新某个属性或者获取某个属性都需要将全部属性都取出。

**3)    hash哈希类型**

每个用户属性使用一个键值对，但都是用一个键保存。

hset user:1 name guoc12 age 34 city Tianjin

优点：简单直观。

缺点：当使用hashtable编码会消耗更多内存。

 

#### 3.  list（列表）

list（列表）用于存储多个有序的字符串，每个字符串称为element（元素），一个list最多存储232-1个元素。

列表有2个特点：

**1.   有序**

**2.   可以重复**

 

**3.1  常用命令**

列表的命令有很多，可以从列表的两端（r和l）对列表进行push（插入）和pop（弹出）操作。还可以获得指定范围内的元素列表，获取指定索引下标的元素等。

列表命令通常以l，r开头。例如lpush，rpush，ltrim，lrange等等。

**1)    ltrim**

ltrim [key] [start] [end]

例如一个列表是 testlist中包含 a,s,d,f ，在执行完ltrim testlist 1,3 之后，会剩余s,d,f。

**2)    blpop/brpop**

他们是lpop/rpop（左右侧弹出）的阻塞版本。命令如下：

blpop [key…] [seconds]

意思是：

a.    如果可以弹出，那么立即弹出。如果不可以弹出，那么等待seconds秒。期间可以弹出时立即弹出，否则等待时间到后返回nil。当seconds为0时，持续等待。

b.    当key为多个时，比如blpop list1 list2 list3 0，会按照从左至右的顺序，一旦有一个可以弹出，客户端立刻返回。

c.    当多个客户端对同一个键执行blpop命令时，最先执行（命令最先到达Redis服务器）的客户端会获取到弹出的值。剩下的客户端依次弹出或继续阻塞。

 

**3.2  内部编码**

list列表类型的内部编码有2种：

**1)    ziplist**

当列表元素个数小于512个、同时列表中每个元素的值都小于64字节（512与64同样是可配，但与hash类型的配置项不同）。

**2)    linkedlist**

不满足ziplist条件时，使用linkedlist进行内部实现。

 

**3.3  使用场景**

**1)    消息队列**

lpush+brpop

**2)    普通队列**

lpush+rpop

**3)    栈**

lpush+lpop

**4)    有限集合**

lpush+ltrim

 

 

#### 4.  set（集合）

set集合也是用来保存多个字符串元素，但是与列表不同：集合中的元素是无序的，并且是不能重复的。一个集合同样能够存储232-1个元素。

 

**4.1  常用命令**

集合除了支持增删改查操作外，还支持多个集合取并集、交集、差集等等。

集合命令通常以s开头。

**1)    spop/srandmember**

spop [key] 从集合内随机弹出一个元素

srandmember [key] [count] 从集合内随机返回指定个元素

两者都是随机弹，但是spop命令执行后，元素会从集合中删除，而srandmember不会。

**2)    sinter/sunion/sdiff**

sinter [key1] [key2] 返回key1和key2的交集

sunion [key1] [key2] 返回key1和key2的并集

sdiff [key1] [key2] 返回key1和key2的差集（key1里有但是key2里没有的）

 

**4.2  内部编码**

**1)    intset**

当集合中的元素都是整数，且元素个数小于512（可配）个时，Redis会选用intset作为集合的内部实现。

**2)    hashtable**

当集合类型无法满足intset条件时，Redis会使用hashtable作为内部实现。

 

**4.3  使用场景**

**1)    标签**

sadd

**2)    抽奖，随机数**

spop/srandmember

**3)    社交（共同好友，共同关注）**

sadd + sinter

 

#### 5.  zset（有序集合）

有序集合跟集合类似，不能有重复成员。不同的是他可以排序。但是他与列表使用下标索引进行排序不同，他给每个元素设置一个score（分数）作为排序的依据。元素不能重复，但是score可以重复。

 

**5.1  常用命令**

有序集合的命令通常以z开头。常用命令除增删改查外，还包括计算排名、增加分数、返回排名，返回分数范围内的成员。也支持交集和并集操作但比较复杂。

 

**5.2  内部编码**

**1)    ziplist**

当有序集合的元素个数小于128个，同时每个元素的值都小于64字节时，Redis会使用ziplist作为有序集合的内部实现。

**2)    skiplist**

当ziplist条件不满足时，使用skiplist作为内部实现。

 

**5.3  使用场景**

排行榜系统（按照score查询或排序）

 

 
