---
title: Redis技术总结3-对象
date: 2022-02-14 16:01:03
tags:
    - 对象
categories:
    - 数据库
    - NoSQL
    - Redis
---

### 1.  对象

Redis 并没有直接使用123456所描述的来实现键值对数据库， 而是基于这些数据结构创建了一个对象系统， 这个系统包含字符串对象、列表对象、哈希对象、集合对象和有序集合对象这五种类型的对象， 每种对象都用到了至少一种我们前面所介绍的数据结构。

**1.**   Redis可以在执行命令之前，根据对象的类型来判断一个对象是否可以执行给定的命令。

**2.**   Redis针对不同的使用场景，为对象设置多种不同的数据结构实现，从而优化对象在不同场景下的使用效率。

**3.**   Redis的对象系统还实现了基于引用计数技术的内存回收机制：当程序不再使用某个对象的时候，这个对象所占用的内存就会被自动释放；

**4.**   Redis还通过引用计数技术实现了对象共享机制，这一机制可以在适当的条件下，通过让多个数据库键共享同一个对象来节约内存。

**5.**   Redis的对象带有访问时间记录信息，该信息可以用于计算数据库键的空转时长，在服务器启用了maxmemory功能的情况下，空转时长较大的那些键可能会优先被服务器删除。

 

####  对象的类型和编码

Redis 使用对象来表示数据库中的键和值，当创建一个键值对时，我们至少会创建两个对象， 一个对象用作键值对的键（键对象）， 另一个对象用作键值对的值（值对象）。

比如当执行命令set msg “hello world”时，数据库中新增了一个键值对，其中键值对的键是一个包含了字符串值 "msg" 的对象， 而键值对的值则是一个包含了字符串值 "hello world" 的对象：

​       Redis中的每个对象由redisObject结构表示，如下图：

![img](1.png)<center>*redisObject代码示意*</center>


**1.   type**

type属性记录了对象的类型，如下表列出的类型常量中的一个：

| 类型常量     | 对象名称     | TYPE命令的输出 |
| ------------ | ------------ | -------------- |
| REDIS_STRING | 字符串对象   | “string”       |
| REDIS_LIST   | 列表对象     | “list”         |
| REDIS_HASH   | 哈希对象     | “hash”         |
| REDIS_SET    | 集合对象     | “set”          |
| REDIS_ZSET   | 有序集合对象 | “zset”         |

 

对于Redis数据库保存的键值对来说，键总是一个字符串对象，而值则可以是字符串对象、列表对象、哈希对象、集合对象或者有序集合对象的其中一种。

 

**2.   encoding和ptr**

对象的ptr指针指向对象的底层实现数据结构，而这些数据结构由对象的encoding属性决定。

encoding,ptr的关系如下表：

| 编码                      | 底层数据结构               | OBJECT  ENCODING输出 |
| ------------------------- | -------------------------- | -------------------- |
| REDIS_ENCODING_INT        | long类型整数               | “int”                |
| REDIS_ENCODING_EMBSTR     | embstr编码的简单动态字符串 | “embstr”             |
| REDIS_ENCODING_RAW        | 简单动态字符串             | “raw”                |
| REDIS_ENCODING_HT         | 字典                       | “hashtable”          |
| REDIS_ENCODING_LINKEDLIST | 双向链表                   | “linkedlist”         |
| REDIS_ENCODING_ZIPLIST    | 压缩列表                   | “ziplist”            |
| REDIS_ENCODING_INTSET     | 整数集合                   | “intset”             |
| REDIS_ENCODING_SKIPLIST   | 跳跃表                     | “skiplist”           |

 

每个type都至少对应了2种的encoding，type和encoding决定了对象的结构类型，如下表：

| 类型         | 编码                      | 对象                           |
| ------------ | ------------------------- | ------------------------------ |
| REDIS_STRING | REDIS_ENCODING_INT        | 整数值实现的字符串对象         |
| REDIS_STRING | REDIS_ENCODING_EMBSTR     | embstr编码的SDS的字符串对象    |
| REDIS_STRING | REDIS_ENCODING_RAW        | SDS实现的字符串对象            |
| REDIS_LIST   | REDIS_ENCODING_ZIPLIST    | 压缩列表实现的列表对象         |
| REDIS_LIST   | REDIS_ENCODING_LINKEDLIST | 双向链表实现的列表对象         |
| REDIS_HASH   | REDIS_ENCODING_ZIPLIST    | 压缩列表实现的哈希对象         |
| REDIS_HASH   | REDIS_ENCODING_HT         | 字典实现的哈希对象             |
| REDIS_SET    | REDIS_ENCODING_INTSET     | 整数集合实现的集合对象         |
| REDIS_SET    | REDIS_ENCODING_HT         | 字典实现的集合对象             |
| REDIS_ZSET   | REDIS_ENCODING_ZIPLIST    | 压缩列表实现的有序集合对象     |
| REDIS_ZSET   | REDIS_ENCODING_SKIPLIST   | 跳跃表和字典实现的有序集合对象 |


### 2.  对象类型

#### 2.1  字符串对象

字符串对象的编码可以是int,raw,embstr。

如果一个字符串对象保存的是整数值，并且这个整数值（假设为10086）可以用long类型来表示，那么字符串对象会将整数值保存在字符串对象结构的ptr属性里面（将void*转换成long），并将字符串对象的编码设置为int。如下图：

​     
![img](2.png)<center>*int编码的字符串对象*</center>


如果字符串对象保存的是一个字符串值，并且这个字符串值（假设为”Long long ago, there lived a king…”）的长度大于39字节，那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串值，并将对象的编码设置为raw。如下图：

​     
![img](3.png)<center>*raw编码的字符串对象*</center>


如果字符串对象保存的是一个字符串值， 并且这个字符串值的长度小于等于 39 字节， 那么字符串对象将使用 embstr 编码的方式来保存这个字符串值。

embstr 编码是专门用于保存短字符串,和 raw编码一样，都使用redisObject结构和sdshdr结构来表示字符串对象，但raw编码会调用两次内存分配函数来分别创建redisObject结构和sdshdr结构，而embstr编码则通过调用一次内存分配函数来分配一块连续的空间，空间中依次包含redisObject和sdshdr两个结构，如图所示：

![img](3.1.png)<center>*redisObject和sdshdr*</center>

 

使用embstr进行编码的好处：

**a.**   embstr 编码将创建字符串对象所需的内存分配次数从 raw 编码的两次降低为一次。

**b.**   释放 embstr 编码的字符串对象只需要调用一次内存释放函数， 而释放 raw 编码的字符串对象需要调用两次内存释放函数。

**c.**   因为 embstr 编码的字符串对象的所有数据都保存在一块连续的内存里面，所以这种编码的字符串对象比起 raw 编码的字符串对象能够更好地利用缓存带来的优势。

 

除了整型之外，使用long double类型表示的浮点数在Redis中也是作为字符串值来保存的：如果我们要保存一个浮点数到字符串对象里面，那么程序会先将这个浮点数转换成字符串值，然后再保存起转换所得的字符串值。在有需要的时候，程序会将保存在字符串对象里面的字符串值转换回浮点数值，执行某些操作，然后再将执行操作所得的浮点数值转换回字符串值，并继续保存在字符串对象里面。

字符串对象保存各类型值的编码方式：

| 值                                                           | 编码          |
| ------------------------------------------------------------ | ------------- |
| 可以用 long 类型保存的整数                                   | int           |
| 可以用 long double 类型保存的浮点数                          | embstr或者raw |
| 字符串值，或者因为长度太大而没办法用long类型表示的整数，又或者因为长度太大而没办法用long double类型表示的浮点数 | embstr或者raw |

 

int 编码的字符串对象和 embstr 编码的字符串对象在条件满足的情况下， 会被转换为 raw 编码的字符串对象。

**1)**   对于 int 编码的字符串对象来说， 如果我们向对象执行了一些命令， 使得这个对象保存的不再是整数值， 而是一个字符串值， 那么字符串对象的编码将从 int 变为 raw 。

**2)**   对embstr 编码的字符串对象，Redis没有编写任何相应的修改程序 （只有 int 编码的字符串对象和 raw 编码的字符串对象有这些程序）， 所以 embstr 编码的字符串对象实际上是**只读**的。当我们对 embstr 编码的字符串对象执行任何修改命令时，程序会先将对象的编码从 embstr 转换成 raw ，然后再执行修改命令； 因为这个原因，embstr编码的字符串对象在执行修改命令之后，会变成一个raw编码的字符串对象。

 

#### 2.2  列表对象

列表对象的编码可以是 ziplist 或者 linkedlist 。

ziplist 编码的列表对象使用压缩列表作为底层实现， 每个压缩列表节点（entry）保存了一个列表元素。当执行命令：RPUSH numbers 1 “three” 5时，如下图所示：

​     
![img](4.png)<center>*ziplist编码的numbers列表对象*</center>

 

当使用双向链表作为底层实现，每个双向链表节点（node）都保存了一个字符串对象，而每个字符串对象都保存了一个列表元素。

​     
![img](5.png)<center>*linkedlist编码的numbers列表对象*</center>



注意：

**1.**   linkedlist 编码的列表对象在底层的双端链表结构中包含了多个字符串对象， 这种嵌套字符串对象的行为在稍后介绍的哈希对象、集合对象和有序集合对象中都会出现， 字符串对象是 Redis 五种类型的对象中唯一一种会被其他四种类型对象嵌套的对象。

**2.**   图中所示StringObject结构，其实是一种简化，真实情况下的结构应该是如下图：

![img](5.1.png)<center>*StringObject真实结构*</center>


 

当列表对象可以同时满足以下两个条件时， 列表对象使用 ziplist 编码：

**1.**   列表对象保存的所有字符串元素的长度都小于 64 字节；

**2.**   列表对象保存的元素数量小于 512 个；

不能满足这两个条件的列表对象需要使用 linkedlist 编码。

对于使用ziplist编码的列表对象来说，当使用ziplist编码所需的两个条件的任意一个不能被满足时，对象的编码转换操作就会被执行：原本保存在压缩列表里的所有列表元素都会被转移并保存到双端链表里面，对象的编码也会从 ziplist 变为 linkedlist 。

 

#### 2.3  哈希对象

哈希对象的编码可以是 ziplist 或者 hashtable 。

ziplist 编码的哈希对象使用压缩列表作为底层实现， 每当有新的键值对要加入到哈希对象时， 程序会先将保存了键的压缩列表节点推入到压缩列表表尾， 然后再将保存了值的压缩列表节点推入到压缩列表表尾。

当依次执行命令：

HSET testH name “Tom” 

HSET testH age 25 

HSET testH career “Programmer”

结构如下图所示。

​     
![img](6.png)<center>*ziplist编码的testH对象*</center>


其中上图中的压缩列表结构如下表所示：

​     
![img](7.png)<center>*压缩列表结构*</center>




当使用hashtable 编码时，哈希对象使用字典作为底层实现，哈希对象中的每个键值对都使用一个字典键值对来保存：

**1.**   字典的每个键都是一个字符串对象，对象中保存了键值对的键；

**2.**   字典的每个值都是一个字符串对象，对象中保存了键值对的值。

上述testH对象的结构如下：

​     
![img](8.png)<center>*hashtable编码的testH哈希对象结构*</center>

dict结构也进行了简化，详细图如下：

![img](9.png)<center>*dict结构*</center>




当哈希对象可以同时满足以下两个条件时， 哈希对象使用 ziplist 编码：

**1.**   哈希对象保存的所有键值对的键和值的字符串长度都小于 64 字节；

**2.**   哈希对象保存的键值对数量小于 512 个；

不能满足这两个条件的哈希对象需要使用 hashtable 编码。

对于使用 ziplist 编码的列表对象来说， 当使用 ziplist 编码所需的两个条件的任意一个不能被满足时，对象的编码转换操作就会被执行：原本保存在压缩列表里的所有键值对都会被转移并保存到字典里面，对象的编码也会从 ziplist 变为hashtable。

 

#### 2.4  集合对象

集合对象的编码可以是 intset 或者 hashtable 。

intset 编码的集合对象使用整数集合作为底层实现， 集合对象包含的所有元素都被保存在整数集合里面。

当执行命令:SADD numbers 1 3 5后，结构如下图：

​     
![img](10.png)<center>*intset编码的numbers集合对象*</center>



如果使用hashtable 编码，集合对象使用字典作为底层实现，字典的每个键都是一个字符串对象，每个字符串对象包含了一个集合元素，而字典的值则全部被设置为NULL。

如果执行命令：SDD fruits “apple” “banana” “cherry”后，如下图：

​     
![img](11.png)<center>*hashtable编码的fruits集合对象*</center>


 

当集合对象可以同时满足以下两个条件时， 对象使用intset编码：

**1.**   集合对象保存的所有元素都是整数值；

**2.**   集合对象保存的元素数量不超过512个；

不能满足这两个条件的集合对象需要使用hashtable编码。

 

#### 2.5  有序集合对象

有序集合的编码可以是 ziplist 或者 skiplist 。

ziplist 编码的有序集合对象使用压缩列表作为底层实现，每个集合元素使用两个紧挨在一起的压缩列表节点来保存， 第一个节点保存元素的成员（member）， 而第二个元素则保存元素的分值（score）。

压缩列表内的集合元素按分值从小到大进行排序，分值较小的元素被放置在靠近表头的方向， 而分值较大的元素则被放置在靠近表尾的方向。

如果执行命令：ZADD price 8.5 apple 5.0 banana 6.0 cherry，那么ziplist结构如下图：

​     
![img](12.png)<center>*ziplist编码的有序集合对象*</center>

压缩列表结构如下：

​     
![img](13.png)<center>*压缩列表结构*</center>

 

如果使用skiplist 编码，那么有序集合对象使用 zset 结构作为底层实现， 一个 zset 结构同时包含一个字典和一个跳跃表，代码结构如下：

​     
![img](14.png)<center>*zset代码结构*</center>


 

假设price对象使用skiplist编码，那么结构如下：

​     
![img](15.png)<center>*skiplist编码的有序集合对象*</center>


 

其中zset结构如下：

​     
![img](16.png)<center>*zset结构（包括字典与跳跃表）*</center>



 

**1.**   zset结构中的zsl跳跃表按分值从小到大保存了所有集合元素。通过这个跳跃表，程序可以对有序集合进行范围型操作，比如ZRANK（查找排名）、ZRANGE（返回给定索引范围内的元素）等命令就是基于跳跃表API来实现的。

**2.**   zset 结构中的 dict 字典为有序集合创建了一个从成员到分值的映射。 通过这个字典，程序可以用 O(1) 复杂度查找给定成员的分值，ZSCORE（查询分值）命令就是根据这一特性实现的，而很多其他有序集合命令都在实现的内部用到了这一特性。

**3.**   有序集合每个元素的成员都是一个字符串对象， 而每个元素的分值都是一个 double 类型的浮点数。 

**4.**   虽然 zset 结构同时使用跳跃表和字典来保存有序集合元素， 但这两种数据结构都会通过指针来共享相同元素的成员和分值， 所以同时使用跳跃表和字典来保存集合元素不会产生任何重复成员或者分值， 也不会因此而浪费额外的内存。

 

疑问：为什么要同时使用跳跃表和字典?

回答：效率。

如果我们只使用字典来实现有序集合，那么可以以 O(1) 复杂度查找成员。但是，因为字典的无序特性，所以每次在执行范围型操作（ZRANK、ZRANGE等），程序都需要对字典保存的所有元素进行排序，完成这种排序需要至少 O(Nlog N) 时间复杂度，以及额外的 O(N) 内存空间（因为要创建一个数组来保存排序后的元素）。

另一方面，如果我们只使用跳跃表来实现有序集合，那么跳跃表执行范围型操作的所有优点都会被保留，但因为没有了字典，所以根据成员查找分值这一操作的复杂度将从O(1)上升为O(log N)。

 

当有序集合对象可以同时满足以下两个条件时， 对象使用 ziplist 编码：

**1.**   有序集合保存的元素数量小于 128 个；

**2.**   有序集合保存的所有元素成员的长度都小于 64 字节；

不能满足以上两个条件的有序集合对象将使用 skiplist 编码。

对于使用ziplist编码的有序集合对象来说，当使用ziplist编码所需的两个条件中的任意一个不能被满足时，程序就会执行编码转换操作，将原本储存在压缩列表里面的所有集合元素转移到zset结构里面，并将对象的编码从ziplist改为 skiplist。

 

### 3  对象处理

#### 3.1 类型检查与命令多态

Redis 中用于操作键的命令基本上可以分为两种类型。

**1)**    可以对任何类型的键执行，比如说DEL、EXPIRE、RENAME、TYPE等等。

**2)**    只能对特定键执行，例如：SET、HSET、RPUSH、SADD、ZADD等等。

 

**1.**   类型检查的实现：

在执行一个类型特定的命令之前，Redis会先检查输入键的类型是否正确， 然后再决定是否执行给定的命令。类型特定命令所进行的类型检查是通过 redisObject结构的type属性来实现的，过程如下：

**1)**    在执行一个类型特定命令之前，服务器会先检查输入数据库键的值对象是否为执行命令所需的类型，如果是的话，服务器就对键执行指定的命令；

**2)**    否则，服务器将拒绝执行命令，并向客户端返回一个类型错误。

 

**2.**   多态命令的实现

Redis除了会根据值对象的类型来判断键是否能够执行指定命令之外，还会根据值对象的编码方式，选择正确的命令实现代码来执行命令。

例如，列表对象有ziplist和linkedlist两种编码可用，如果我们对一个键执行LLEN命令，那么服务器除了要确保执行命令的是列表键之外，还需要根据键的值对象所使用的编码来选择正确的 LLEN 命令实现：

**1)**    如果列表对象的编码为ziplist ，那么说明列表对象的实现为压缩列表， 程序将使用ziplistLen函数来返回列表的长度；

**2)**    如果列表对象的编码为linkedlist，那么说明列表对象的实现为双端链表，程序将使用 listLength 函数来返回双端链表的长度；

所以，借用面向对象方面的术语来说，我们可以认为LLEN命令是多态的： 只要执行LLEN命令的是列表键，那么无论值对象使用的是ziplist编码还是linkedlist编码，命令都可以正常执行。

实际上，我们可以将DEL、EXPIRE、TYPE等命令也称为多态命令，因为无论输入的键是什么类型，这些命令都可以正确地执行。这些命令和LLEN命令的区别在于，前者是基于类型的多态：一个命令可以同时用于处理多种不同类型的键，而后者是基于编码的多态：一个命令可以同时用于处理多种不同编码。

 

#### 3.2  内存回收

因为C语言并不具备自动的内存回收功能， 所以Redis在自己的对象系统中构建了一个引用计数技术实现的内存回收机制，通过这一机制，程序可以通过跟踪对象的引用计数信息，在适当的时候自动释放对象并进行内存回收。

在redisObject结构中，除了type，encoding，ptr三者外，还是用了引用计数器，如下图：

​     
![img](17.png)<center>*redisObject代码示意图*</center>

 

对象的引用计数信息会随着对象的使用状态而不断变化：

**1)**    在创建一个新对象时，引用计数的值会被初始化为1；

**2)**    当对象被一个新程序使用时，它的引用计数值会被增1；

**3)**    当对象不再被一个程序使用时，它的引用计数值会被减1；

**4)**    当对象的引用计数值变为 0 时，对象所占用的内存会被释放。

 

#### 3.3  对象共享

对象的引用计数属性，还带有对象共享的作用。假设键A创建了一个包含整数值 100 的字符串对象作为值对象，如果要创建一个B，同时也包含整数值100的字符串对象作为值。那么相比于为键B新创建一个字符串对象的做法来说，**让键A和键B共享一个值对象更节约内存**，步骤如下：

**1)**    将数据库键的值指针指向一个现有的值对象；

**2)**    将被共享的值对象的引用计数增1。

 

可以使用OBJECT REFCOUNT命令查看对象的引用次数。

比如说， 假设数据库中保存了整数值 100 的键不只有键 A 和键 B 两个， 而是有一百个，那么服务器只需要用一个字符串对象的内存就可以保存原本需要使用一百个字符串对象的内存才能保存的数据。

 

目前来说，Redis会在初始化服务器时，创建10000（可配置）个字符串对象，这些对象包含了从0到9999的所有整数值，当服务器需要用到值为0到9999的字符串对象时，服务器就会使用这些共享对象，而不是新创建对象。

 

受到复杂度的限制，Redis只对保存**整数值**的字符串对象进行共享。

 

#### 3.4 空转时长

redisObject结构包含的最后一个属性为lru属性，该属性记录了对象最后一次被命令程序访问的时间：

​     
![img](18.png)<center>*redisObject代码示意*</center>



用OBJECT IDLETIME命令可以显示出键的空转时长（通过计算当前时间和对象的lru时间计算得出）。值得注意的是：OBJECT IDLETIME命令访问键的时候，不会更新lru时间。

空转时长的主要作用是： 如果服务器打开了maxmemory选项， 并且服务器用于回收内存的算法为volatile-lru或者allkeys-lru，那么当服务器占用的内存数超过了maxmemory选项所设置的上限值时，空转时长较高的那部分键会优先被服务器释放，从而回收内存。

备注：

volatile-lru:根据LRU算法删除设置了超时属性（expire）的键，直到腾出足够空间为止。

allkeys-lru:根据LRU算法删除键，不管数据有没有设置超时属性，直到腾出足够空间为止。

 

 

其他淘汰策略：

**1.**   noeviction：当内存使用超过配置的时候会返回错误，不会删除任何键 

**2.**   allkeys-random：加入键的时候如果过限，从所有key随机删除

**3.**   volatile-random：加入键的时候如果过限，从过期键的集合中随机驱逐 

**4.**   volatile-ttl：从配置了过期时间的键中删除最早要过期的键 

**5.**   volatile-lfu：从所有配置了过期时间的键中删除使用频率最少的键 

**6.**   allkeys-lfu：从所有键中删除使用频率最少的键

 
