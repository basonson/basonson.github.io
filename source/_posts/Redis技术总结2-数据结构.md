---
title: Redis技术总结2-数据结构
date: 2022-02-14 14:15:56
tags:
    - 数据结构
categories:
    - 数据库
    - NoSQL
    - Redis
---

### 1.  简单动态字符串

Redis虽然是基于C语言，但并没有使用C语言中的字符串。而是构建了一个名为简单动态字符串（Simple Dynamic String, SDS）的类型，并将SDS作为Redis默认的字符串表示。

在Redis中，有一种情况会使用C语言的字符串，就是常量字符串。除此之外，都会使用SDS来表示字符串值。同时，SDS还会被用作缓冲区：AOF中的缓冲区，以及客户端状态中的输入缓冲区都是用SDS实现的。

例如：Redis 所有的数据结构都是以唯一的 key 字符串作为名称，然后通过这个唯一 key 值来获取相应的 value 数据。不同类型的数据结构的差异就在于 value 的结构不一样。但是这个key使用的结构，都是字符串类型。

 

#### 1.1  SDS的定义

每个sdshdr结构表示一个SDS：

![img](1.png)<center>*SDS代码示意*</center>


![img](2.png)<center>*SDS结构示意*</center>


SDS遵循了C语言以’\0’结尾的惯例，保存空字符的一个长度空间不计算在len值里，并且为’\0’分配额外的空间，以及其他各种操作，都是有SDS函数完成，对使用者是透明的。


#### 1.2  SDS与C字符串的区别

**a.**   **O(1)复杂度获取字符串长度**

在C语言中，如果需要获取一个字符串长度，必须对字符串进行遍历，那么时间复杂度为O(N)。

但是在SDS中，因为有len的存在，所以获取长度的复杂度为O(1)。

**注意：在Redis中到处充斥着看似冗余，其实大大提高效率的方法。**

**b.**   **避免缓冲区溢出**

在C语言中，执行字符串深度融合操作strcat(s1,s2)时，默认s1的空间足够长来容纳s2。如果曾经写过java的程序员（产品经理）忘记了为s1分配足够的空间，那么会导致修改之后s1的数据，会占据原先跟他相邻的空间，导致将其他程序的数据覆盖。

在SDS中，需要对值进行修改时，API会检查SDS的空间是否满足修改所需要求，如果不满足，API会自动将SDS空间进行扩展，之后执行实际的修改操作。所以用户不需进行手动修改，也不会发生缓冲区溢出问题。

**c.**   **减少内存重分配次数**

在C语言中，字符串的底层实现是一个N+1个字符长度的数组（额外的一个字符空间保存’\0’）。所以每次增长或缩短C字符串，程序都会对保存这个字符串的数组进行一次内存重分配的操作（拼接前首先扩展空间，截断后需要释放空间）。内存重分配涉及复杂的算法，而且可能需要执行系统调用，所以通常是个比较耗时的操作。在极度追求速度、数据修改频繁的Redis中，会对性能造成影响。

在SDS中，实现了**空间预分配**和**惰性空间释放**两种优化策略。

**1)    空间预分配**

当需要对SDS进行空间扩展的时候，程序不仅为SDS分配所需必要空间，同时也会分配额外的使用空间。

规则1：如果对SDS进行修改之后，SDS的长度（len值）小于1M，那么程序分配和len值同样大小的未使用空间。此时SDS的len值和free值相同。

规则2：如果对SDS修改之后，SDS长度将大于1M，那么程序会分配1M的未使用空间。

**2)    惰性空间释放**

当SDS的API需要缩短字符串时，程序并不立即使用内存重分配来回收缩短后多出来的字节，而是使用free属性将这些字节的数量记录起来，等待将来使用。

同时，在我们有需要时，也可以真正的释放SDS的未使用空间，所以不用担心惰性空间释放策略会造成内存浪费。

**d.**   **二进制安全**

因为传统C字符串符合ASCII编码，这种编码的操作的特点就是：遇零则止。即，当读一个字符串时，只要遇到’\0’结尾，就认为到达末尾，就忽略’\0’结尾以后的所有字符。因此，如果传统字符串保存图片，视频等二进制文件，操作文件时就被截断了。

SDS的buf被定义为字节数组，因为判断是否到达字符串结尾的依据则是len成员，这意味着它可以存放任何二进制的数据和文本数据，包括’\0’。

同时SDS的API都会以处理二进制的方式处理SDS存放在buf数组里的数据。

**e.**   **兼容部分C字符串函数**

因为SDS同样遵循C语言字符串以’\0’结尾的管理，所以SDS可以重用类似strcasecmp(忽略大小写的比较)和strcat(字符串拼接)等C语言字符串的函数。

 

### 2.  链表

当list类型包含了超过??个元素，或者元素长度超过??字节时，链表会作为列表的底层实现。同时，发布与订阅，慢查询、监视器等功能也使用到了链表。Redis服务器本身还使用链表来保存多个客户端的状态信息，以及使用链表来构建客户端输出缓冲区。

节点使用listNode结构来表示：

​     

![img](3.png)<center>*listNode代码示意*</center>

 

如果使用多个listNode，其实可以组成链表。但为了效率和操作方便，Redis使用list结构来表示链表：

​     

![img](4.png)<center>*list代码示意*</center>

 

 

一个包含3个节点的链表结构如下图所示：

![img](5.png)<center>*链表结构示意*</center>

 

Redis链表的特性有以下几点：

**1)    双端**

通过prev和next指针，获取某个节点的前置节点和后置节点的复杂度都是O(1)。

**2)    非环**

头节点的prev指针和尾结点的next指针都指向NULL,对链表的访问以NULL为终点。

**3)    头尾**

通过head指针和tail指针，程序获取链表头结点和尾结点的复杂度为O(1)。

**4)    长度**

通过len值，程序获取链表中节点数量的复杂度为O(1)。

**5)    多态**

链表节点使用void*指针来保存节点值，可以通过list结构中的dup、free、match三个属性为节点值设置类型特定函数，所以链表可以用于保存各种不同类型的值。

 

### 3.  字典

字典在Redis中的应用非常广泛，比如Redis数据库就是用字典来作为底层实现的，对数据库的增删改查操作也是构建在对字典的操作之上的。除了标识数据库之外，字典也是哈希键的底层实现之一。当哈希键包含的键值对数量多，或者键值对中的元素是较长的字符串时，Redis会使用字典作为哈希键的底层实现。

Redis中的字典包含了哈希表节点、哈希表和字典三个结构

#### 3.1  哈希表节点

哈希表节点使用dicEntry结构表示，如下图：

​     

![img](6.png)<center>*dictEntry代码示意*</center>

 

**1)**    key中保存键。

**2)**    val中保存值。val可以是一个指针，也可以是一个uint64_t的整数或者int64_t的整数。

**3)**    next是指向另一个节点的指针，这个指针可以将多个哈希值相同的键值对连接在一起，解决哈希冲突问题。

#### 3.2  哈希表

哈希表使用dictht结构定义，如下图：

​     

![img](7.png)<center>*dictht代码示意*</center>

 

**1)**    table是一个数组，table中的每一个元素都是只想dictEntry结构的指针，每个dictEntry结构保存着一个键值对。

**2)**    size属性记录了哈希表大小。

**3)**    sizemask始终等于size-1，用于与哈希值一起计算index。

**4)**    used属性记录已有节点的数量。

 

一个哈希表如下图所示：


![img](8.png)<center>*hashht结构示意*</center>

 

#### 3.3  字典

Redis中的字典使用dict结构表示，如下图：

​     

![img](9.png)<center>*dict代码示意*</center>

 

**1)**    type属性是一个指向dictType结构的指针，每个dictType结构保存了一簇用于操作特定类型键值对的函数，Redis会为用途不同的字典设置不同的类型特定函数。

**2)**    privdata属性保存了需要传给那些类型特定函数的可选参数。

**3)**    ht属性是一个包含2个元素的数组，其中每个项都是一个dictht哈希表。一般情况下，字典只使用ht[0]，而ht[1]只有在对ht[0]进行rehash时使用。

**4)**    rehashidx属性记录了rehash目前的进度，如果没有在进行rehash，那么值为-1。


dict结构如下图所示：

​              
![img](10.png)<center>*dict结构示意图*</center>

 

#### 3.4  哈希算法

当要将一个新的键值对添加到字典中时，程序要先根据键计算出哈希值和索引值，然后根据索引值，将包含新键值对的哈希表节点放到哈希表数组的指定索引上面。

Redis计算哈希值和索引值的方法如下：


**1.** 使用字典设定的特定类型的哈希函数，计算键key的哈希值

**hash = dict->type->hashFunction(key);**

**2.** 根据哈希表的sizemask和哈希值，计算出索引值。

//根据情况不同，ht[x]可以是ht[0]或ht[1]

**index=hash & dict->ht[x].sizemask;**

 

Redis使用MurmurHash2算法（目前最新版本是MurmurHash3）来计算键的哈希值。**这个算法的优点在于，即使输入的键是有规律的，算法依然能够给出一个很好的随机分布性**。

 

#### 3.5  哈希冲突

当有2个或2个以上数量的键被分配到哈希表数组的同一个索引上面时，我们称这些键发生了冲突。

Redis的哈希表使用链地址法来解决哈希冲突：即next指针。通过每个哈希表节点的next指针，可以构成一个单向链表，这样被分配到同一个索引上的多个节点可以通过这个链表连接起来，解决了冲突问题。

因为dictEntry节点组成的链表没有指向尾部的指针，所以每次都会将新节点添加到链表的表头位置（复杂度O(1)）。排在其他已有节点的前面。

 

#### 3.6  rehash

随着操作的不断进行，哈希表保存的键值会不断地增多，为了让负载因子维持在一个合理的范围内，程序需要对哈希表的大小进行相应的扩展和收缩。

扩展和收缩哈希表通过rehash操作来完成，步骤如下：

**1)**    为ht[1]分配空间，大小取决于要执行的操作以及ht[0]当前键的数量（ht[0].used的值）：

如果要执行扩展操作，那么ht[1]大小为 第一个大于等于ht[0].used*2的2n。

如果要执行收缩操作，那么ht[1]大小为 第一个大于等于ht[0].used的2n。

**2)**    将保存在ht[0]中的所有键值对rehash到ht[1]上面，即重新计算哈希值和索引值，然后将键值对放置到ht[1]指定的位置上。

**3)**    当ht[0]包含的键值对都迁移到ht[1]时，释放ht[0]，将ht[1]置为ht[0]，并在ht[1]创建一个空白的哈希表，为下一次rehash做准备。

 

#### 3.7  rehash的条件

负载因子=哈希表已存节点数量/哈希表大小

**1)**    当哈希表的负载因子小于0.1时，程序自动开始对哈希表执行收缩操作。

**2)**    当服务器没有执行BGSAVE或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于1，程序开始对哈希表执行扩展操作。

**3)**    当服务器正在执行BGSAVE或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于5，程序开始对哈希表执行扩展操作。

为什么正在执行命令时负载因子被扩大到5？

因为在执行BGSAVE和BGREWRITEAOF命令时，Redis需要创建当前服务器进程的子进程，而大多数操作系统都采用**写时复制技术**来优化子进程的使用效率，所以在子进程存在期间，服务器会提高负载因子，尽量避免在此期间对哈希表进行扩展操作，也就避免写入操作，最大限度节约内存。

 

#### 3.8  渐进式rehash

将ht[0]中的键值rehash到ht[1]中这个过程并不是一次性完成的，而是一个多次的、渐进的完成过程。因为ht[0]中存储的键值数量有可能很多，如果一次性完成，可能会导致服务暂时停止响应。

渐进式rehash的步骤：

**1)**    为ht[1]分配空间。

**2)**    将rehashidx置为0，表示rehash开始。

**3)**    在rehash期间，每次对字典执行添加、删除、查找、更新操作时，程序除了执行指定的操作以外，还会顺带将ht[0]哈希表在rehashidx索引上的所有键值对rehash到ht[1]，当rehash工作完成后，程序将rehashidx属性的值增加1。

**4)**    随着字典操作的不断进行，最终在某个时间点，ht[0]上面的所有键值对都会被移动至ht[1]上面，这是将rehashidx的值设置为-1，标识rehash操作已经完成。

渐进式rehash的要注意的点：

**1)**    渐进式rehash避免了集中rehash带来的庞大计算量和宕机风险。

**2)**    在渐进式rehash过程中，字典的删除、查找、更新操作，会同时在两个ht上进行。例如如果查找一个键，程序会先在ht[0]中进行查找，如果没找到，那么在ht[1]中进行查找。

**3)**    在渐进式rehash过程中，字典的新增操作，一律会被保存到ht[1]中，保证ht[0]只减不增。

 


### 4.  跳跃表

跳跃表（skiplist）是一种有序的数据结构，通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。

Redis只在2个地方使用到了跳跃表：一是有序集合键；二是在集群节点中用作内部数据结构。

Redis 的跳跃表由 zskiplistNode 和 zskiplist 两个结构定义， 其中 zskiplistNode 结构用于表示跳跃表节点， 而 zskiplist 结构则用于保存跳跃表节点的相关信息。如下图：

​     

![img](11.png)<center>*跳跃表结构示意图*</center>



zskiplistNode结构如下图：

​     

![img](12.png)<center>*zskiplistNode代码示意图*</center>

 

**1)    层（L1,L2,L3,L4…）**

L1表示第一层，L2表示第二层，等等。每个层都带有两个属性：前进指针和跨度。前进指针用于访问位于表尾方向的其他节点，指向其他节点的相同层。而跨度则记录了前进指针所指向节点和当前节点的距离。

跳跃表节点的 level 数组可以包含多个元素，每个元素都包含一个指向其他节点的指针，**程序可以通过这些层来加快访问其他节点的速度**，一般来说，层的数量越多，访问其他节点的速度就越快。

每次创建一个新跳跃表节点的时候， 程序都根据幂次定律 （power law，越大的数出现的概率越小） 随机生成一个介于 1 和 32 之间的值作为 level 数组的大小，这个大小就是层的“高度”。包含层数越高的节点数越少。

层的跨度不是用于遍历，遍历只用前进指针即可完成。跨度用于计算排位：在查找某个节点的过程中，将沿途访问过的所有层的跨度累计起来，得到的结果就是目标节点在跳跃表中的排位。

**2)    后退（BW）指针**

节点中用 BW 字样标记节点的后退指针，它指向位于当前节点的前一个节点。后退指针在程序从表尾向表头遍历时使用。每个节点只有一个后退指针，所以每次智能后退至前一个节点。

**3)    分值（1.0,2.0,3.0…）**

在跳跃表中，节点按各自所保存的分值从小到大排列。分值是一个double类型浮点数。

**4)    成员对象（o1,o2,o3…）**

各个节点中的 o1 、 o2 和 o3 是节点所保存的成员对象。它是一个指针，指向一个字符串对象，字符串对象存着一个SDS值。分值相同的节点会按照成员对象在字典序中的大小进行排序。

 

虽然仅凭跳跃节点就可以组成一个跳跃表，但是通过zskiplist结构可以更方便的对整个跳跃表进行处理，比如快速访问表头节点、表尾结点、节点数量等。zskiplist结构定义如下：

​     

![img](13.png)<center>*zskiplist代码示意图*</center>

 

**1)    header**

指向跳跃表的表头节点

**2)    tail** 

指向跳跃表的表尾节点。

**3)    length** 

记录跳跃表的长度，也即是，跳跃表目前包含节点的数量（表头节点不计算在内）。

**4)    level** 

记录目前跳跃表内，层数最大的那个节点的层数（表头节点的层数不计算在内）。

 

通过4个属性，程序可以在O(1)复杂度内实现表头节点、表尾结点、节点数量、最大高度等。

 

关于跳跃表：

跳跃表的关键在于：关键节点。

当只有一层时，跳表其实是一个链表。如果想要插入数据或者寻找数据，只能逐个遍历比较。但当出现第二层时，第二层的值可以作为关键节点。程序可以在第二层关键节点中进行比较，确定大概位置后，返回第一层确定准确位置。同样，可以建立第三层，作为第二层关键节点的关键节点。

最高层是多少层？当一层中只有2个节点时，就无须再往上创建层级。

哪些节点往上升级？基于大数据人工智能区块链的科学严谨的算法：抛硬币。

复杂度？O(logN)。可以和平衡树相媲美。

 

### 5.  整数集合

整数集合（intset）是集合键的底层实现之一： 当一个集合只包含整数值元素， 并且这个集合的元素数量不多（??）时， Redis 就会使用整数集合作为集合键的底层实现。

整数集合intset结构代码如下：

​     

![img](14.png)<center>*intset代码示意图*</center>

 

1)    contents 数组是整数集合的底层实现，保存着每个元素。各个项在数组中按值的大小从小到大有序地排列， 并且数组中不包含任何重复项。

2)    length 属性记录了 contents 数组的长度。

3)    encoding 属性的值决定而contents数组的真正类型（而不是int8_t）。随着encoding的类型（INTSET_ENC_INT16，INTSET_ENC_INT32，INTSET_ENC_INT64），contents数组类型分别是int16_t（-215-215-1），int32_t（-231-231-1），int64_t（-263-263-1）。 

 

结构示意图如下：

​     

![img](15.png)<center>*intset结构示意图*</center>

虽然contents数组保存的四个整数值中，只有-2675256175807981027是真正需要用int64_t类型来保存的，而其他的1、3、5三个值都可以用int16_t类型来保存，不过根据**整数集合的升级规则**，当向一个底层为int16_t数组的整数集合添加一个int64_t类型的整数值时，整数集合已有的所有元素都会被转换成int64_t类型，所以contents数组保存的四个整数值都是int64_t类型的，不仅仅是-2675256175807981027。

 

#### 5.1  升级

每当我们要将一个新元素添加到整数集合里面，并且新元素的类型比整数集合现有所有元素的类型都要长时，整数集合需要先进行升级（upgrade）， 然后才能将新元素添加到整数集合里面。

升级整数集合并添加新元素共分为三步进行：

**1.**   扩展原有空间。

**2.**   旧元素类型转换，安放位置，按照顺序。

**3.**   新元素添加。

 

假设现在有一个INTSET_ENC_INT16编码的整数集合，里面存着1，2，3。存储位置如下：

| 位   | 0-15 | 16-31 | 32-47 |
| ---- | ---- | ----- | ----- |
| 元素 | 1    | 2     | 3     |

当我们要存储一个32768的数字进入数组时，因为超过了int16_t的范围，所以要对数组进行升级。

**1.**   根据新类型的长度， 以及集合元素的数量（包括要添加的新元素在内）， 对底层数组进行空间重分配（4个int32_t元素长度是128），分配后如下图所示：

| 位   | 0-15 | 16-31 | 32-47 | 48-127 |
| ---- | ---- | ----- | ----- | ------ |
| 元素 | 1    | 2     | 3     | 空     |

**2.**   从后往前（3->2->1），依次将原有的元素放到新的位置上。

| 位   | 0-15 | 16-31 | 32-47 | 48-63 | 64-95   | 96-127 |
| ---- | ---- | ----- | ----- | ----- | ------- | ------ |
| 元素 | 1    | 2     | 3     | 空    | 3（新） | 空     |

 

| 位   | 0-15 | 16-31 | 32-63   | 64-95 | 96-127 |
| ---- | ---- | ----- | ------- | ----- | ------ |
| 元素 | 1    | 2     | 2（新） | 3     | 空     |

 

| 位   | 0-31 | 32-63 | 64-95 | 96-127 |
| ---- | ---- | ----- | ----- | ------ |
| 元素 | 1    | 2     | 3     | 空     |

**3.**   添加新元素。

| 位   | 0-31 | 32-63 | 64-95 | 96-127 |
| ---- | ---- | ----- | ----- | ------ |
| 元素 | 1    | 2     | 3     | 32768  |

**4.**   修改encoding 为INTSET_ENC_INT64，修改length为4。

 

注意：升级后新元素位置在哪？

升级后新元素位置要么在数组最开头，要么在数组最末尾。

 

#### 5.2  升级的好处

**1)    提高灵活性**

虽然不像某语言可以在同一数组中存入不同类型的各种元素，但是整数集合可以通过自动升级完成 int16_t、int32_t或者int64_t类型整数的兼容，而不用担心类型错误。

**2)    节约内存**

虽然可以直接用int64_t类型来存储数组，但是在整数值较小时，会造成内存浪费。整数集合可以保证升级操作仅在有必要时进行，尽量节约内存。

 

#### 5.3  降级

整数集合不支持降级操作， 一旦对数组进行了升级， 编码就会一直保持升级后的状态。

 

 

### 6.  压缩列表

压缩列表（ziplist）是列表键和哈希键的底层实现之一。

 

#### 6.1  压缩列表的构成

压缩列表的组成部分如下：

| zlbytes | zltail | zllen | entry1 | entry2 | …    | entryN | zlend |
| ------- | ------ | ----- | ------ | ------ | ---- | ------ | ----- |
|         |        |       |        |        |      |        |       |

 

压缩列表各组成部分说明：

| 属性    | 类型     | 长度 | 用途                                    |
| ------- | -------- | ---- | --------------------------------------- |
| zlbytes | uint32_t | 4    | 记录整个压缩列表所占用内存字节数        |
| zltail  | uint32_t | 4    | 记录表尾结点距离起始地址有多少字节      |
| zllen   | uint16_t | 2    | 记录压缩列表节点数量                    |
| entryX  | 列表结点 | 不定 | 压缩列表各个节点                        |
| zlend   | uint8_t  | 1    | 固定值0xFF(十进制255)，标记压缩列表末端 |

 

示例如下：

| zlbytes | zltail | zllen | entry1 | entry2 | entry3 | entry4 | entry5 | zlend |
| ------- | ------ | ----- | ------ | ------ | ------ | ------ | ------ | ----- |
| 0xd2    | 0xb3   | 0x5   |        |        |        |        |        | 0xFF  |
| P       |        |       |        |        |        |        | P+179  |       |



**1)**    zlbytes属性的值为0xd2（十进制210），表示压缩列表的总长为210字节。

**2)**    zltail属性的值为0xb3（十进制179），这表示如果我们有一个指向压缩列表起始地址的指针p，那么只要用指针p加上偏移量179，就可以计算出表尾节点entry5 的地址。

**3)**    zllen属性的值为0x5（十进制5），表示压缩列表包含五个节点。

**4)**    zllend属性的值为 0xFF（十进制255），固定值。

 

#### 6.2  压缩列表节点

压缩列表节点可以保存一个字节数组或一个整数值。组成部分如下：

| previous_entry_length | encoding | content |
| --------------------- | -------- | ------- |
|                       |          |         |

 

**1)**    previous_entry_length

previous_entry_length以字节为单位，记录了压缩列表中**前一个节点的长度**。

程序可以通过指针运算，根据当前节点的起始地址来计算前一个节点的起始地址。压缩列表的表尾向表头的遍历操作就是通过这一原理实现的。

**2)**    encoding

encoding记录了节点的content属性所保存的类型及长度。

**3)**    content属性

content属性负责保存节点的值，节点值可以是一个字节数组或者整数， 值的类型和长度由节点的encoding属性决定。

举例如下：

| previous_entry_length | encoding | content        |
| --------------------- | -------- | -------------- |
| …                     | 00001011 | “hello  world” |

**a)**    编码的最高两位 00 表示节点保存的是一个字节数组；

**b)**   编码的后六位 001011 记录了字节数组的长度 11 ；

**c)**    content 属性保存着节点的值 "hello world" 。

 

| previous_entry_length | encoding | content |
| --------------------- | -------- | ------- |
| …                     | 11000000 | 10086   |

**a)**    编码 11000000 表示节点保存的是一个 int16_t 类型的整数值；

**b)**   content 属性保存着节点的值 10086 。
