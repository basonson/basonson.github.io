---
title: MySQL技术总结-3
date: 2022-02-09 11:37:42
tags:
    - 索引
    - B+树
    - explain
categories:
    - 数据库
    - MySQL
---

### 1.  架构图

![img](1.png)

 

存储引擎是数据的不同的存储的方式。

**1)**    存储方式

存储位置，存储形式等等

例如：

InnoDB中索引文件和数据文件是存储在一个文件中的。（frm存储表结构，idb存储索引和数据）

MyISAM引擎中索引文件和数据文件是分开存放的。（frm存储表结构，MYD存储数据，MYI存储索引）

Memory引擎的数据是存储在内存中的。

**2)**    事务

事务型引擎InnoDB和非事务型引擎MyISAM。

**3)**    锁。

InnoDB支持表锁行锁，MyISAM支持表锁。。

**4)**    索引

InnoDB的索引叶子节点存储数据，而MyISAM存储地址。

**5)**    外键

InnoDB支持外键，MyISAM不支持。

 

### 2.  索引

索引（在MySQL中也叫做键-key），是存储引擎用于快速找到记录的一种数据结构。索引优化是查询性能优化的最有效的手段。

 

#### 2.1.   为什么要设计索引

**加快数据访问速度。**

数据是存储在文件中，如果我们顺序访问文件，那么速度很慢。如果我们在查询前，能够迅速的知道，应该访问文件的第几行，就会大大提升速度。

 

#### 2.2.   如何设计索引

数据顺序存储在文件中，索引顺序存储在索引文件中。

要确定的信息：

**1.**    索引值；

**2.**    文件（索引文件与数据文件）的地址；

**3.**    偏移量。

但这种设计还是会慢。因为当数据量大的时候，读取索引文件同样会很慢。

 

#### 2.3.   索引的数据结构

数组，哈希，二叉树、红黑树、b树，b+树

官网写的是b树但其实是b+树。

索引是在存储引擎层而不是服务器层实现，所以提到索引是跟引擎相关联的。索引的类型包括：B-Tree索引，哈希索引，空间数据索引，全文索引等等。

 

#### 2.4.   索引实现-哈希

哈希索引基于哈希表实现，是Memory引擎的默认索引类型，也只有Memory显示的支持哈希索引。（Memory引擎也支持B-Tree索引）

假设有一个表：

 

| oa      | name   |
| ------- | ------ |
| guoc12  | 郭超   |
| cuizg1  | 崔志广 |
| wanghg6 | 王怀刚 |
| zhaijl1 | 翟静林 |
| liuzc24 | 刘作成 |

 

哈希函数f()返回如下值：

f(‘guoc12’)=1234;

f(‘cuizg1)=5678;

f(‘wanghg6)=2345;

f(‘zhaijl1)=8765;

f(‘liuzc24)=5612;

 

索引存储的形式如下(不一定是表，最终形式应该是哈希+链表)：

| 槽(slot) | 值(value)       |
| -------- | --------------- |
| 1234     | 指向第1行的指针 |
| 2345     | 指向第3行的指针 |
| 5612     | 指向第5行的指针 |
| 5678     | 指向第2行的指针 |
| 8765     | 指向第4行的指针 |

 

索引存储时按照槽值的顺序存储，但是数据行不是。如果查询：select * from table where oa = ‘zhaijl1’。MySQL先计算‘zhaijl1’的哈希值，f(‘zhaijl1’)=8765，所以MySQL在索引中找到8765，根据值找到指向第4行的指针，最后一步是比较第4行的oa是否为zhaijl1，以确保该行就是要查找的行。

 

哈希索引的限制是：

**1.**    哈希索引只包含哈希值和行指针，而不是存储字段值，所以不能使用索引中的值来避免读取行。

**2.**    哈希索引数值并不是按照索引值顺序存储的，所以无法用于排序。

**3.**    哈希索引也不支持部分索引列匹配查找，因为哈希索引是用索引列的全部内容计算哈希值。

**4.**    哈希索引只支持等值比较查询，包括=，IN，<=>（比较操作符<=>表示NULL安全的等价比较。这个比较操作符执行等价比较，和=操作符类似，但是如果两个操作数都是NULL，会返回1，而不是返回NULL；如果其中一个操作数是NULL,会返回0，而不是返回NULL）。不支持任何形式的范围查询。

**5.**    当出现哈希冲突时，访问哈希索引上的数据时，存储引擎必须遍历链表中所有行指针，逐行比较，直到找到所有符合条件的行。

**6.**    如果哈希冲突很高，一些索引维护操作的代价也会很高。

 

注意：

**1.**    **自适应哈希索引**

InnoDB引擎有一个功能叫自适应哈希索引（adaptive hash index），当InnoDB注意到某些索引值被使用的特别频繁时，他会在内存中基于B-Tree索引之上再创建一个哈希索引。这样就会让B-Tree索引也具有哈希索引的优点，比如快速查找。这是一个完全自动的内部的行为，用户无法控制或者配置，不过如果有必要可以关闭该功能。

**2.**    **创建自定义哈希索引**

思路：创建一个新列，保存哈希索引值。但与真正的哈希索引不同，因为还是用B-Tree进行查找，它使用的是哈希值而不是键本身进行索引查找。

例如存储url时，如果用B-Tree建立索引，会造成索引内容很大，例如：

select id from table where url = ‘http://www.baidu.com/’

这时可以删除原先url列上的索引，新增一个被索引的url_crc列，使用CRC32函数做哈希，如下：

select id from table where url_crc = CRC32(‘http://www.baidu.com/’) and url = ‘http://www.baidu.com/’

MySQL优化器会使用这个选择性很高而体积很小的基于url_crc列的索引来完成查找。（相对于用完整的url字符串查询，速度提升非常大）

如果采用这种方式，不能使用SHA1()或者MD5()做哈希函数因为这两个函数产生的哈希值，虽然能够避免哈希冲突，但是是非常长的字符串，如果作为索引会类似uuid，浪费大量空间，也会比较慢。

为什么要包含and url = ‘http://www.baidu.com/’这个查询条件，因为要解决哈希冲突。如果不包含这个条件，只用url_crc查询，一旦出现哈希冲突，会造成查询返回多条记录。

除了CRC32()之外，还可以使用FNV64()作为哈希函数（哈希值为64位，速度快，冲突要比CRC32少很多）。

 

#### 2.5.   索引实现-二叉树与红黑树

树形结构是最常见的数据结构之一。

树(Tree)：每个子节点有多棵子树。

二叉树（Binary Tree）：每个节点最多只有左右两棵子树。

二叉搜索树(Binary Search Tree)：每个节点左子树均小于根节点值，右子树均大于根节点值。

二叉平衡搜索树(AVL，发明者名字缩写)：自平衡，二叉搜索树，并且每个节点左右子树高度差不超过1。（查询速度很快，但是增删速度很慢）

红黑树(Red Black Tree)：自平衡，最高不超过最低高度的2倍即可。（对查找和增删的性能做了平衡）

**无论二叉树还是红黑树，都因为树的深度过高而搞成io变多，影响数据的读取的效率。**

B树(Balance Tree)：任何节点子树的高度差都小于1。多个分支的排序树，降低深度。

 

 

![img](2.png)

 

提高速度的关键：减小I/O次数；减少I/O量。

 

#### 2.6.   索引实现-B树

每个节点放置degree-1个数据，可以在每个节点保存一页的数据。

如下图所示：

 

![img](3.png)

 

说明：

每个节点占用一个磁盘块，一个节点上有2个升序排序的关键字和3个指向子树根节点的指针，指针存储的是子节点所在磁盘块的地址。2个关键字划分成的三个范围域对应3个指针指向的子树的数据的范围域。以根节点为例，关键字为16和34，P1指针指向的子树的数据范围小于16。P2指针指向的子树的数据范围为16-34。P3指针指向的子树的数据范围大于34。

查找关键字的过程：

根据根节点找到磁盘块1。读入内存（磁盘I/O操作1次）

比较关键字28在区间16-34，找到磁盘块1的指针P2。

根据P2指针找到磁盘块3，读入内存（磁盘I/O操作2次）

 

一个磁盘块就是一个页。一个数据块是16k。

 

3层的B树可以存储多少数据？

假设一个data是1kb，那么一个磁盘块里可以放16个data也就是16条数据（假设剩余不占空间）。那3层就是16*16*16也就是4096条数据。

为什么3层B树只能存4000条数据？空间浪费在哪了---浪费在data了。

 

#### 2.7.   索引实现-B+树

非叶节点不存data。如下图所示：

![img](4.png)

 

说明：在B+树上有2个头指针，一个指向根节点，另一个指向关键字最小的叶子节点。而且所有的叶子节点（即数据节点）之间是有一种链式的环结构。因此可以对B+树进行2种查找运算：一种是对于主键的范围查找和分页查找；另一种是从根节点开始，进行随机查找。

优化器自己决定是从根节点查找还是从叶子节点头查找。

数据在插入时就做好了排序。

 

假设一个指针+一个键值是10字节，那么一个数据库16k可以存储1600条数据。第二层也是1600。第三层是16。那么三层的数据量是1600*1600*16 = 40960000条数据。

 

问题：MySQL里的B+树是几层（深度）。

3层或者4层取决于当前的数据量。

尽可能让16k存储更多的key值。用当前数据块的总大小（16k）除以key值的大小。得出每个块所存数据的多少。然后根据表里的数据量决定是3层还是4层。所以索引越小越好。

 

前缀索引：不拿字段的所有值当索引，而只拿前n个字符当做索引（left(column_name,3), column_name(3)）。

 

3层B+树可以支撑千万级别的数据量。具体数字需要看索引大小->阶。

 

#### 2.8.   索引的优点

索引按照顺序存储数据，所以MySQL可以直接用索引进行ORDER BY和GROUP BY操作。同时因为索引是有序的， 所以该行相关的列值都会存储在一起。最后，因为索引中存储了实际的列值，查询只是用索引就能完成全部查询返回全部结果。

索引的三个优点：

**1.**    索引大大减少了服务器需要扫描的数据量。

**2.**    索引可以帮助服务器避免排序和临时表。

**3.**    索引可以将随机I/O变为顺序I/O。

 

索引并不总是最好的解决方案。当索引帮助存储引擎快速查找到记录带来的好处大于其带来的额外工作时，索引才是有效的。对于非常小的表，大部分情况下简单地全表扫描更高效。对于中到大型表，索引就非常有效。对于特大型的表，建立和使用索引的代价会随之增长。

 

### 3.  高性能索引策略

对B-Tree索引来说，只有如下类型的匹配方式是有效的：

索引匹配方式：

**1.**    全值匹配

和索引中的所有列进行匹配。

select * from table where name = ? and age = ? and pos = ? 

**2.**    匹配最左前缀

只使用索引的前N列。

select * from table where name = ?

select * from table where name = ? and age = ?

**3.**    匹配列前缀

只使用某一列值的开头部分。

select * from table where name like ‘J%’

**4.**    匹配范围值

索引第一列在某个范围之间。

select * from table where name > ‘Mary’

**5.**    精确匹配某一列并范围匹配另一列

第一列全匹配，第二列范围匹配。

select * from table where name = ? and age > ?

select * from table where name = ? and age > ? and pos = ?

**6.**    只访问索引的查询

索引覆盖。只用索引值就可以返回查询结果。

select name,age,pos from table where name = ? and age = ? and pos = ?

 

注意：

**1.**    如果不是按照索引的最左列开始查找，那么无法使用索引。

select * from table where pos = ?

select * from table where age= ?

select * from table where name like ‘%J’

**2.**    不能跳过索引中的列。

select * from table where name = ? and pos = ?

只能使用name作为索引进行查询。

**3.**    如果查询中使用了某个列的范围查询，则其右面的所有列都无法使用索引优化查找。

select * from table where name = ? and age > ? and pos = ?

只能使用name和age做索引进行查询。

 

#### 3.1.   独立的列

独立的列指的是索引列不能是表达式的一部分，也不能是函数的参数。如果查询中的列不是独立的，MySQL不会使用索引。

select * from table where name + 1 = 30

select * from table where TO_DAYS(CURRENT_DATE) – TO_DAYS(date_col) > 10

 

#### 3.2.   索引选择性和前缀索引

索引选择性是指：不重复的索引值（也称为基数）和数据表的记录总数（#T）的比值，范围从1/#T到1之间。索引的选择性越高则查询效率越高，因为选择性高的索引可以让MySQL在查找时过滤掉更多的行。唯一索引的选择性是1，性能是最好的。

前缀索引指的是当索引列字符数很多时，会让索引变得大而且慢，所以可以只将开始的部分字符作为索引，这样可以节约索引空间，提高索引效率。但是会降低索引选择性。

关键在于选择足够长的前缀保证较高的选择性，同时又不能太长（以便节约空间）。前缀的基数应该接近于完整列的基数。

 

前缀索引是一种能使索引更小、更快的有效办法，但另一方面也有缺点：MySQL无法使用前缀索引做ORDER BY和GROUP BY， 也无法使用前缀索引做覆盖扫描。

有时候后缀索引也有用途，例如找到某个域名的所有电子邮件地址。MySQL原生并不支持反向索引，但是可以将字符串翻转后存储，并基于此建立前缀索引。

 

#### 3.3.   多列索引

关于多列索引常见的错误是：为每个列创建独立的索引，或者按照错误的顺序创建多列索引。

在多个列上建立独立的单列索引大部分情况下并不能提高MySQL的查询性能。

在5.0版本之后的MySQL，如果同时有2个列查询（在此两列上各有一个索引），查询能够同时使用这两个单列索引进行扫描，并将结果进行合并，叫做索引合并策略。

索引合并策略是一种优化的结果，但实际上说明了这个表上的索引建立的比较糟糕。

**1.**    当出现服务器对多个索引做相交操作时（通常有多个and条件），通常意味着需要一个包含所有相关列的多列索引，而不是多个独立的单列索引。

**2.**    当服务器需要对多个索引做联合操作时（通常有多个or条件），通常需要耗费大量CPU和内存资源在算法的缓存、排序和合并操作上，特别是当其中有些索引的选择性不高，需要合并扫描返回的大量数据的时候。

**3.**    优化器不会把这些计算到查询成本中，优化器只关心随机页面读取。这会使得查询的成本被“低估”，导致该执行计划还不如直接走全表扫描。

 

#### 3.4.   选择合适的索引列顺序

最常用的经验：将选择性最高的列放到索引的最前列。

如果有具体的多条件查询，可以用不同条件分别进行查询，将对应条件的结果数量最小的列放在最前。

如果查询语句性能很慢，而不同条件查询出的数量都很多，那么应该从程序角度来尝试修改或取消这种业务的查询。

 

#### 3.5.   聚簇索引

聚簇索引并不是单独的一种索引类型，而是一种数据存储方式。也就是说数据跟索引是不是放在一起。 对InnoDB的主键索引来说，是聚簇索引。对MyISAM来说，是非聚簇索引。

MyISAM和InnoDB都是采用的B+树，但是有区别：

**1.**    MyISAM中，叶子节点存储该行数据的存储地址。

**2.**    InnoDB中，叶子节点直接放该行全部数据

**1)**   InnoDB通过B+树结构对主键创建索引，在叶子节点中存储记录。如果没有主键，那么选择唯一键。如果没有唯一键，那么会生成一个6字节的row_id作为主键。

**2)**   如果创建索引的键是其他字段，那么叶子节点中存储的是该记录的主键，然后再通过主键索引找到对应的记录，这叫做回表。

 

聚簇索引的优点：

**1.**    可以把相关的数据保存到一起。

**2.**    数据访问更快。

缺点：

**1.**    最大限度的提高了I/O密集型应用的性能，但如果全部数据都在内存中，那么访问顺序就不重要了，聚簇索引也就没什么优势了。

**2.**    插入速度严重依赖于插入顺序。按照逐渐顺序插入时加载数据到InnoDB表中速度最快的方式。

**3.**    更新聚簇索引列的代价很高，因为会强制InnoDB将每个被更新的行移动到新的位置。

**4.**    基于聚簇索引的表在插入新行，或者主键被更新导致需要移动行的时候，可能面临页分裂的问题。

**5.**    聚簇索引可能导致全表扫描变慢，尤其是行比较稀疏或者由于页分裂导致数据存储不连续的时候。

**6.**    二级索引（非聚簇索引）会比想象中大，因为在二级索引的叶子节点包含了引用行的主键列。

**7.**    二级索引访问需要两次索引查找，而不是一次。

 

每增加一个索引就是一棵树。InnoDB主键索引树中叶子节点存的是该行全部数据，二级索引树中叶子节点存储的是主键值。这意味着如果通过二级索引查找行，存储引擎需要找到二级索引的叶子节点获得对应的主键值，然后根据这个值去聚簇索引中查找到对应的行。即：两次B-Tree查找，也即回表。

 

对自增主键来说，插入时要做的操作会少很多（页分裂，页合并），查询也会简单。

 

例如一个表（col1是主键，col2列上有B-Tree索引）：

| 行号 | col1 | col2 |
| ---- | ---- | ---- |
| 0    | 99   | 8    |
| 1    | 12   | 56   |
| 2    | 3000 | 62   |
| …    | …    | …    |
| 9997 | 18   | 8    |
| 9998 | 4700 | 13   |
| 9999 | 3    | 93   |

 

**MyISAM****的数据分布**：MyISAM按照数据插入的顺序存储在磁盘上。主键索引如下图所示：

![img](5.png)

 

col2列索引如下图所示：

![img](6.png)

 

可以看出，MyISAM引擎主键索引和其他索引在结构上并没有区别。主键索引就是一个名为PRIMARY的唯一非空索引。

 

**InnoDB****的数据分布**：InnoDB的主键索引（聚簇索引）如下图所示：

![img](7.png)

 

二级索引col2列索引如下图所示：

![img](8.png)

 

**在InnoDB表中按照主键顺序插入行**

在InnoDB的表中的主键，最好与应用无关(代理主键而非自然主键)，例如自增列，保证数据行是按顺序写入，同时做关联操作的性能会更好。最坏的情况是I/O密集型应用中的UUID主键，他会使得聚簇索引的插入完全变得随机。

 

| 表名          | 行数 | 时间（秒） | 索引大小（MB） |
| ------------- | ---- | ---------- | -------------- |
| userinfo      | 100w | 137        | 342            |
| userinfo_uuid | 100w | 180        | 544            |
| userinfo      | 300w | 1233       | 1036           |
| userinfo_uuid | 300w | 4525       | 1707           |

 

在300w数据量时，uuid主键表的插入顺序变为自增id主键表插入顺序的3倍，索引大小变为1.5倍。

一方面是因为主键字段更长，另一方面是因为页分裂和碎片导致的。

 

![img](9.png)

 

因为主键值是顺序的，所以InnoDB把每一条记录存储在上一条记录的后面。当达到页的最大填充因子（InnoDB默认最大填充因子是页大小的15/16，留出部分空间用于以后修改），下一条记录会写入新的页中。一旦数据按照这种顺序方式加载，主键页就会近似于被顺序的记录填满。这也正是预期的结果。

 

 

![img](10.png)

 

因为新行的键值不一定比之前键值大，所以InnoDB会为他寻找合适的位置，通常是已有数据的中间位置，并且为他分配空间。这会增加很多额外的工作，并且导致分布不够优化。如下：

**1.**   写入目标页可能已经刷新到硬盘并且从缓存中移除，或是还没被加载到缓存中。InnoDB在插入之前不得不先从磁盘读取目标页加载到内存中，这会导致大量的随机I/O。

**2.**   因为写入是乱序的，InnoDB不得不做频繁的页分裂操作，以便为新行分配空间。页分裂会导致移动大量数据，一次插入最少需要修改三个页而不是一个页。

**3.**   由于频繁的页分裂，页会变的稀疏并被不规则的填充，所以最终数据会有碎片。

**4.**   在将随机值插入到聚簇索引之后，也许需要做一次OPTIMIZE TABLE来优化页的填充。

 

所以，使用InnoDB应尽可能地按照主键顺序插入数据，并尽可能的使用单调增加的主键值插入新行。

 

#### 3.6.   覆盖索引

如果一个索引包含（或者说覆盖）所有需要查询的字段的值，那么称为覆盖索引。

索引覆盖可以极大地提升性能：

**1.**    索引条目通常远小于数据行大小，所以如果只读取索引，会极大地减少访问量。将花在数据拷贝上的时间大大减少，同时数据也会更容易的放入内存中。

**2.**    因为索引时按照列值顺序存储，所有对于I/O密集型的范围查询会比随机从磁盘读取每一行数据的I/O要少得多。

**3.**    一些存储引擎例如MyISAM在内存中只缓存索引，数据依赖于操作系统缓存，所以每次访问数据都需要一次系统调用，这可能导致严重的性能问题。

**4.**    由于InnoDB的聚簇索引，如果二级索引能够覆盖查询，可以避免对主键索引的二次查询。

 

但并不是说所有的索引都能实现覆盖索引，例如哈希索引、空间索引、全文索引等等，因为都不存储索引列的值，所以在MySQL当中，只能使用B-Tree索引做覆盖索引。

EXPLAIN解析结果可以看出Extra的值为Using index，表示已经使用了索引覆盖。

 

#### 3.7.   索引下推

索引下推（index condition pushdown ）又叫索引条件推送，简称ICP，在MySQL5.6的版本上推出，用于优化查询。

 

在不使用ICP的情况下，在使用非主键索引进行查询时，存储引擎通过索引检索到数据，然后返回给MySQL服务器，服务器然后判断数据是否符合条件 。

 

在使用ICP的情况下，如果存在某些被索引的列的判断条件时，MySQL服务器将这一部分判断条件传递给存储引擎，然后由存储引擎通过判断索引是否符合MySQL服务器传递的条件，只有当索引符合条件时才会将数据检索出来返回给MySQL服务器 。

 

假如查询中有3个条件，当查询的时候，先将符合条件1的结果取出，放到MySQL服务器，再进行条件2和条件3的筛选。这是未进行索引下推。

假如在查询的时候，一次性将符合条件123的结果全部取出，放到MySQL服务层。这就叫索引下推。

 

索引条件下推优化可以减少回表次数，也可以减少MySQL服务器从存储引擎接收数据的次数。

 

假设一张用户表(user)，其中主要几个字段有：id、name、age、pos。有联合索引（name，age）。

 

**第一种情况：**

``` SQL
SELECT * FROM user WHERE name LIKE '陈%'
```

根据 "最佳左前缀" 的原则，这里使用了联合索引（name，age）进行了查询，性能要比全表扫描肯定要高。

 

**第二种情况：**

``` SQL
SELECT * from user where name = '陈xx' and age=20
```

**1.**    在MySQL 5.6之前版本，会忽略age这个字段，直接通过name进行查询，在(name,age)这课树上查找到了两个结果，id分别为2,1，然后拿着取到的id值一次次的回表查询，因此这个过程需要回表两次。

**2.**    在MySQL 5.6之后版本，InnoDB并没有忽略age这个字段，而是在索引内部就判断了age是否等于20，对于不等于20的记录直接跳过，因此在(name,age)这棵索引树中只匹配到了一个记录，此时拿着这个id去主键索引树中回表查询全部数据，这个过程只需要回表一次。

 

EXPLAIN解析结果可以看出Extra的值为Using index condition，表示已经使用了索引下推。

索引下推唯一的缺点是需要在磁盘上多做数据筛选，原先的筛选是放在内存中的，现在放在了磁盘中进行查找数据的环节，这样做看起来成本高了，但是数据是排序的，所有的数据是聚集存放，所以性能不会有影响，而且整体的I/O量大大减少了，性能反而提升了

 

#### 3.8.   使用索引扫描排序

MySQL有两种方式生成有序的结果：通过排序操作；按照索引顺序扫描。如果EXPLAIN的结果type列为index（Extra没有出现Using filesort），标识MySQL使用了索引扫描进行排序。

扫描索引本身很快，如果MySQL可以使用同一个索引既满足排序，又用于查找查找行，这样是最好的。

只有当索引的列顺序和ORDER BY子句的顺序完全一致，并且所有列的排序方向（正序或倒序）都一样时，MySQL才可以使用索引对结果进行排序。如果查询需要关联多张表，则只有当ORDER BY子句引用的字段全部为第一个表时，才能使用索引做排序。ORDER BY子句需要满足索引的最左前缀要求，否则MySQL无法用索引排序。

有一种特殊情况ORDER BY子句可以不满足索引的最左前缀要求，就是前导列为常量的时候。

例如：

假设一张用户表(user)，其中主要几个字段有：id、name、age、pos、remark。有联合索引（age,name,pos）。

**1.**    SELECT id FROM user where age = 20 ORDER BY name, pos

即使ORDER BY子句并不满足索引的最左前缀要求，也可以用于查询排序，这是因为索引的第一列被指定为一个常数。

**2.**    SELECT id FROM user where age = 20 ORDER BY name

第一列是常量，用第二列排序，相当于索引的最左前缀。

**3.**    SELECT id FROM user where age > 20 ORDER BY age,name

使用的ORDER BY两列就是索引的最左前缀。

 

下面几种情况是不能用索引做排序的查询：

**1.**    … WHERE age = 20 ORDER BY name DESC, pos ASC

两种不同的排序方向。

**2.**    … WHERE age = 20 ORDER BY name, remark

引用了不在索引中的列。

**3.**    … WHERE age = 20 ORDER BY pos

WHERE和ORDER BY中的子句无法组成索引的最左前缀

**4.**    … WHERE age > 20 ORDER BY name, pos

索引上的第一列是范围条件。

**5.**    … WHERE age = 20 AND name IN (‘A’,’B’) ORDER BY pos

name列上有多个等于条件，也是一种范围查询。

 

#### 3.9.   压缩索引（前缀压缩）

MyISAM使用前缀压缩来减少索引的大小，从而让更多的索引可以放到内存中，这在某些情况下可以极大地提升性能。

MyISM压缩每个索引块的方法是：先完全保存索引块中的第一个值，然后将其他值和第一个值进行比较得到相同的前缀字节数和不同的后缀部分，存储即可。例如，所以块的第一个值是config,第二个值是configuration,那么第二个值压缩之后存储的值类似6,uration。

压缩块节省了空间，代价是某些操作可能会慢。因为每个值的压缩前缀都依赖于前面的值，所以MyISAM查找时无法在索引块使用二分查找只能从头开始扫描。在块中查找某一行的操作平均都需要扫描半个索引块。

 

#### 3.10.  冗余和重复索引

重复索引指的是在相同的列上按照相同的顺序创建相同类型的索引。应当避免这样创建重复索引，发现后也应该立即移除。

冗余索引与重复索引有所不同，例如：

**1.**    如果创建了索引（A,B），再创建索引(A)就是冗余索引，因为这是索引(A,B)的前缀索引，索引（A,B）也可以当做索引（A）使用。

**2.**    创建索引（A,ID），ID是主键。对于InnoDB来说主键列已经包含在二级索引中了，所以这也是冗余的。

 

### 4.  EXPLAIN

基于表的设计、列、索引、还有查询语句中的where条件，MySQL优化器会使用很多技术来更好地执行查询。查询最终会变成一堆操作的集合，这个集合是MySQL优化器选择的最有效的执行这个查询的操作集合，也就是执行计划（query execution plan， 也叫作EXPLAIN plan）。

 

EXPLAIN返回的结果是MySQL执行语句的信息，EXPLAIN可以应用于SELECT, UPDATE, DELETE, INSERT, REPLACE。

 

EXPLAIN给每一个SELECT语句中的表，按照MySQL执行语句时的顺序，都返回了一行信息，用以表示执行计划的信息。（多表join时，mysql的查询方式）

 

EXPLAIN的输出格式

![img](11.png)

 

关于各字段含义：

| 字段          | 含义                         |
| ------------- | ---------------------------- |
| id            | 主键                         |
| select_type   | 查询类型                     |
| table         | 表名，每个表一条数据         |
| partitions    | 匹配的分区                   |
| **type**      | **关键字段：查询类型**       |
| possible_keys | 可能选择的索引               |
| **key**       | **关键字段：实际选择的索引** |
| key_len       | 选择索引的长度               |
| ref           | 索引对应的列                 |
| rows          | 预估的行数                   |
| filtered      | 查询扫描行数的百分比         |
| **Extra**     | **关键字段：额外信息**       |

 

#### 4.1.    type

type列标识查询的类型，效果从最好到最坏依次是：

**1)**   **system**

表只有一行（系统表）。一个const类型的特例。

**2)**   **const**

表只有一行匹配，这一行会在查询开始的时候就被读取。非常快。

在用主键索引或唯一索引查询时，type列为const。

``` sql
select * from table where id = 1
```

**3)**   **eq_ref**

只返回一行。使用主键或唯一索引时，才会有eq_ref。

**4)**   **ref**

索引访问，返回所有匹配某个单个值的行。

**5)**   **fulltext**

全文索引。

**6)**   **ref or null**

跟ref类似，但是包含NULL值判断。

**7)**   **index merge**

索引合并。索引合并优化策略启用时出现，此时key列中会显示使用的索引列表。

**8)**   **unique subquery**

在一些in子查询中替代eq_ref。

**9)**   **index subquery**

与unique subquery类似，在in子查询中，使用非唯一索引时出现。

**10)**  **range**

在索引确定的范围内返回行。key列标识用到哪个索引，ref列为NULL。

当使用比较符=, <>, >, >=, <, <=, IS NULL, <=>, BETWEEN, LIKE, 或者 IN() 函数时，会出现range。

**11)**  **index**

跟ALL形式一样，全表扫描。但是会按照索引次序。有两种情况：

a.   覆盖索引。此时Extra列会显示Using index

b.   通过查询索引列进行全表扫描。

**12)**  **ALL**

全表扫描。

 

#### 4.2.    Extra

一些额外信息，但很重要。

**1)**   **Using index**

索引覆盖。

**2)**   **Using index condition**

索引下推。

**3)**   **Using filesort**

排序时没有使用到索引，而是使用内存排序或磁盘排序（统称为文件排序，filesort）。

**4)**   **Using temporary** 

查询中使用了中间表存储临时结果。

**5)**   **Using where**

存储引擎检索过行之后，服务器层进行过滤。如果type是index或者All，Extra没有Using where，通常会有问题。

**6)**   **Using MRR**

MRR（Multi Range Read），将随机I/O变为顺序I/O。

``` sql
SELECT * FROM table WHERE name = ?
```

结果是1000行，在二级索引树取出1000个id后，在主键树中一个一个的进行查找，速度会比较慢。

MRR:取出1000个id后，在内存中进行排序，然后在主键树中做顺序查找。

 

### 5.  实验

建立组合索引abc，不同sql语句使用索引情况

| 语句                                     | 是否使用索引 | 索引使用情况 |
| ---------------------------------------- | ------------ | ------------ |
| where a = 3                              | 是           | 只使用a      |
| where a = 3 and b = 5                    | 是           | 使用a,b      |
| where b = 3 and a = 5                    | 是           | 使用a,b      |
| where a = 3 and b = 5 and c = 4          | 是           | 使用a,b,c    |
| where b = 3 or c = 4                     | ？           | -            |
| where a = 3 and c = 4                    | 是           | 只使用a      |
| where a = 3 and b > 10 and c  = 7        | ？           | 使用a,b      |
| where a = 3 and b like ‘%xx%’  and c = 4 | 是           | 只使用a      |

 

疑问：

**1.**   where b=3 or c=4时 是否使用索引。

**2.**   where a = 3 and b > 10 and c = 7 使用索引中的几列。

 

回答：具体情况具体分析。

如果一个表的所有列都做了组合索引，那么不管怎么查数据，都会用到组合索引。

如果加了多余的一列之后，那么就不会用到索引了。

 

一些意见：

**1.**   当使用索引列进行查询时尽量不要使用表达式，把计算放到业务层也不是数据库层。

**2.**   尽量使用主键查询，而不是其他索引，因为主键查询不会触发回表。

**3.**   使用前缀索引

**4.**   使用索引扫描来排序

**5.**   union all，in，or都会使用索引，但是推荐使用in

**6.**   范围列可以使用索引（>,>=,<,<=,between）但范围列后面的列无法用到索引，索引最多用于一个范围列

**7.**   强制类型转换会全表扫描

phone是varchar型

隐式类型转换也会使得索引无效

``` sql
explain select * from user where phone = 13000000000; -- 不会触发索引

explain select * from user where phone = '13000000000' -- 会触发索引
```

**8.**   更新频繁的，数据区分度不高的字段上不宜建立索引

a.   更新会变更b+树，更新频繁的字段建立索引会大大降低数据库性能。

b.   类似于性别之类的字段，建立索引没有意义。

c.   一般区分度在80%以上的时候可以建立索引，区分度用count(distinct(column_name))/count(*)计算。   

**9.**   创建索引的列，不允许为null，因为可能会得到不符合预期的结果。

**10.**  当需要进行表连接的时候，最好不要超过3张表，因为需要join的字段，数据类型必须一致。

**11.**  能使用limit的时候尽量使用limit。

**12.**  单表索引尽可能控制在5个以内。（但是现在没有太多的限制了）

**13.**  单索引字段数不允许超过5个（组合索引）

**14.**  创建索引的时候应该避免以下概念：索引越多越好；过早优化或者在不了解系统时进行优化。

 

 
