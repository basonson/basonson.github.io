---
title: MySQL技术总结-2
date: 2022-02-09 10:17:41
tags:
    - schema
    - 数据类型
    - 范式
categories:
    - 数据库
    - MySQL
---

### 1． Schema与数据类型优化


选择正确的数据类型，几个基本的原则如下：

**a.**   更小的通常更好

一般情况下，应该尽量使用可以正确存储数据的最小数据类型。更小的数据类型通常更快，因为他们占用更小的磁盘空间、内存和CPU缓存，处理时需要的CPU周期也更少。

**b.**   越简单越好

简单的数据类型的操作通常需要更少的CPU周期。例如，整型比字符串操作代价更低，因为字符集和校对规则（排序规则）使字符比整型更复杂。

**c.**   尽量避免NULL

如果查询包含可为NULL的列，对MySQL来说更难优化，因为可为NULL的列使得索引、索引统计和值比较都更复杂。

 

#### 1.1  整数类型

MySQL支持的整数类型有TINYINT、SMALLINT、MEDIUMINT、INT（INTEGER）、BIGINT，分别使用8,16,24,32,64位存储空间，存储的值范围是-2（N-1）到2（N-1）-1。

可选的UNSIGNED属性会将正数上限提高一倍。如下表所示：

| 类型      | 位数 | 有符号最小  | 有符号最大 | 无符号最小 | 无符号最大 |
| --------- | ---- | ----------- | ---------- | ---------- | ---------- |
| TINYEINT  | 8    | -128        | 127        | 0          | 255        |
| SMALLINT  | 16   | -32768      | 32767      | 0          | 65535      |
| MEDIUMINT | 24   | -8388608    | 8388607    | 0          | 16777215   |
| INT       | 32   | -2147483648 | 2147483647 | 0          | 4294967295 |
| BIGINT    | 64   | -263        | 263-1      | 0          | 264-1      |

 

有无符号使用相同的存储空间与性能，需要根据实际情况进行选择。（JAVA开发规范中，要求主键使用UNSIGNED BIGINT）。

**为整数类型指定的宽度，例如INT(11)，其中的11并不代表整数的最大位数，他只是规定了MySQL的一些交互工具（例如命令行客户端）用来显示字符的个数。对于存储和计算来说，INT(1)与INT(11)是相同的。**

在设定ZEROFILL（填充零）属性后，会依据设定的宽度，在列的值的左侧补充0，作为补充显示。如果值本身长度超过了设定的宽度，那么不会补充，也不会对值有影响。

![img](1.png)

 

当用于表达式或者UNION查询时，ZEROFILL的属性会无效。

如果给某些字段设置了ZEROFILL属性，同时赋值了超过指定宽度的数值，那么在MySQL执行某些复杂查询时产生的临时表中，这些字段可能会有问题。

ZEROFILL属性同样适用于实数类型（FLOAT,DOUBLE,DECIMAL）。

 

BOOL和BOOLEAN在MySQL中与TINYINT(1)同义。

![img](2.png)

 


但true和false仅仅是1和0的别称，跟其他值无关。例如：

![img](3.png)

 


SERIAL与BIGINT UNSIGNED NOT NULL AUTO_INCREMENT UNIQUE同义。

 

关于BIGINT应当了解：

**1)**    所有的计算都是用BIGINT和DOUBLE来计算的。除了位运算以外，在计算时不要使用大于9223372036854775807的无符号整数，因为最后几位可能会因为四舍五入到DOUBLE类型而造成误差。

**2)**    可以用存储字符串的方式将准确的数字存储在BIGINT型字段中，MySQL会做一个string-to-number的转换（与DOUBLE类型无关）。

**3)**    当+,-,*操作符两边都是整型时，MySQL使用BITINT类型做计算。所以当两个大整数相乘，结果大于9223372036854775807时，会得到意想不到的结果。

 

 

#### 1.2  实数类型

实数类型就是有小数的数字。包括FLOAT,DOUBLE和DECIMAL。

**a.**   **FLOAT**

单精度类型，4个字节，范围是10-38到1038。常定义为FLOAT(M,D)，M是总的位数（不包括.和-），D是小数位数。

如果定义为FLOAT(P)，那么MySQL会根据P值，确定数据类型。如果P值在0-24，那么类型为FLOAT，如果P值在25-53，那么类型会为DOUBLE。FLOAT(P)为ODBC使用。

因为MySQL里的计算是用BIGINT和DOUBLE做的，所以使用FLOAT类型可能会产生意想不到的错误。

**b.**   **DOUBLE**

双精度类型，8个字节，范围是10-308到10308。常定义为DOUBLE(M,D)，M是总的位数（不包括.和-），D是小数位数。

**c.**   **DECIMAL**

封装过的精准数据类型，常定义为DECIMAL(M,D)，M是总的位数（不包括.和-），D是小数位数。M值最大为65，D值最大为30。如果M没定义的话，默认为10。如果D没定义的话，默认为0。

DECIMAL类型的操作(+,-,*,/)都是用65位的精度完成。

DEC,FIXED,NUMERIC都是DECIMAL的同义词。

 

MySQL既支持精确类型（DECIMAL），也支持不精确的类型（FLOAT,DOUBLE）但他们并不是只为了存储小数，比如可以用DECIMAL存储比BIGINT还大的整数。

FLOAT和DOUBLE类型支持使用标准的浮点运算进行近似计算，因为CPU支持，所以浮点运算会更快。

DECIMAL类型用于存储精确的小数，CPU不支持直接计算，MySQL服务器自身实现。相比浮点类型稍微慢一些。

MySQL在存储数值时，会进行四舍五入。例如当给FLOAT(5,2)赋值’36.545’时，会存储为’36.55’。

当设置UNSIGNED属性时，同样不能存储负数。但是与整型值不同的是，最大值并不会翻倍。

DECIMAL类型中，MySQL是将数字打包存储到2进制字符串中（每4个字节存9个数字）。所以一个DECIMAL(18,9)的数字，一共使用9个字节：9位整数是4个字节，小数点1个字节，9位小数4个字节。

如果在需要精确计算时，应当尽可能使用DECIMAL，即使需要额外的空间和计算开销。在数据量大的时候，可以考虑用BIGINT代替DECIMAL，将需要存储的数据根据最小单位乘以响应的倍数。

 

#### 1.3  字符串类型

MySQL的字符串类型包括CHAR, VARCHAR, BINARY, VARBINARY, BLOB, TEXT, ENUM, SET。

VARCHAR和CHAR是两种最主要的字符串类型。

BINARY和VARBINARY是两种二进制字符串类型。

BLOB和TEXT是为了存储很大的数据而设计的字符串类型，分别采用二进制和字符串方式存储。

CHAR、VARCHAR、TEXT类型，MySQL以字符单位为描述长度。BINARY、VARBINARY、BLOB，MySQL以字节为单位描述长度。

字符串类型的字段可以设定字符集（CHARACTER SET）和比较规则（COLLATION）。

**a.**   **VARCHAR**

VARCHAR用于存储可变长度的字符串。因为仅使用必要的空间，所以它比定长类型（CHAR）更节省空间。VARCHAR类型不会删掉末尾空格。

VARCHAR长度限制为0-65535，具体的长度决定于所用的字符集和整行最大长度（所有列共用65535个字节，不包括BLOB和TEXT）。例如如果只有一个VARCHAR字段，指定为UTF-8类型，占用3个字节表示一个字符，那么该列最大长度为21844。

VARCHAR需要额外的1或2个字节记录字符串长度：如果列的最大长度小于或等于255字节，那么需要1个字节存储长度，否则需要2个。

因为字段是变长的，所以在UPDATE时可能使行变得比以前更长，这时可能会造成页内没有更多的空间存储。这种情况下，MyISAM会将行拆成不同的片段存储，InnoDB会分裂页使行可以放进页内。

下面几种情况使用VARCHAR是合适的：

**1)**    字符串最大长度比平均长度大很多；

**2)**    列的更新很少，所以碎片不是问题；

**3)**    使用了像UTF-8这样复杂的字符串，每个字符都是用不同的字节存储。

**b.**   **CHAR**

CHAR是定长的。长度为0-255，如果长度不指定，那么默认为1。

当存储CHAR值时，MySQL会删除所有的末尾空格。当存储小于长度的值时，在右侧用空格填充。当存储超长的值时，CHAR会将值从末尾截断。

当取出CHAR值时，会将末尾空格去掉（当设置sql_mode为PAD_CHAR_TO_FULL_LENGTH时不会去掉）。

可以创建CHAR(0)字段，如果一个不能修改的程序必须需要这个字段，但是不会用到它，可以考虑创建CHAR(0)字段。CHAR(0)字段仅仅可以被赋值为NULL或’’。

CHAR适合存储很短的字符串，或者所有值都接近一个长度。

下面几种情况使用CHAR是合适的：

**1)**    MD5值或者手机号；

**2)**    经常变更的数据，因为定长的CHAR不容易产生碎片；

**3)**    非常短的列，例如CHAR(1)只有Y和N

 

CHAR型与VARCHAR型的存储如下表所示：

| Value     | CHAR(4) | 存储空间 | VARCHAR(4) | 存储空间 |
| --------- | ------- | -------- | ---------- | -------- |
| ‘’        | ‘    ’  | 4 bytes  | ‘’         | 1 bytes  |
| ‘ab’      | ‘ab   ’ | 4 bytes  | ‘ab’       | 3bytes   |
| ‘abcd’    | ‘abcd’  | 4 bytes  | ‘abcd’     | 5 bytes  |
| ‘abcdefg’ | ‘abcd’  | 4 bytes  | ‘abcd’     | 5 bytes  |

 

所有比较规则（COLLATION）都会进行尾部去空格。所以CHAR、VARCHAR、TEXT在比较时都会无视掉尾部的空格，但是此处的比较不包括LIKE。

![img](4.png)

 

![img](5.png)

 

 

**c.**   **BINARY和VARBINARY**

对应CHAR类型和VARCHAR类型。区别是字符集和排序采用BINARY，同时长度也对应的是字节数而非字符数。

他们存储的是二进制字符串，也就是字节码而不是字符。填充时用的是\0(0x00)而不是空格，检索时也不会去掉填充值。比较、排序时\0和空格都会参与，不会被去掉。VARBINARY类型不需要填充。

例如：一个BINARY(3)的字段，当插入’a ’时会变成’a \0’，当插入’a\0’时会变成’a\0\0’。值在进行查询时不会改变。

如下图：

![img](6.png)

 

二进制的优势：

**1)**    大小写敏感；

**2)**    比较值时，二进制字节要比字符简单，也就更快。

**d.**   **BLOB和TEXT**

BLOB和TEXT对应2组数据类型家族：字符型的是TINYTEXT,TEXT,MEDIUMTEXT,LONGTEXT;对应的二进制类型是TINYBLOB,BLOB,MEDIUMBLOB,LONGBLOB。

与其他的类型不同，MySQL会将每个BLOB和TEXT当做单独的对象处理，当值太大时，InnoDB会建立专门的外部存储区域进行存储，每个值在行内需要1-4个字节存储一个指针，指向外部地址。

二者区别是：BLOB类型存储二进制数据，使用binary字符集和数字型的排序规则；TEXT存储的是字符型数据，使用指定的字符集和指定的排序比较规则。

对BLOB和TEXT，在新增和查询时均不会对结尾的数据做出修改（例如增删空格）。

通常我们可以将BLOB认为是一个很大的VARBINARY，将TEXT认为是一个很大的VARCHAR。

MySQL对2者进行排序或索引时，与普通类型不同：只对每个列的最前长度的字节或字符而不是整个字符串做排序或索引。

BLOB和TEXT列上也不能赋值默认值。

当查询BLOB或者TEXT列时，如果MySQL使用了临时表，那么会使用真实存储在磁盘的临时表而非Memory表，因为Memory引擎不支持这俩类型。而使用存储在磁盘的临时表很影响性能，所以在查询时一定注意除非必须否则不要包含这俩字段。

BLOB和TEXT类型的最大长度取决于字段本身，但是也取决于客户端到服务器的通信缓存大小。

 

#### 1.4  日期和时间类型

MySQL可以使用YEAR,DATE,TIME等数据类型来保存日期和时间，但最常用的还是DATETIME和TIMESTAMP类型。

~~MySQL能存储的最小的时间粒度是秒。~~

**a.**   **DATETIME**

DATETIME占用8个字节，表示的时间范围从1000-01-01 00:00:00到9999-12-31 23:59:59 **（从1000-01-01 00:00:00.000000到9999-12-31 23:59:59.999999）**。

它把日期和时间封装到格式为yyyyMMddHHmmss的整数中，与时区无关。

默认情况下以yyyy-MM-dd HH:mm:ss显示，可以用yyyy-MM-dd HH:mm:ss或yyyyMMddHHmmss格式的数值进行INSERT。

**b.**   **TIMESTAMP**

TIMESTAMP占用4个字节，表示的范围从1970-01-01 00:00:01到2038-01-19 03:14:07 **（切换到北京时间是从1970-01-01 08:00:01到2038-01-19 11:14:07，加上毫秒之后是从1970-01-01 08:00:01.000000到2038-01-19 11:14:07.999999）**。

TIMESTAMP与时区有关，在MySQL服务器、操作系统以及客户端里连接都有时区设置。MySQL在存储时，用的是UTC时间。在查询时，将UTC时间转换为当前时区时间。所以在TIMESTAMP字段值的前提下，将系统时区进行修改后，再次查询会得到不同的结果。

如果字段允许为NULL，TIMESTAMP会存储为NULL。否则，在INSERT时会自动存储当前时间。如果勾选“根据当前时间戳更新”，在UPDATE时会自动更新该字段为当前时间。

**c.**   **YEAR**

YEAR占用4个字节，显示为yyyy，表示的范围从1901到2155。

如果赋值0-99的话，会有不同的情况：在0-69时，赋值为2000-2069。在赋值70-99时，赋值为1970-1999。

**d.**   **DATE**

DATE可以认为是DATETIME一部分，按照yyyy-MM-dd的格式，表示的范围是'1000-01-01' to '9999-12-31'。

**e.**   **TIME**

TIME类型会显示为HH:mm:ss或者HHH:mm:ss，表示的范围从'-838:59:59' to '838:59:59'**（从'-838:59:59.000000' to '838:59:59.000000'）**。因为TIME类型并不完全用来代表一天中的时间，也会用来计时会表示时间间隔。

给TIME类型赋值时，如果赋值时写冒号了，例如赋值11:12，会被MySQL认为是11:12:00而不是00:11:12。如果赋值时没写冒号，例如赋值1112，那么正好相反，会被MySQL认为是00:11:12而不是11:12:00。如果赋值12，会被MySQL认为是00:00:12。

 

#### 1.5  位数据类型

**a.**   **BIT**

在MySQL5.0之前，BIT类型与TINYINT是同义词。在5.0及之后，BIT变为一个特性完全不同的数据类型。

BIT是一列中存储一个或多个true/false值。BIT(1)定义包含单个位的字段，BIT(2)存储2个位。最大长度是64位。

当存储时，可以通过b’value’的格式，比如b’00111001’，将值写入该列。但是在查询时，可能会返回不同的结果，如下图：

![img](7.png)

 

当在数字或者字符串型上下文中，BIT类型得到的结果是不同的。所以，对于绝大部分应用，应避免使用此类型。

 

**b.**   **SET**

如果需要保存很多的true/false值，可以考虑用SET数据类型，它在MySQL内部是以一系列打包的位的集合来表示。

缺点是改变列的定义的代价较高，也无法在SET列上通过索引查找。

**c.**   **整数列**

一种替代SET的方式是用一个整数包装一系列的位，比如将8个位包装到一个TINYINT中，并且用按位操作来使用。

好处在于可以不使用ALTER TABLE改变字段代表的值，缺点是查询语句更难写更难理解。

 

#### 1.6  选择主键

当选择主键时，不仅要考虑存储类型，还要考虑MySQL对这种类型怎么进行计算和比较。

一旦选定一种类型，要确保在所有的关联表中都是用同样的类型。类型之间需要精确匹配，比如UNSIGNED这样的属性。

在可以满足值的范围需求，并且预留未来增长空间的前提下，应该选择最小的数据类型。

常见技巧如下：

**a.**   **整数类型**

自增的UNSIGNED BIGINT永远作为最优的主键类型。

**b.**   **字符串类型**

如果有可能，尽量减少字符串类型作为主键的情况。因为字符串类型通常比较耗空间，而且比数字型慢。

一些用MD5(), SHA1(), UUID()产生的字符串，因为是非连续的，会因为索引存储方式导致数据分布在很大的空间内，也会产生碎片，同时，相邻的行分布在不同的地方，缓存赖以工作的局部性原理失效，导致INSERT以及一些SELECT语句变得很慢。

**c.**   **UUID类型**

如果一定要用UUID类型作为主键，应当移除”-”后进行存储;

或者在移除之后，用UNHEX()函数转换为字节型字符串，并且存储在BINARY(16)中。检索时可以通过HEX()函数来获取转换之前的值。

 

#### 1.7  特殊数据类型

**a.**   **精确度高于秒的时间**

**MySQL的最高时间精度是秒。如果存储高于秒精度的时间，可以用BIGINT存储毫秒或者微秒级别的时间戳。或者用DOUBLE存储秒之后的小数部分。**

**b.**   **IPv4地址**

虽然可以用VARCHAR(15)来存储IPv4地址，但是它实际上是无符号32位整数。用整型来存储要比字符型效率更高。所以推荐在数据库中用INET_ATON()将地址转换为整型存储，取出是用INET_NTOA()将整型转换为地址。

 

### 2     范式与反范式

范式定义：符合某一种级别的关系模式的集合，表示一个关系内部各属性之间的联系的合理化程度。

人话：一张数据库的表结构设计所符合的标准。

 

数据库的三范式：

1NF:表中的每个属性都不可再分。

2NF:每一列的都与主键相关。

3NF:每一列都不能与其他非主键列相关。

关于三范式的讲解： 

https://www.zhihu.com/question/24696366/answer/29189700

 

范式的优点：

**1.**   当完全或者较好的范式化时，就不会或者很少有冗余数据，可以尽量减少使用DISTINCT或者GROUP BY；

**2.**   范式化的表通常更小，可以更好地放在内存里进行更快的CRUD操作.

 

缺点：

通常需要连表查询，造成性能开销变大，甚至索引无效。

 

实际中，完全的范式化或者完全的反范式化都是实验室中才有的东西，在实际应用中，通常需要进行综合考虑，进行混用。例如缓存表，中间表，汇总表，统计表等等。
