---
title: Redis技术总结4-持久化
date: 2022-02-15 09:32:49
tags:
    - 数据库结构
    - RDB
    - AOF
categories:
    - 数据库
    - NoSQL
    - Redis
---

### 1.  数据库

#### 1.1  数据库结构

一个Redis服务器中有多个（默认16个）数据库。这些数据库都保存在redisServer结构中，每一个数据库都是一个redisDB结构，如下图：

​                                   
![img](1.png)<center>*redisServer代码示意*</center>


 

初始化服务器时，程序会根据dbnum属性来决定创建多少个数据库。如下图：

​     
![img](2.png)<center>*redisServer结构示意*</center>


 

每个Redis客户端都有自己的目标数据库，可以用SELECT命令进行切换。在程序中，客户端的状态记录在redisClient结构中，如下图：

​     
![img](3.png)<center>*redisClient代码示意*</center>


 

redisClient.db指向redisServer.db数组中的一个元素，而被指向的元素就是客户端的目标数据库。

如果客户端最开始指向数据库1，如下图：

​     
![img](4.png)<center>*客户端指向数据库1*</center>


 

当执行命令SELECT 2之后，客户端会指向数据库2，如下图：

​     
![img](5.png)<center>*客户端指向数据库2*</center>

 

redisClient.db指针的改变就是SELECT命令实现的原理。

 

#### 1.2  数据库的键空间

每个redisDb结构中，会有一个dict字典，保存了数据库的所有键值对，这个字段被称为键空间。

​     
![img](6.png)<center>*redisDb代码示意*</center>

 

键空间就是用户所能感知到的数据库：

键空间中的键就是数据库中的键，每个键是一个字符串对象。

键空间中的值就是数据库中的值，每个值可以是5种Redis对象中的一种。

例如一个包含了列表键alphabet，哈希键book，字符串对象message的数据库结构，如下图：

​     
![img](7.png)<center>*redisDb结构示意*</center>


 

所有针对数据库的操作，比如对键的增删改查，其实都是在对键空间字典进行操作。

不光是增删改查，其他的命令，比如FLUSHDB命令，其实是删除键空间所有键值对；比如DBSIZE命令，是返回键空间中键值对数量；RANDOMKEY命令，是随机返回键空间中某一个键。

当读写数据库的键空间时，服务器还会执行一些额外的维护操作：

**1)**    在读取一个键后（读操作和写操作都要对键进行读取），服务器会根据键是否存在，来更新服务器的键空间命中次数和键空间不命中次数。这两个值可以在INFO STATS命令中查看。

**2)**    在读取一个键后，服务器会更新键的LRU时间，这个值用于计算键的空转时间，使用OBJECT IDLETIME命令查看。

**3)**    在读取一个键时，如果发现键已经过期，服务器会删除这个键。

**4)**    当修改一个键后，服务器会将该键标记为脏dirty，让使用WATCH命令监视此键的客户端知道该键已经被修改。

**5)**    服务器每修改一个键，都会对脏键计数器+1，这个计数器会触发服务器的持久化和复制操作。

**6)**    对键进行修改之后，如果服务器开启了数据库通知功能，会按照配置发送相应的数据库通知。

 

#### 1.3  设置键的生存时间和过期时间

有4个命令来设置键的生存时间和过期时间：

**1)    EXPIRE**

以秒为单位，设置某个键的生存时间，指定秒后，键过期。

**2)    PEXPIRE**

以毫秒为单位，设置某个键的生存时间。

**3)    EXPIREAT**

以秒为精度，设置某个键的过期时间，UNIX秒数时间戳。

**4)    PEXPIREAT**

以毫秒为精度，设置某个键的过期时间，UNIX毫秒数时间戳。

实际上，EXPIRE,PEXPIRE,EXPIREAT命令，都是使用PEXPIREAT命令来实现的：即无论客户端执行哪一个命令，最终都是执行PEXPIREAT命令。

 

在redisDb结构中，字典expires保存了数据库中所有键的过期时间，我们称为过期字典，如下图：

​     
![img](8.png)<center>*redisDb代码示意*</center>


 

过期字典的键是一个指针，指向键空间中的某个键对象；

过期字典的值是一个long long型整数，保存着键指向的数据库键的过期时间：毫秒级精度的UNIX时间戳。

如下图：

​     
![img](9.png)<center>*redisDb结构示意*</center>


 

移除过期时间可以用PERSIST命令。PERSIST命令时PEXPIREAT命令的反操作，将键从过期字典中移除。

获取剩余时间可以用TTL命令（返回秒）和PTTL命令（返回毫秒）。

判断键是否过期步骤如下：

**1)**    检查给定键是否在过期字典中，如果存在，那么获取键的过期时间；

**2)**    检查当前UNIX时间戳是否大于键的过期时间，如果是那么键已经过期。如果不是，那么嗨未过期。

虽然用TTL和PTTL命令也可以判断键是否过期，但是访问字典要比执行一个命令稍微快一点。

 

#### 1.4  过期键删除策略

过期键删除有3种策略：

**1)**    定时删除。

设置过期键的时候，同时生成一个定时器。当定时器到时之后，对键进行删除操作。

优点是对内存最友好，缺点是对CPU最不友好。

**2)**    惰性删除

每次从键空间中读取键的时候，都检查是否过期，如果过期就删除。没过期正常操作。

优点是对CPU最友好，缺点是对内存不友好。

**3)**    定期删除

每隔一段时间，程序对数据库进行一次检查，删除过期键。每次检查多少数据库、多少键、删除多少键，由算法决定。

优点是折中方案，兼顾CPU和内存。缺点是难以确定删除操作的算法策略。

 

Redis采用惰性删除和定时删除两种策略。

**1)**    惰性删除就是由expireIfNeeded函数实现。所有读写数据库的Redis命令，在执行之前都会调用expireIfNeeded函数对输入键进行检查。

**2)**    定时删除由activeExpireCycle函数实现。Redis服务器有一个周期性操作函数serverCron。每当serverCron函数执行时，activeExpireCycle函数会被调用。步骤如下：

a)    从一定数量的数据库中随机选取一定数量的键，删除其中过期键。

b)   使用current_db记录当前activeExpireCycle函数执行进度（数据库编号），下次执行从下一个数据库开始。

c)    所有数据检查完成后，current_db置0。之后开始新一轮。

 

#### 1.5  RDB、AOF、复制功能对过期键的处理

对RDB文件来说，过期键不会对服务器产生影响。因为：

**1)**    生成RDB文件

当执行SAVE命令或者BGSAVE命令创建RDB文件时，程序会对数据库中的键进行检查，过期键不会生成在RDB文件中。

**2)**    载入RDB文件

如果服务器以主服务器模式运行，载入时程序会对过期键进行忽略。

如果服务器以从服务器模式运行，所有键会全部载入。但是主从进行数据同步时，从服务器会按照主服务器数据进行更新，所以过期键也不会对服务器产生影响。

 

对AOF文件来说，略复杂：

**1)**    写入AOF文件

如果某个键已经过期，但是还未被删除策略删除。那么对AOF文件，不会有影响。

当过期键被删除的时候，程序会在删除该键之后，向AOF文件追加一条DEL命令。

**2)**    AOF重写

在执行AOF重写命令时，会忽略已过期的键，不会保存在重写之后的AOF文件中。

 

当服务器运行在复制模式下时，过期键删除操作由主服务器控制：

**1)**    主服务器删除一个过期键后，向所有从服务器发送DEL命令，告诉从服务器对过期键进行删除。

**2)**    从服务器执行读命令时，不会判断键是否过期，即使过期也按未过期处理。

**3)**    从服务器只有接收到DEL命令后，才会对键进行删除。

 

### 2.  RDB持久化

RDB（Redis DataBase）持久化功能，相当于提供一个数据库的快照，保存在磁盘，避免数据丢失。RDB持久化功能生成的RDB文件是一个经过压缩的二进制文件。

#### 2.1  RDB文件的创建和载入

有2个Redis命令可以用于生成RDB文件，SAVE和BGSAVE。

**1)    SAVE**

阻塞服务器进程，直到RDB文件创建完毕为止。在服务器阻塞期间，不能处理任何命令。待RDB文件生成之后，客户端发送的命令才会被处理。

**2)    BGSAVE**

fork一个子进程，由子进程负责创建RDB文件，服务器进程（父进程）继续处理命令。

但是要注意的是，对SAVE、BGSAVE、BGREWRITEAOF三个命令的处理会有所不同。

a)    SAVE和BGSAVE命令会被服务器拒绝。

b)   如果BGSAVE正在执行，那么BGREWRITEAOF会被延迟到BGSAVE执行完毕后执行。

c)    如果BGREWRITEAOF命令正在执行，那么BGSAVE命令会被拒绝。

 

和使用命令创建RDB文件不同的是，Redis并没有载入RDB文件的命令。载入RDB文件是在Redis启动时自动执行的。

服务器在载入RDB文件期间，会一直处于阻塞状态，直到载入工作完成为止。

 

#### 2.2  自动间隔性保存

Redis允许用户通过配置项，设置服务器执行BGSAVE命令的频率（条件）。

默认：

``` bash
save 900 1 //900s内做了1次修改

save 300 10 //300秒内做了10次修改

save 60 10000 //60秒内做了10000次修改
```

满足任何一个条件，服务器就会执行BGSAVE命令。

 

保存条件在redisServer中的结构如下：

​     
![img](10.png)<center>*redisServer代码示意*</center>

 

saveparams是一个数组，每个元素是一个saveparam结构，这个结构保存着save选项设置的保存条件：

​     
![img](11.png)<center>*saveparam代码示意*</center>


 

 

保存着saveparams的redisServer结构如下：

​     
![img](12.png)<center>*redisServer结构示意*</center>

 

除了saveparams数组外，服务器状态还同时维持着一个dirty计数器和一个lastsave属性。

\1)    dirty计数器记录了上一次执行SAVE或者BGSAVE命令后，服务器对数据库状态进行了多少次修改。

\2)    lastsave属性是一个UNIX时间戳，记录了上一次成功执行SAVE或者BGSAVE命令的时间。

如下图：

​     
![img](13.png)<center>*redisServer代码示意图*</center>


 

Redis服务器周期性操作函数serverCron默认每个100ms执行一次。该函数的其中一个工作就是检查save选项所设置的条件是否已经满足（遍历saveparams数组，只要一个条件满足即可），如果满足则执行BGSAVE命令。

 

除了满足save条件，还有3种触发RDB持久化操作的场景：

**1)**    从节点执行全量复制操作时，主节点自动执行BGSAVE命令生成RDB文件传输给从节点。

**2)**    执行DEBUG RELOAD命令重新加载Redis时，也会触发SAVE。

**3)**    执行SHUTDOWN命令时，如果没有开启AOF持久化，则自动执行BGSAVE。

 

#### 2.3  优缺点

RDB文件是一个紧凑压缩（如果开启了RDB压缩设置）的二进制文件，代表Redis在某个时间点的快照。非常适合用于备份、全量复制等场景。加载RDB文件恢复数据的速度也远快于AOF文件。

但RDB方式数据没有办法做到实时持久化（或者秒级持久化），因为BGSAVE命令需要fork子进程，属于重量级操作，耗费资源高。RDB文件也会有版本兼容性问题。

 

### 3.  AOF持久化

AOF(Append Only File)持久化功能，是Redis提供的另一个持久化功能。

假设有3个命令依次执行：

``` bash
SET msg “hello”

SADD fruits “apple” “banana” “cherry”

RPUSH numbers 128 231 456
```

RDB持久化保存数据库的方式是将msg、fruits、numbers三个键值存储在RDB文件中，而AOF持久化的方式是保存3个命令到AOF文件中。

如果服务器开启了AOF持久化功能，那么会优先使用AOF进行数据库状态的还原。只有在AOF持久化功能处于关闭状态时，服务器才会使用RDB文件来还原数据库。

 

#### 3.1  AOF持久化功能的实现

AOF持久化功能可以分为**命令追加(append)、文件写入、文件同步(sync)**三步。

当AOF持久化功能处于打开状态时，服务器在执行完一个写命令后，会按照协议格式将执行的命令追加到服务器状态的aof_buf缓冲区末尾：

​     
![img](14.png)<center>*redisServer代码示意*</center>

 

Redis的服务器进程是一个**事件循环**。这个循环包含两类事件：

**1)    文件事件**

负责接收客户端的命令，以及向客户端发送命令回复。

**2)    时间事件**

负责执行像serverCron这样需要定时运行的函数。

服务器在每结束一个事件循环之前，都会调用flushAppendOnlyFile方法，考虑是否要将aof_buf缓冲区的内容**写入和同步**到AOF文件里。

注意：写入和同步是两个操作。

flushAppendOnlyFile函数的行为由服务器配置的appendfsync选项的值确定，如下表所示：

| appendfsync      | flushAppendOnlyFile函数行为                                  |
| ---------------- | ------------------------------------------------------------ |
| always           | 将aof_buf缓冲区内所有内容写入并同步到AOF文件                 |
| everysec（默认） | 将aof_buf缓冲区内所有内容写入到AOF文件，如果上次同步AOF时间距现在超过1秒钟，那么会再次同步，这个同步操作由一个线程专门负责执行 |
| no               | 将aof_buf缓冲区内所有内容写入到AOF文件，但不对AOF文件进行同步，何时同步由操作系统指定。 |

 

**关于文件的写入和同步：**

为了提高文件的写入效率，现代操作系统中，当用户调用write函数，操作系统通常会将写入数据暂时保存在一个内存缓冲区中，等到缓冲区的空间被填满，或者超过了指定的时限之后，才真正的将缓冲区中的数据写入到磁盘中。

虽然提高了效率，但是也带来了安全问题，加入计算机宕机，那么保存在内存缓冲区中的尚未同步到磁盘中的数据将会丢失。

所以，操作系统提供了fsync和fdatasync两个同步函数，他们可以强制让操作系统立刻将缓冲区中的数据写入到磁盘中，从而确保写入数据的安全性。

 

**关于三种方式的分析：**

**1)    always**

服务器在每个事件循环结束，都会进行写入和同步操作。所以效率是最慢的，但也是最安全的。

**2)    everysec**

服务器在每个事件循环结束，都会进行写入操作，同时每隔一秒进行同步操作。所以效率足够快，而且最多丢失1s的数据。

**3)    no**

服务器在每个事件循环结束，都会进行写入操作，无需程序执行同步操作。所以效率是最快的，但是最不安全。

 

#### 3.2  AOF文件的载入

Redis读取AOF文件的步骤如下：

**1)**    创建一个不带网络连接的伪客户端。

因为Redis的命令只能在客户端中执行，所以服务器使用了一个没有网络连接的伪客户端，执行命令的效果和带网络连接的真实客户端效果是完全一样的。

**2)**    从AOF文件中分析并读取一条写命令；

**3)**    使用伪客户端执行该命令。

**4)**    重复执行2和3，直到AOF文件中的所有写命令都被处理完毕。

 

#### 3.3  AOF重写

随着服务器运行时间增加，AOF文件中的数据也会越来越多。为了解决AOF文件体积膨胀的问题，Redis提供了AOF文件重写(rewrite)功能。

AOF重写过程可以通过手动触发（直接调用BGREWRITEAOF命令）和自动触发（根据AOF重写时文件最小体积auto-aof-rewrite-min-size和当前AOF空间和上次重写后AOF空间比值auto-aof-rewrite-percentage自动重写）。

虽然这个功能被叫做AOF文件重写，但是他并不需要对现有的AOF文件进行任何读取、分析、写入操作，这个功能是通过读取服务器当前数据库的状态来实现的。

比如之前服务器对一个键执行了6次写命令，那么保存在AOF文件中，关于这个键的命令会有6条。当要重写时，不会依次分析6条语句，而是直接读取当前数据库该键的值，然后用一条写命令记录键值对，来代替之前的多条语句。这就是AOF重写功能的实现原理。

因为AOF文件重写可能会涉及到大量的命令写入和同步文件的操作，如果直接调用会造成服务器进程阻塞。所以Redis会单独fork一个子进程来执行重写操作。

但是如果在子进程重写期间，如果有命令到来，会对数据库状态造成不一致的现象。 为了解决这个问题，Redis服务器设置了一个**AOF重写缓冲区**，这个缓冲区会在服务器创建子进程之后开始使用，当Redis服务器执行完一个写命令后，他会将写命令同时写入AOF缓冲区和AOF重写缓冲区。

当子进程完成AOF重写工作后，他会向父进程发送一个信号，父进程收到信号会调用一个函数，执行以下操作：

**1)**    将AOF重写缓冲区中的所有内容写入到新的AOF文件中。保证AOF文件所保存的数据库状态跟服务器当前状态一致。

**2)**    对新的AOF文件改名，覆盖现有AOF文件，完成新旧两个AOF文件的替换。

具体过程如下表：

| 时间 | 父进程                                          | 子进程                        |
| ---- | ----------------------------------------------- | ----------------------------- |
| T1   | 执行命令SET k1 v1                               |                               |
| T2   | 执行命令SET k1 v2                               |                               |
| T3   | 执行命令SET k1 v3                               |                               |
| T4   | 创建子进程，执行AOF文件重写                     | 开始AOF文件重写               |
| T5   | 执行命令SET k2 123                              | 执行重写操作                  |
| T6   | 执行命令SET k3 456                              | 执行重写操作                  |
| T7   | 执行命令SET k4 789                              | 完成AOF重写，向父进程发送信号 |
| T8   | 收到信号，将T5T6T7三个命令追加到新的AOF文件末尾 |                               |
| T9   | 用新的AOF文件替换旧AOF文件                      |                               |

 

以上就是BGREWRITEAOF命令的实现原理。

 

在Redis启动时，持久化文件加载流程如下：

**1)**    AOF持久化开启并且存在AOF时，优先加载AOF文件；

**2)**    AOF关闭时，加载RDB文件；

**3)**    加载AOF或者RDB文件成功后，Redis启动成功；

**4)**    AOF或者RDB文件存在错误时，Redis启动失败并打印错误信息。

 
