---
title: MySQL技术总结-1
date: 2022-02-08 16:32:35
tags:
  - 架构
  - 并发控制
  - 事务
  - 存储引擎
categories:
  - 数据库
  -	MySQL
---

### 1.       MySQL逻辑架构

![](逻辑架构图.png)

 

**1)** 客户端

不是MySQL独有。 程序、网站、客户端、服务器工具等等。

**2)** 服务层

包含大多数MySQL的核心服务功能，比如查询解析、分析、优化、缓存以及所有的内置函数（日期、时间、数学等）、所有跨存储引擎的功能：存储过程、触发器、视图。

**3)** 引擎层

负责MySQL数据的存储和提取，服务层通过API与引擎层交互，例如“开始一个事务”、“根据主键提取一行记录”等操作。

 

#### 1.1    连接管理与安全性

每个客户端连接都会在服务器进程中拥有一个线程。服务器会负责缓存线程，因为“不需要”为每一个新建的连接创建或者销毁线程。MySQL 5.5之后的版本提供了线程池的API。

当客户端连接到MySQL服务器时，服务器需要基于主机信息、用户名、密码进行认证。当客户端连接成功时，还会继续验证客户端是否具有某个查询的权限。

 

#### 1.2    优化与执行

MySQL会解析查询，对其进行各种优化，包括重写查询、决定表的读取顺序、以及选择合适的索引等。用户可以通过特殊的关键字提示（hint）优化器，影响他的决策过程，也可以请求优化器解释（explain）优化过程的各个因素。

优化器不关心存储引擎的类型， 但是存储引擎对优化查询是有影响的。比如优化器会请求存储引擎提供容量或者某个操作的开销信息，表数据的统计信息等等。

对于SELECT语句，在解析查询之前，服务器会先检查查询缓存（query cache），如果能找到对应查询，服务器就不再进行查询解析、优化、执行，而是直接返回查询缓存中的结果集。

 

### 2.       并发控制

#### 2.1    读写锁

只要有多个操作同时修改数据，就会产生并发控制问题，解决方法就是锁。锁分为共享锁（shared lock）和排它锁（exclusive lock），也叫读锁（read lock）和写锁（write lock）。

读锁是共享的，或是相互不阻塞的。多个客户在同一时刻可以同时读取同一资源，互不干扰。写锁是排他的，一个写锁会阻塞其他的写锁和读锁。

实际数据库系统中，每时每刻都在发生锁定。

 

#### 2.2    锁粒度

理想的状态：只对会修改的数据进行精确的锁定。原因：任何时候，在给定的资源上，锁定的数据量越少，系统的并发程度越高，只要相互之间不发生冲突即可。

锁的各种操作：获得锁、检查锁状态、解除锁，都会增加系统的开销。

锁策略就是在数据的安全性和锁的开销之间寻求平衡。大多数数据库都是提供了行级锁（row-level lock），并以各种复杂的方式实现，以便在锁比较多的情况下尽可能的提供更好的性能。

MySQL有更多的选择，每种存储引擎都可以选择自己的锁策略和锁粒度。

表级锁和行级锁是两种最重要的锁策略，还有库级锁以及页级锁。

 

**a.**   **表级锁（table-level lock）**

表级锁是MySQL中开销最小的策略：锁定整张表。

用户对表进行写操作（CUD）时，首先获得写锁，这会阻塞其他用户对该表的所有读写操作。

虽然存储引擎可以管理自己的锁，但是MySQL本身还是会使用各种有效的表锁来实现不同的目的。例如，服务器层会为ALTER TABLE之类的语句使用表锁，而忽略存储引擎的锁机制。

 

**b.**   **行级锁（row-level lock）**

行级锁可以最大程度的支持并发处理。

行级锁只在存储引擎层实现，并未在服务层实现。

 

### 3.       事务

事务是一组原子性的SQL查询，或者是一个独立的工作单元。事务内的语句，要么全部执行成功，要么全部执行失败。

举例：A->B转账。

1). 查询A的余额；

2). A账户减少100元;

3). B账户增加100元。

 

#### 3.1    ACID

**1)**   **A（Atomicity）原子性**

一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么失败全部回滚。

**2)**   **C（Consistency）一致性**

事务开始前与完成后，数据库的一致性状态不变。

**3)**   **I（Isolation）隔离性**

通常来说，一个事务所做的修改在最终提交以前，对其他事务是不可见的。

**4)**   **D（Durability）持久性**

一旦事务提交，所做的修改就会永久的保存在数据库中。

 

#### 3.2    隔离级别

在SQL标准中定义了4种隔离级别。

**1)**   **READ UNCOMMITTED（未提交读）**

在READ UNCOMMITTED级别，事务中的修改，即使没有提交，对其他事务也是可见的。事务可以读取未提交的数据，会引发脏读。实际中一般不使用。

脏读：一个事务读取到了别的事务还没提交时修改的数据。

**2)**   **READ COMMITTED（提交读）**

在READ COMMITTED级别，一个事务开始时，只能看到已经提交的事务所做的修改。也就是说，一个事务从开始直到提交，所做的任何修改对其他事务都是不可见的。这个级别也叫不可重复读，因为重复查询时会得到不一样的结果。

READ COMMITTED是SQL SERVER和Oracle等大多数数据库的默认隔离级别。

不可重复读：事务A第一次查询某值x时，为200。之后事务B对x进行了修改为100并提交。 之后事务A再次查询某值x，得到值为100。不可重复读指的是值的修改。

**3)**   **REPEATABLE READ（可重复读）**

在REPEATABLE READ级别，可以解决不可重复读的问题。但是不能解决幻读的问题。

REPEATABLE READ是MySQL的默认隔离级别。

幻读：事务A第一次依据某条件修改数据时，修改了10条数据。之后事务B在此范围内插入了一条数据，并提交。 之后事务A再次查询时，得到11条数据，其中10条修改过，1条未修改，仿佛发生了幻觉。幻读指的是数据条数的修改。

InnoDB引擎通过MVCC（多版本并发控制）解决了幻读问题。

**4)**   **SERIALIZABLE（可串行化）**

SERIALIZABLE是最高的隔离级别，会在读取的每一行数据上都加锁，强制事务串行执行，解决了幻读，但是会引发大量的锁征用问题。实际中也很少使用。

 

四种隔离级别及问题可能性如下：

| 隔离级别          | 脏读可能性 | 不可重复读可能性 | 幻读可能性 |
| ----------------- | ---------- | ---------------- | ---------- |
| READ  UNCOMMITTED | √          | √                | √          |
| READ  COMMITTED   | ×          | √                | √          |
| REPEATABLE  READ  | ×          | ×                | √          |
| SERIALIZABLE      | ×          | ×                | ×          |

 

#### 3.3    死锁

死锁是指两个或多个实例在同一资源上相互占用，并请求锁定对方占用的资源，导致发生恶性循环的现象。当多个事务试图以不同顺序锁定资源时，就可能产生死锁。

死锁产生的原因主要包含如下两个：

**1)**    真正的数据占用冲突，通常难以避免。

**2)**    存储引擎的实现方式导致。

解决方法：

**1)**    数据库提供了各种死锁检测和死锁超时机制，迅速检测到死锁的循环依赖并迅速返回错误。

**2)**    当查询到达锁等待超时的设定时间后，放弃请求。比如InnoDB处理死锁的方式就是将持有最少行级排他锁的事务进行回滚。

 

#### 3.4    事务日志

使用事务日志，存储引擎在修改表数据的时候，只需要修改其内存拷贝，再把该修改行为记录到硬盘上的事务日志中，而不用每次都将修改的数据本身持久化到硬盘。

事务日志采用追加的方式，写日志的操作是在磁盘的一小块区域内顺序IO，而不需要在随机IO，所以采用记录事务日志的方式要比直接将数据写入磁盘快很多。

事务日志持久化之后，内存中被修改的记录在后台慢慢的写入到磁盘。

这种方式被称为预写式日志（Write-Ahead Logging），每次修改数据需要写2次磁盘。

 

#### 3.5    MySQL中的事务

MySQL中包含支持事务的引擎比如InnoDB， 不支持事务的引擎比如MyISAM。

MySQL采用的是自动提交（AUTOCOMMIT）模式，也就是说如果不是显示的开始一个事务，那么每次查询都会被当做一个事务执行提交操作。可以通过设置AUTOCOMMIT变量修改。

修改AUTOCOMMIT变量对非事务型的引擎表，没有任何影响。

有一些命令比如ALTER TABLE等，会在执行前强制提交当前活动事务。

如果在同一个事务中混合操作了事务型引擎表和非事务型引擎表。当事务正常提交时没有问题，当事务失败想回滚时，非事务型引擎表的操作不会回滚。这样就会造成一致性的问题。

 

### 4.       多版本并发控制

多版本并发控制（MVCC, Multi-Version Concurrency Control）是数据库基于性能考虑，用于实现并发访问的技术手段。不止MySQL，SQLServer、Oracle都实现了MVCC但方式不尽相同。

在MySQL中，MVCC在很多情况下避免了加锁操作，他是通过保存数据在某个时间点的快照来实现的。

在InnoDB中，通过在每行数据中添加2个隐藏列实现MVCC。这两个列，一个保存了该行数据的创建版本，另一个保存了该行数据的删除版本。当然存储的并不是系统时间，而是系统版本号。每开始一个新的事务，系统版本号都会自动增加。事务开始时刻的系统版本号，会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。

以下是具体操作方式：

**1.**    **SELECT**

InnoDB根据以下2个条件检查每行记录：

a.   创建版本小于等于当前事务版本的数据行。这样可以保证事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或修改过的。

b.   删除版本要么未定义，要么大于当前事务版本号。确保事务读取到的行，在事务开始之前未被删除。

同时符合上述两个条件的记录，才会作为查询结果返回。

**2.**    **INSERT**

InnoDB为新插入的每一行保存当前系统版本号作为创建版本。

**3.**    **DELETE**

InnoDB为删除的每一行保存当前系统版本号作为删除版本。

**4.**    **UPDATE**

InnoDB插入一行新记录，保存当前系统版本号作为创建版本，同时将原来行的删除版本保存为当前系统版本号。

保存两个隐藏列，可以是大多数的读操作都不需要加锁，提升了数据库的性能。但是不足之处是每行记录都需要额外的存储空间，以及一些额外的维护工作。

MVCC只在REPEATABLE READ和READ COMMITTED两个隔离级别下工作。READ UNCOMMITTED总是读取最新行，而不是符合当前事务版本的行。而SERIALIZABLE会对所有的读取行都加锁。

 

### 5.       MySQL的存储引擎

#### 5.1    InnoDB引擎

**1)**    InnoDB是MySQL默认的引擎，是最重要也是最广泛的事务型引擎。

**2)**    数据存储在单独的文件（.ibd或者.ibdata）中。

**3)**    采用MVCC支持高并发，默认级别是REPEATABLE READ，通过间隙锁（next-key locking）策略防止幻读的出现。间隙锁使得InnoDB不仅仅锁定查询涉及的行，还会对索引中的间隙进行锁定，以防止幻影行的插入。

**4)**    InnoDB表是基于聚簇索引建立。聚簇索引对主键查询有很高的性能，但是二级索引（非主键索引）中必须包含主键列，所以如果主键列很大的话，所有索引都会很大。所以应当尽可能的减小主键。

**5)**    InnoDB在内部做了很多优化，比如从磁盘读取数据时采用可预测性预读，能够自动在内存中创建hash索引以加速读操作的自适应哈希索引（adaptive hash index），以及能够加速插入操作的缓冲区（insert buffer）。

**6)**    InnoDB可以支持真正的热备份，而MySQL的其他存储引擎不支持热备份（要获取一致性视图必须停止对所有表的写入）。

 

#### 5.2    MyISAM引擎

**1)**    在MySQL 5.1及之前的版本，是默认的存储引擎。不支持事务。

**2)**    数据存储在两个文件中：数据文件和索引文件，分别是.MYD和.MYI文件。

**3)**    MyISAM是表级锁而不是行级锁。

**4)**    MyISAM表会崩溃并且不自动修复。虽然可以通过手动修复的方式，但是可能会导致一些数据丢失，而且修复操作是非常慢的。

**5)**    MyISAM表中，即使是BLOB或者TEXT等长字段，也可以基于前500个字符创建索引。也支持全文索引。

**6)**    MyISAM表可以在创建时指定延迟更新索引键（DELAY_KEY_WRITE）选项，在每次修改完成后，不会立刻将修改的索引数据写入磁盘，而是写入到内存的键缓冲区（in-memory key buffer），只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大提升写入性能，但是在数据库或主机崩溃时会造成索引损坏，需要修复。

**7)**    MyISAM表可以用myisampack对整张表进行压缩，将表变为只读表。极大的减少了存储空间，减少了磁盘的I/O，提高的查询的性能。压缩表中的每行记录是单独压缩的，所以读取单行并不需要解压。（但是修改需要解压）

 

#### 5.3    其他引擎

**1)**    Memory

所有数据都在内存中，不进行磁盘I/O。结构在重启后保留，但是数据丢失。使用表级锁，并发写入性能较低。如果MySQL查询中需要使用临时表来保存中间结果，内部使用的表就是Memory表。

**2)**    CSV

将CSV文件作为表来处理，不支持索引。

**3)**    Archive

只支持INSERT和SELECT操作。对数据压缩所以比MyISAM更快，磁盘I/O更少。支持行级锁和专用缓冲区，实现高并发的插入，不支持事务。是一个针对高速插入和压缩做了优化的简单引擎。

**4)**    Blackhole

没有存储机制，不存任何数据，只是服务器会记录Blackhole表的日志。问题较多，不建议使用。

**5)**    Federated

访问其他MySQL服务器的一个代理，创建一个连接，将查询传输到远程服务器执行。已经被禁用。

**6)**    Merge

用于分表，在引入分区功能后，被禁用。

 

#### 5.4    关于引擎的选择

除非需要用到InnoDB不具备的特性，并且没有其他方法可以替代，否则都应该优先选择InnoDB引擎。

正例：如果用到全文索引，优先考虑InnoDB+ElasticSearch/Sphinx，而不是支持全文索引的MyISAM。

反例：如果不在乎可扩展能力和并发能力，也不要求事务，也不在乎频繁崩溃以及崩溃后的数据丢失问题，却对InnoDB的空间占用过多很敏感，可以选择MyISAM。

除非万不得已，否则不要混合使用多种存储引擎，容易引发一系列复杂的问题、潜在的bug和边界问题等等。

如果一定需要不同的引擎，那么需要从事务、备份、崩溃恢复、特性等方面去进行综合的考虑与选择。
