---
title: Redis技术总结6-复制
date: 2022-02-15 14:06:37
tags:
    - 复制
    - 主从
categories:
    - 数据库
    - NoSQL
    - Redis
---

### 1.  复制

用户可以通过执行SLAVEOF命令，或者设置slaveof选项，让一个服务器去复制另外一个服务器。被复制的服务器叫做主服务器，去复制主服务器的服务器叫做从服务器。主从服务器会保存相同的数据，称为“数据库状态一致”。

#### 1  建立复制

主从服务器也分别叫做主节点和从节点。每个从节点只能有一个主节点，而主节点可以有多个从节点。建立复制的方法有3种：

**1)** 在配置文件中加入slaveof [masterhost] [masterport]，随着redis启动而生效。

**2)** 在redis-server命令后加入--slaveof [masterhost] [masterport]生效。

**3)** 启动后直接使用命令：slaveof [masterhost] [masterport]生效。

注意：以上都是针对从节点，主节点不需进行配置。

 
#### 2  断开复制

使用slaveof no one断开。不会丢失原有数据，只是不再与主节点进行同步。

也可以直接使用salveof [newmasterhost] [newmasterport]来切换主节点。执行命令后，从节点会首先断开与旧主节点的复制关系，然后与新主节点建立复制关系，之后删除从节点当前所有数据，从新的主节点进行复制操作。

注意：切换主节点会清空从节点所有数据，线上操作时避免出现salveof错误的节点的情况。

 

#### 3  只读

从节点默认为只读模式。因为从节点数据的修改，主节点是无法感知的，修改从节点会导致主从数据不一致。所以建议线上不要修改从节点的只读模式。

 

#### 4  拓扑

复制的拓扑结构可以分为单层或者多层。按照复杂性分为一主一从，一主多从，树状主从三种。

**1)   一主一从结构**

最简单的拓扑结构。当写并发量较高并且需要持久化的时候，可以只在从节点开启AOF，这样保证了数据安全性也避免了持久化对主节点的性能干扰。但是需要注意的是，主节点关闭持久化功能后，如果需要重启，主节点数据会清空，从节点数据也会清空。

所以，当需要重启主节点时，建议的做法是在从节点执行slaveof no one后，再在主节点执行重启。

**2)   一主多从结构**

对于读操作占比较高的场景，可以把读命令发送到各个从节点分担主节点压力。同时一些耗时较高的命令，可以在特定从节点执行，防止慢查询影响生产环境效率。

但对于写并发量较高的场景，多个从节点会导致主节点写命令的多次发送从而过度消耗网络带宽，同时也加重了主节点的负载影响服务稳定性。

**3)   树状主从结构**

在此结构中，从节点不但复制主节点数据，同时也作为其他从节点的主节点往下传递数据。这样有效地降低了主节点负载和需要传输给其他从节点的数据量。

 

#### 5  旧版复制功能

旧版复制功能分为同步和命令传播两个操作。

同步功能用于将从服务器的数据库状态更新为主服务器的数据库状态。

命令传播用于主服务器数据库状态被修改时，让主从服务器状态一致。

**5.1    同步**

从服务器从主服务器发送SYNC命令。

主服务器收到SYNC命令后，执行BGSAVE命令，开始生成一个RDB文件，并且使用一个缓冲区记录当前开始执行的所有写命令。

BGSAVE执行完毕后，RDB文件发送给从服务器，从服务器接收并载入这个文件。

主服务器将缓冲区内所有命令发送给从服务器，从服务器一一执行。

这样主从服务器的状态到达一致。

**5.2    命令传播**

主服务器会将自己执行过的写命令，发送给从服务器执行。这样双方的状态始终保持一致。

 

缺陷：

主从服务器的复制可以分为初次复制和断线之后的复制。对初次复制来说，上述功能可以很好地完成任务。但对断线后的复制来说，全量SYNC效率很低。

例如主从服务器现在已经各有10000个键。此时网络断开2秒，期间主服务器新增2个键。2秒后网络恢复。如果按照旧版同步方式，主服务器需要生成一个包含10002个键的RDB文件同步给从服务器，但其实他只需要将额外的2个键同步给从服务器即可。RDB文件的生成、传输、载入都需要耗费大量的CPU、内存、网络资源。

 

#### 6  新版复制功能

新版采用PSYNC命令代替SYNC命令。PSYNC命令包括完整重同步和部分重同步两种模式。完整重同步适用于初次赋值，部分重同步适用于断线后复制。

部分重同步由以下三部分共同完成：

**1)**   主从双方各维护一个复制偏移量。

**2)**   主服务器维护复制积压缓冲区。

**3)**   主服务器的运行ID。

 

**6.1    复制偏移量**

主服务器每次向从服务器传输N个字节的数据时，就将自己的复制偏移量+N。

从服务器每次接收N个字节的数据时，就将自己的复制偏移量+N。

通过对比双方的复制偏移量，程序就能够了解双方的状态是否一致。

 

**6.2    复制积压缓冲区**

复制积压缓冲区是由主服务器维护的一个固定长度的、先进先出的队列，默认1M。

当主服务器进行命令传输时，它不仅会将命令发送给所有从服务器，也会将命令写入到复制积压缓冲区里，并且为每个字节记录偏移量。

当从服务器连接到主服务器时，通过PSYNC命令将复制偏移量发送给主服务器，主服务器比较之后，如果发现偏移量不同，那么：

**1)**    如果从服务器偏移量之后的数据仍然存在于复制积压缓冲区中，那么主服务器会对从服务器按照偏移量差，进行部分重同步操作。

**2)**    如果从服务器偏移量之后的数据已经不存在于复制积压缓冲区中，那么进行完整重同步操作。

 

**6.3    运行ID**

每个Redis服务器，无论主从，都会有一个运行ID。在服务器启动时自动生成，是40个随机十六进制字符。

主从服务器初次同步时，主服务器会将自己的运行ID传输给从服务器，保存起来。

断线重连后，从服务器会将保存的主服务器运行ID发送给当前主服务器。

如果ID相同，会尝试判断偏移量。

如果ID不同，那么直接进行完整重同步操作。

 

如何在不改变运行ID的情况下重启呢？

使用debug reload命令重启。

注意：debug reload命令会阻塞当前Redis节点的主线程，阻塞期间生成本地的RDB快照并清空数据，之后重新加载RDB。所以对于大数据量的主节点和无法容忍阻塞的应用场景，谨慎使用。

 

#### 7  心跳

主从节点建立复制之后，他们之间维护着长连接并发送心跳命令。

**1)**  主从节点批次都有心跳检测机制，他们各自模拟成对方的客户端去跟对方进行通信。（这些客户端可以通过client list命令查看到）

**2)**  主节点默认每隔10s向从节点发送ping命令，判断从节点的存活性和连接状态。

**3)**  从节点每隔1s向主节点发送replconf ack [offset]命令，给主节点上报自己当前的复制偏移量。

主节点根据replconf命令判断从节点超时时间，在info replication统计中的lag标识与从节点最后一次通信后的秒数，通常在0-1之间。如果超过60s（可以配置），则判断从节点下线并断开连接。

 

#### 8  异步复制

主节点会将写命令同步给从节点，这个发送过程是异步完成的。

**1)**  主节点接收并处理命令

**2)**  命令处理完后返回响应结果

**3)**  命令异步发送给从节点，从节点在主线程中执行该命令

异步操作决定了主从之间数据是有延迟的。延迟多少可以在主节点中执行info replication命令通过比较主从的offset来判断。
