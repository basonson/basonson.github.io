---
title: Redis技术总结7-集群
date: 2022-02-15 14:11:43
tags:
    - 集群
    - 分片
    - 槽
categories:
    - 数据库
    - NoSQL
    - Redis
---

### 1.  集群

集群与复制不同，复制分为主从服务器，主负责写，从负责读。集群中每个服务器都是独立，共同完成读写任务。


#### 1  节点

一个Redis集群由多个节点构成。连接各个节点使用CLUSTER MEET命令完成。

比如现在有3个独立节点127.0.0.1:7000,127.0.0.1:7001,127.0.0.1:7002（分别以7000,7001,7002代替）。如果我们登陆127.0.0.1.7000，然后输入命令

``` bash
CLUSTER MEET 127.0.0.1 7001

CLUSTER MEET 127.0.0.1 7002
```

那么结果会如下4张图：

​                                   
![img](1.png)<center>*节点7000与7001握手*</center>

 

![img](2.png)<center>*7000与7001建立集群*</center>

 

![img](3.png)<center>*7000与7002握手*</center>



![img](4.png)<center>*3个节点位于同一个集群*</center>

 

在服务器启动时，会根据一个配置项cluster-enabled，来决定是否开启集群模式。

集群模式与普通模式并没有太大区别，该有的功能都会有。但是会使用3个结构来保存集群模式才会用到的数据。

每个节点会使用一个clusterNode结构保存了节点当前状态，比如节点名称、创建时间、IP地址、端口号等等。

每个clusterNode中包含一个clusterLink结构，该结构保存了连接节点所需的有关信息，比如socket描述符，输入缓冲区，输出缓冲区。

每个节点会保存着一个clusterState结构，这个结构记录了当前节点的视角下，集群的状态，所包含的节点等等。

​     
![img](5.png)<center>*clusterNode结构*</center>


​     
![img](6.png)<center>*clusterLink代码示意*</center>


​     
![img](7.png)<center>*clusterState代码示意*</center>



集群结构如下图：

​     
![img](8.png)<center>*集群结构示意*</center>


 

关于CLUSTER MEET命令的实现：

登录节点A，发送命令CLUSTER MEET命令，输入B的ip和port。

**1)**    节点A为节点B创建一个clusterNode结构，并添加到自己的clusterState.nodes字典里。

**2)**    节点A向节点B发送MEET消息。

**3)**    节点B收到MEET消息，为节点A创建一个clusterNode结构，并添加到自己的clusterState.nodes字典里。

**4)**    节点B向节点A返回一条PONG消息。

**5)**    节点A收到后，知道B已经收到了自己发送的MEET消息。

**6)**    节点A向B返回一条PING消息。

**7)**    节点B收到后，知道A已经收到了自己发送的PONG消息。

握手完毕。

之后节点A会将节点B的信息通过Gossip协议传播给集群中其他节点，让其他节点与B握手。这样过了一段时间之后，节点B会被集群中所有节点都认识（互相拥有对方的结构）。

 

#### 2  槽

集群中的整个数据库被分为16384个槽（slot），每个键都属于这16384个槽中的一个，集群中的每个节点都可以处理0个或16384个槽。

当这16384个槽都有节点处理时，集群处于上线状态；相反的，如果有任何一个槽没有得到处理，集群处于下线状态。

登录7000之后，使用CLUSTER ADDSLOTS命令指定槽。当所有槽都被指定到节点之后，集群自动上线。（如果有槽已经被指派给其他节点，那么会返回错误）

clusterNode结构中的slots属性和numslot属性记录了节点负责处理哪些槽以及槽的数量。每个节点还会将自己负责处理哪些槽通过消息发送给其他节点，其他节点收到之后，会更新自己clusterState.nodes字典中对应节点的clusterNode结构对slots和numslots进行更新。

clusterState结构中记录了集群中16384个槽的指派信息。

​     
![img](9.png)<center>*redisState代码示意*</center>


 

这是一个Redis里很经典的冗余。从nodes属性，可以快速找到每个节点负责的槽。从slots属性，可以快速找到每个槽对应的节点。单纯用哪种存储都可以完成所有任务，但是两种存储方式一起用可以将复杂度由O(N)变成O(1)。

 

#### 3  在集群中执行命令

当客户端向节点发送有关键的命令时，收到命令的节点会计算要处理的键属于哪个槽，并判断这个槽指派的节点：

如果指派的节点是自己，那么节点执行这个命令；

如果指派的节点不是自己，那么节点会给客户端返回一个MOVED错误，指向客户端转向正确的节点，并再次发送之前想要执行的命令。

​     
![img](10.png)<center>*节点收到命令后的判断*</center>


 

节点使用如下算法确定key属于哪个槽：

int i = CRC16(key) & 16383

计算出i之后，节点检查clusterState.slots[i]，判断是否等于clusterState.myself。如果相同，那么就直接执行命令。如果不同，那么根据clusterState.slots[i]指向的clusterNode结构记录的节点IP和port，向客户端返回MOVED错误。

客户端收到MOVED错误后，会跟据错误中提供的IP地址和端口号，转到负责该槽的节点，并向该节点重新发送命令。

节点与单机服务器的一个区别是，节点只使用0号数据库，单机服务器没有这一个限制。

另外，除了将键值保存在数据库中之外，节点还会使用clusterState结构中的slots_to_keys跳跃表来保存槽和键的关系。跳跃表中的分值是槽号，节点成员是数据库键。如下图：

​     
![img](11.png)<center>*slots_to_keys跳跃表*</center>



通过跳跃表，可以很方便的对属于某个或某些个槽的数据库键进行批量操作。

 

#### 4  重新分片

集群重新分片的操作可以将任意数量已经分配给某个节点的槽，改为指向另一个节点，并且所属的键值对也会移动到目标节点。

重新分片的过程中，集群不需要下线，并且源节点和目标节点都是继续处理命令请求。

集群重新分片操作由redis-trib负责执行，步骤如下图：

​     
![img](12.png)<center>*对槽slot进行重新分片的过程*</center>


 

#### 5  复制

Redis集群中的节点分为主节点和从节点。其中主节点用于处理槽，而从节点用于复制某个主节点，并在被复制的主节点下线时，代替主节点继续处理命令请求。

假设现有6个节点集群如下图：

​     
![img](13.png)<center>*集群*</center>


 

各节点如下表：

![img](14.png)

 

当7000下线时，集群中其他主节点会从7000的两个从节点中选出1个作为新的主节点，假如是7004。7004会接管7000负责的槽，并处理客户端发送的命令请求。7005也会从复制7000改为复制7004。当7000重新上线时，它会成为7004的从节点。如下表：

 
![img](15.png)
 

向一个节点发送命令CLUSTER REPLICATE <node_id>会将该节点变为node_id对应节点的从节点。

**1)**    收到该命令的节点会在自己的clusterState.nodes字典中找到node_id对应节点的clusterNode，并将自己的clusterState.myself.slaveof指向该clusterNode，标识自己正在复制该节点。

**2)**    从节点修改自己的clusterState.myself.flags属性，关闭REDIS_NODE_MASTER标识，打开REDIS_NODE_SLAVE标识。

**3)**    从节点调用复制代码（与复制功能相同），复制主节点的状态。

一个节点变成从节点，这个信息会通过消息发送给集群中其他节点，最终节点都会知道某个从节点正在复制某个主节点。

 

#### 6  消息

集群中的消息分为以下五种：

**1)**    MEET消息

发送者收到客户端发送的CLUSTER MEET命令时，会向接收者发送MEET消息，请求接收者加入到发送者当前所处的集群中。

**2)**    PING消息

集群中的节点，每隔1s就会从已知节点列表中随机选择5个节点，然后对其中最长时间没有发送过PING消息的节点发送PING消息，以此来检测被选中的节点是否在线。

除此之外，节点A最后一次收到节点B的PONG消息时间，如果已经超过节点A的cluster-node-timeout时间的一半，节点A也会向节点B发送PING消息，防止节点A长时间没有随机选择B作为PING消息对象而导致节点B的消息更新之后。

**3)**    PONG消息

接收者收到发送者发送的MEET消息或PING消息，为了确认收到，会向发送者返回一条PONG消息。

另外，一个节点也可以像集群广播PONG小让集群中其他节点立刻刷新对此节点的认识。

**4)**    FAIL消息

当一个主节点A判断另一个主节点B已经进入FAIL状态时，主节点A会向集群广播一条关于节点B的FAIL消息，所有收到这条消息的节点会将节点B标记为已下线。

**5)**    PUBLISH消息

当节点接收到PUBLISH消息时，节点会执行这个命令，并向集群广播一条PUBLISH消息，素有接收到这条消息的节点会执行相同的PUBLISH命令。

 
